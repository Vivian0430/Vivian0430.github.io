[{"title":"","date":"2018-12-05T13:34:00.233Z","path":"2018/12/05/http协议、表单处理/","text":"HTTP1.概要1.1. 定义​ HTTP（HyperText Transfer Protocol，超文本传输协议）最早就是计算机与计算机之间沟通的一种标准协议，这种协议限制了通讯内容的格式以及各项内容的含义。默认使用80端口。最新版本是HTTP 2.0，目前是用最广泛的是HTTP 1.1。 ​ HTTP协议： 对客户端和服务器端之间数据传输的格式规范。 ​ 随着时代的发展，技术的变迁，这种协议现在广泛的应用在各种领域，也不仅仅局限于计算机与计算机之间，手机、电视等各种智能设备很多时候都在使用这种协议通讯，所以一般现在称 HTTP 为端与端之间的通讯协议。 ​ Web 属于 B/S 架构的应用软件，在 B/S 架构中，浏览器与服务器沟通的协议就是 HTTP 协议，作为一个合格的Web 开发者，了解 HTTP 协议中约定的内容是一门必修课。 1.2. HTTP协议约定内容1234请求 / 响应报文格式请求方法 —— GET / POST响应状态 —— 200 / 404 / 302 / 304预设的请求 / 响应头 1.3. HTTP协议工作流程12341. 客户端通过随机端口与服务端某个固定端口（一般为80）建立连接 三次握手2. 客户端通过这个连接发送请求到服务端（这里的请求是名词）3. 服务端监听端口得到的客户端发送过来的请求4. 服务端通过连接响应给客户端状态和内容 ​ 要求：接下来的一个月，每次上网打开任何一个页面时都要能够脑补这个画面，默念这个流程。 1.4 HTTP协议的三次握手​ HTTP是基于传输层的TCP协议，而TCP是一个端到端的面向连接的协议。所谓的端到端可以理解为进程到进程之间的通信。所以HTTP在开始传输之前，首先需要建立TCP连接，而TCP连接的过程需要所谓的“三次握手”。 ​ 下图所示TCP连接的三次握手。在TCP三次握手之后，建立了TCP连接，此时HTTP就可以进行传输了。一个重要的概念是面向连接，既HTTP在传输完成之前并不断开TCP连接。在HTTP1.1中(通过Connection头设置)这是默认行为。 1.5 HTTP协议的特点​ 无状态：同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求来自同一个客户端。这意味着，每一个请求的是独立的，任何两个请求之间无任何记忆关系。如果服务端处理一个请求需要前面的信息，则该信息必须重传。 12345//除了上面无状态这个特点，还有几个其他小特点：1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。2. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。3. 在HTTP/1.1之前，使用非持续连接，客户端（浏览器）和服务器每次连接只处理一个请求。服务器处理完客户端的请求，对客户端做出应答后，即断开连接。 HTTP/1.1开始，默认开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。 2.核心概念2.1. 报文2.1.1. 请求报文 请求行 12GET /demo.php HTTP/1.1请求方式 + 空格 + 请求路径 + 空格 + HTTP 协议版本 请求头 ​ 客户端想要告诉服务端的一些额外信息，以下为常见的请求头： 请求体 ​ 这次请求客户端想要发送给服务端的数据正文，只有POST请求才有请求体 2.1.2. 响应报文 状态行 12HTTP/1.1 200 OKHTTP 协议版本 + 空格 + 状态码 + 空格 + 状态描述 响应头 ​ 服务端想要告诉客户端的一些额外信息，常见的有以下： ​ 请求服务端想要返回给客户端的数据正文，一般返回的都是 HTML，也可以返回 JavaScript 或者 CSS（需要修改响应头中的响应类型）。 2.2. 应用场景2.2.1 设置响应文件类型1234567891011121314151617181920212223242526272829303132333435//MIME type 指的是文件类型， 像 text/css ， text/html ， text/plain ， applcation/javascript//1.案例1：设置Content-type为text/html&lt;?php// 设置响应内容为text/html并且设置页面的编码为utf-8，这个会替换掉网页默认的charsetheader('Content-Type: text/html; charset=utf-8');?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;这是一个网页内容&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;这是一个网页内容&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; //2.案例2：设置Content-type为application/javascript&lt;?php// 通过 HTTP 响应头告诉客户端我们给你的内容是 CSS 代码header('Content-Type: application/javascript');?&gt;alert(1);//3.案例3：设置Content-type为text/css&lt;?php// 通过 HTTP 响应头告诉客户端我们给你的内容是 CSS 代码header('Content-Type: text/css');?&gt;body &#123; background-color: hotpink;&#125; 2.2.2 重定向（跳转到其他网页）12345&lt;?php// 注意这边的冒号前面没有空格header('Location: 03-location2.php');//重定向原理 = 302 + 新的location 2.2.3 下载文件123456789101112131415&lt;?php //打开文件 $file = fopen(\"names.txt\", \"r\"); //输入文件标签 Header (\"Content-type: application/octet-stream\"); //Accept-Ranges表明服务器是否接受获取其某个实体的一部分(断点续传)的请求 Header (\"Accept-Ranges: bytes\"); Header (\"Accept-Length: \" . filesize (\"names.txt\")); Header (\"Content-Disposition: attachment; filename=names.txt\"); //输出文件内容 //读取文件内容并直接输出到浏览器 echo fread ( $file, filesize (\"names.txt\") ); fclose ( $file ); exit (); ?&gt; 2.2. 请求方式http://www.w3school.com.cn/tags/html_ref_httpmethods.asphttp://www.runoob.com/http/http-methods.html 2.2.1. GET/POST​ GET：字面意思：拿，获取 ​ POST：发送 2.2.2. 对比GET与POST 12GET请求无害：get是等幂的，无论执行多少遍不影响最终的结果。POST是不等幂的，每次post调用都会创建新的资源。 12345678910111213141516171819202122232425262728293031323334353637383940//IE下GET请求的缓存(POST请求无缓存)：Ajax使用GET方式发送请求时，在IE下会产生缓存。很多情况下，ajax都会获取实时数据，如果存在缓存问题，就会影响数据真实性。可使用以下两种方式清除缓存：1.URL随机后缀：在get请求时增加一个随机后缀，用来区分每一次访问的URL地址 $.ajax(&#123; type: \"GET\", url: \"http://localhost/index.php?s=\"+Math.random(), data: null, success: function(data)&#123; console.log(data); &#125; &#125;); //在jquery中可以通过$.ajaxSetup(&#123;cache:false&#125;)去除get请求缓存 $.ajaxSetup(&#123;cache:false&#125;); $(\"#box\").click(function()&#123; $.ajax(&#123; type: \"GET\", url: \"http://localhost/index.php\", data: null, success: function(data)&#123; console.log(data); &#125; &#125;); &#125;) 2.还可以在后台PHP程序中设置不进行数据缓存 &lt;?php header('Content-Type: application/json'); /*跨域访问的问题*/ header(\"Access-Control-Allow-Origin: *\"); /*禁止浏览器缓存*/ header('cache-controller:no-cache'); header('Pragam:no-cache'); header('Expires:-1'); $raw_success = array('code' =&gt; 1, 'msg' =&gt; '验证码正确'); $res_success = json_encode($raw_success); echo $res_success; ?&gt; 2.3. 状态码 http://www.w3school.com.cn/tags/html_ref_httpmessages.asp ​ 状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。 123451xx：指示信息 —— 表示请求已接收，继续处理。2xx：成功 —— 表示请求已被成功接收、理解、接受。3xx：重定向 —— 要完成请求必须进行更进一步的操作。4xx：客户端错误 —— 请求有语法错误或请求无法实现。5xx：服务器端错误 —— 服务器未能实现合法的请求 ​ 常见状态代码、状态描述的说明如下 123456789200 OK：客户端请求成功。/*客户端错误*/400 Bad Request：客户端请求有语法错误，不能被服务器所理解。401 Unauthorized：请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用。403 Forbidden：服务器收到请求，但是拒绝提供服务。404 Not Found：请求资源不存在，举个例子：输入了错误的URL。/*服务器错误*/500 Internal Server Error：服务器发生不可预期的错误。503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常。 2.4.HTTPS1234567891011#HTTPS协议：简单来说，可以理解为安全版的HTTP协议，基于TCP/IP协议和SSL/TLS协议之上的应用层协议。默认端口443。#HTTP协议和HTTPS协议的区别1.HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此HTTP协议不适合传输一些敏感信息，比如密码等。2.HTTPS为安全套接字层超文本传输协议。HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。 #HTTPS和HTTP的区别主要为以下四点：1.https协议需要到ca申请证书，一般免费证书很少，需要交费。2.http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。3.http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。4.http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 表单处理​ 表单的概念在生活中很常见，就像是问卷调查表一样，别人先把问卷发给你，你照着问卷的要求填写，完事过后再将填完的问卷发给别人，从而达到一个将别人需要的信息传递给别人的一种方式。 ​ 传统的网页大多数的作用都是展示数据，就是将信息传递给用户。而在现代化的 Web 开发中，非常注重信息交互，所以表单也随处可见，只是形式上变成网页，性质上还是一模一样的。主要的作用任然是收集指定的用户信息。 ​ 信息交互：例如简书这个平台，除了展示文章（展示信息），还可以发布文章（收集信息） 1.表单基本使用​ HTML 中有一个专门用于提交数据的标签：form，通过这个标签可以很容易的收集用户输入。 123//form 标签有两个必要属性：1.action：表单提交地址（填完了，交给谁）2.method：表单以什么方式提交 ​ 例如，我们需要在登录界面上收集用户输入的用户名和密码 1234567891011121314#1.form.php&lt;body&gt; &lt;form action=\"login.php\" method=\"post\"&gt; &lt;div&gt; &lt;label for=\"username\"&gt;用户名&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"password\"&gt;密码&lt;/label&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt; &lt;/form&gt;&lt;/body&gt; ​ 按照目前的情况，用户第一次请求得到这个表单页面，填写完表单内容，点击登录，表单会自动发送到login.php ，剩下的问题就是要考虑如何在 login.php 中获取到用户提交过来的内容。 1234//PHP中有三个超全局变量专门用来获取表单提交内容：$_GET ：用于获取以 GET 方式提交的内容，更标准的说法：接收 URL 地址问号参数中的数据$_POST ：用于获取以 POST 方式提交的内容，更标准的说法：接收 请求体 中的数据$_REQUEST ：用于获取 GET 或 POST 方式提交的内容 ​ 借助 助 $_POST $_GET 或者 $_REQUEST 就可以获取到表单提交的内容： 123456789101112#login.php&lt;?phpvar_dump($_GET);// $_GET 用于接收 URL 地址中的提交数据（一般是 GET 参数）var_dump($_POST);// $_POST 用于接收 请求体 中提交的数据（一般是 POST 提交的数据）var_dump($_REQUEST);// $_REQUEST = $_GET + $_POST// 获取表单提交的用户名和密码echo '用户名：' . $_REQUEST['username'];echo '密码：' . $_REQUEST['password']; 2. 表单提交地址​ action 提交地址指的是这个表单填写完成过后点击提交，发送请求的请求地址是什么。 从便于维护的角度考虑，一般我们最常见的都是提交给当前文件，然后在当前文件中判断是否是表单提交请求： 123456789&lt;!‐‐ 这样写死 action 地址，当文件重命名就需要修改代码 ‐‐&gt;&lt;form action=\"/foo/login.php\"&gt; ... &lt;/form&gt; &lt;!‐‐ 通过 `$_SERVER['PHP_SELF']` 获取路径，可以轻松避免这个问题 ‐‐&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\"&gt; ...&lt;/form&gt; 12345678910111213141516171819202122&lt;?php// 将表单的处理逻辑放在HTML之前，为了更灵活的控制HTML的输出// var_dump($_POST);// 因为对于表单的处理逻辑不是每一次都需要执行，// 所以一般我们会判断请求的方式，从而决定是否执行对数据的处理if ($_SERVER['REQUEST_METHOD'] === 'POST') &#123; // 请求的方式是 POST，当前是点击按钮产生的请求 var_dump($_POST);&#125;?&gt; &lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\"&gt; &lt;div&gt; &lt;label for=\"username\"&gt;用户名&lt;/label&gt; &lt;input type=\"text\" id=\"username\" name=\"username\"&gt; &lt;/div&gt; &lt;div&gt; &lt;label for=\"password\"&gt;密码&lt;/label&gt; &lt;input type=\"password\" id=\"password\" name=\"password\"&gt; &lt;/div&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt; &lt;/form&gt; 3. 提交方式​ method 可以用于设置表单提交的方式，目前我们所认识的就是最常见两种表单提交方式： GET 和 POST 。 从效果上来看，两者都可以将数据提交到服务端，但是从实现提交的原理上两者有很大的不同： 3.1. GET123表单数据是通过 URL 中的 ? 参数传递到服务端的可以在地址栏中看到提交的内容数据长度有限制，因为 URL 地址长度有限（2000个字符） 3.2 POST123表单数据是通过请求体传递到服务端的，我们在界面上看不到可以提交任何类型的数据，包括文件由于界面上看不见，浏览器也不储存，所以更安全 ​ 至于什么情况下应该选用哪种方式，这个需要结合业务场景和这两种方式各自的特点来决定，没有绝对的答案，只能给出一些原则： 12绝不能使用 GET 来发送密码或其他敏感信息！！！应该想清楚这次请求到底主要是去拿东西，还是去送东西 4. 常见表单元素处理​ 至于表单元素中的文本框文本域一类的元素，都是直接将元素的 name 属性值作为键，用户填写的信息作为值，发送到服务端。 但是表单元素中还有一些比较特殊的表单元素需要单独考虑。 4.1. 单选按钮123&lt;!‐‐ 最终只会提交选中的那一项的 value ‐‐&gt;&lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt;&lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 4.2. 复选按钮1234&lt;!‐‐ 没有设置 value 的 checkbox 选中提交的 value 是 on ‐‐&gt;&lt;input type=\"checkbox\" name=\"agree\"&gt;&lt;!‐‐ 设置了 value 的 checkbox 选中提交的是 value 值 ‐‐&gt;&lt;input type=\"checkbox\" name=\"agree\" value=\"true\"&gt; ​ 如果需要同时提交多个选中项，可以在 name 属性后面 跟上 [] ：http://php.net/manual/zh/faq.html.php#faq.html.arrays 12345&lt;input type=\"checkbox\" name=\"funs[]\" value=\"football\"&gt;&lt;input type=\"checkbox\" name=\"funs[]\" value=\"basketball\"&gt;&lt;input type=\"checkbox\" name=\"funs[]\" value=\"world peace\"&gt;//最终提交到服务端，通过 $_POST 接收到的是一个索引数组。 4.3. 选择框123456&lt;select name=\"subject\"&gt; &lt;!‐‐ 设置 value 提交 value ‐‐&gt; &lt;option value=\"1\"&gt;语文&lt;/option&gt; &lt;!‐‐ 没有设置 value 提交 innerText ‐‐&gt; &lt;option&gt;数学&lt;/option&gt;&lt;/select&gt; 4.4 表单提交案例123456789101112131415161718192021222324252627282930313233343536&lt;?phpif ($_SERVER['REQUEST_METHOD'] === 'POST') &#123; var_dump($_POST);&#125;?&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" id=\"\"&gt; &lt;input type=\"password\" name=\"password\" id=\"\"&gt; &lt;textarea name=\"key2\" id=\"\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;!-- 当表单中使用了radio，一定要为相同name的radio设置不同的value，让服务端可以辨别 --&gt; 性别： &lt;label&gt;&lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 男&lt;/label&gt; &lt;label&gt;&lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; 女&lt;/label&gt; &lt;br&gt; &lt;!-- checkbox 如果没有选中则不会提交，如果选中提交 on --&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"agree\"&gt; 同意协议&lt;/label&gt; &lt;br&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"funs[]\" value=\"football\"&gt; 足球&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"funs[]\" value=\"basketball\"&gt; 篮球&lt;/label&gt; &lt;label&gt;&lt;input type=\"checkbox\" name=\"funs[]\" value=\"earth\"&gt; 地球&lt;/label&gt; &lt;br&gt; &lt;select name=\"status\"&gt; &lt;option&gt;激活&lt;/option&gt; &lt;option&gt;未激活&lt;/option&gt; &lt;option value=\"1\"&gt;待激活&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;input type=\"file\" name=\"\" id=\"\"&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; 4.5. 用户注册案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpfunction postback () &#123; // 申明 $message 是全局 // global $message; // 1. 校验参数的完整性 if (empty($_POST['username'])) &#123; // 没有提交用户名 或 用户名为空字符串 $GLOBALS['message'] = '会不会玩'; return; &#125; if (empty($_POST['password'])) &#123; $GLOBALS['message'] = '请输入密码'; return; &#125; if (empty($_POST['confirm'])) &#123; $GLOBALS['message'] = '请输入确认密码'; return; &#125; if ($_POST['password'] !== $_POST['confirm']) &#123; $GLOBALS['message'] = '两次输入的密码不一致'; return; &#125; if (!(isset($_POST['agree'])) &#123; $GLOBALS['message'] = '必须同意注册协议'; return; &#125; // 所有的校验都OK $username = $_POST['username']; $password = $_POST['password']; // 将数据保存到文本文件中 file_put_contents('users.txt', $username . '|' . $password . \"\\n\", FILE_APPEND); $GLOBALS['message'] = '注册成功';&#125;if ($_SERVER['REQUEST_METHOD'] === 'POST') &#123; postback();&#125;?&gt;/*register.php*/&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\"&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;&lt;label for=\"username\"&gt;用户名&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\" id=\"username\" value=\"&lt;?php echo isset($_POST['username']) ? $_POST['username'] : ''; ?&gt;\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label for=\"password\"&gt;密码&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\" id=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label for=\"confirm\"&gt;确认密码&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"confirm\" id=\"confirm\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;label&gt;&lt;input type=\"checkbox\" name=\"agree\" value=\"on\"&gt; 同意注册协议&lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;!--错误消息提示--&gt; &lt;?php if (isset($message)): ?&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $message; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endif ?&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;button&gt;注册&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 5.文件上传5.1 文件上传的基本实现1234567891011121314151617181920212223242526#文件上传的三要素：1.提供一个上传的表单控件2.请求方式是POST3.请求的enctype为multipart/form-data#enctype为multipart/form-data和application/x-www-form-urlencoded区别：1.multipart/form-data ： 表单数据被编码为一条消息，页上的每个控件对应消息中的一个部分。 2.application/x-www-form-urlencoded ： 表单数据被编码为名称/值对，这是标准的编码格式。#multipart/form-data下的数据拼接格式如下：先确定一个分隔符：boundary=aaaaa --aaaaa Content-Disposition:form-data;name=”username”zhangsan --aaaaa Content-Disposition:form-data;name=”password”123--aaaaa Content-Disposition: form-data; name=\"icon\"; filename=\"xx.png\"Content-Type: image/png…sisdhs..ssjsdjisad.sidshidhdsi.sahdsisda.adhidsahdsiahdsaihdsahda 图片数据..--aaaaa-- 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpfunction upload () &#123; if (!isset($_FILES['avatar'])) &#123; $GLOBALS['message'] = '别玩我了'; // 客户端提交的表单内容中根本没有文件域 return; &#125; $avatar = $_FILES['avatar']; echo $avatar['error']; if ($avatar['error'] !== UPLOAD_ERR_OK) &#123; // 服务端没有接收到上传的文件 $GLOBALS['message'] = '上传失败'; return; &#125; // 接收到了文件 // 将文件从临时目录移动到网站范围之内 $source = $avatar['tmp_name']; // 源文件在哪 // =&gt; 'C:\\Windows\\Temp\\php1138.tmp' $target = './uploads/' . $avatar['name']; // 目标放在哪 // =&gt; './uploads/icon-02.png' // 移动的目标路径中文件夹一定是一个已经存在的目录 $moved = move_uploaded_file($source, $target); if (!$moved) &#123; $GLOBALS['message'] = '上传失败'; return; &#125; // 移动成功（上传整个过程OK）&#125;if ($_SERVER['REQUEST_METHOD'] === 'POST') &#123; // 接收文件 使用一个 叫做 $_FILES 超全局成员 upload();&#125; &lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"avatar\"&gt; &lt;button&gt;上传&lt;/button&gt; &lt;?php if (isset($message)): ?&gt; &lt;p style=\"color: hotpink\"&gt;&lt;?php echo $message; ?&gt;&lt;/p&gt; &lt;?php endif ?&gt;&lt;/form&gt; 1234567891011# $_FILES 同样也是一个关联数组，键为表单的name，内容如下：array(1) &#123; [\"avatar\"]=&gt; array(5) &#123; [\"name\"]=&gt;string(17) \"demo.jpg\" [\"type\"]=&gt;string(10) \"image/jpeg\" [\"tmp_name\"]=&gt;string(27) \"C:\\Windows\\Temp\\php786C.tmp\" [\"error\"]=&gt; int(0) [\"size\"]=&gt; int(29501) &#125;&#125; 5.2 文件上传的配置1234http://php.net/manual/zh/features.file-upload.php1.修改 php.ini 中的 post_max_size 配置，让服务端可以接受更大的请求体体积2.修改 php.ini 中的 upload_max_filesize 配置，让服务端支持更大的单个上传文件 6.音乐列表案例 基于文件存储的音乐数据增删改查 6.1. 数据放在哪​ 绝大多数情况下我们编写的应用功能都是在围绕着某种类型的数据做增删改查（Create / Read / Update /Delete）。 ​ 我们第一件事就是考虑数据放在哪，如何存取？ 目前我们接触到的技术方案中，只有文件可以持久化的保存内容（数据），所以一定是用文件存我们要操作的数据。 ​ 但是由于我们要存放的是一个有着复杂结构的数据，并不是简简单单的值，所以我们必须设计一种能表示复杂结构数据的方式。 ​ 例如，一行为一条数据，不同信息之间用 | 分割，同时约定好每个位置的数据含义： 123459d632855434e | 错过 | 梁咏琪 | /uploads/img/1.jpg | /uploads/mp3/1.mp359d632855434f | 开始懂了 | 孙燕姿 | /uploads/img/2.jpg | /uploads/mp3/2.mp359d6328554350 | 一生中最爱 | 谭咏麟 | /uploads/img/3.jpg | /uploads/mp3/3.mp359d6328554351 | 爱在深秋 | 谭咏麟 | /uploads/img/4.jpg | /uploads/mp3/4.mp3 ​ 这种方式很简单，但是缺点也非常明显，需要手动读取数据进行分割，所以我们迫切需要一个更好更方便的表示有结构数据的方式。 6.2. JSON​ JSON（JavaScript Object Notation） 是一种通过普通字符串描述数据的手段，用于表示有结构的数据。JSON是JavaScript的原生对象，类似于JS中字面量的概念，语法上跟 JavaScript 的字面量非常类似。 6.2.1. JSON对象的数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#1.JSON对象的key始终是字符串#2.JSON对象的值可以是以下类型1.null2.string : \"hello json\"3.number : 20484.boolean : true5.object6.array#3.JSON对象和JSON字符串#3.1 JSON格式的js对象/*我们可以把这个称做：JSON格式的JavaScript对象 */var obj5=&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;; /*我们可以把这个称做：JSON格式的字符串 */var str1='&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;';#3.2 JSON格式的数组/*这个叫JSON格式的数组，是JSON的稍复杂一点的形式 */var a=[ &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, &#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;, ];/* 这个叫稍复杂一点的JSON格式的字符串 */var str2='['+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ '&#123;\"width\":100,\"height\":200,\"name\":\"rose\"&#125;,'+ ']' ; #4.JSON对象的注意点1. JSON 中属性名称必须用双引号包裹2. JSON 中字符串必须使用双引号,width\\height等必须是双引号3. JSON 中不能有单行或多行注释4. JSON 没有 undefined 这个值#5.JS中JSON对象和JSON字符串的相互转换//JS中，对象转字符串 JSON.stringify(对象)//JS中，字符串转对象 JSON.parse(字符串)#6.PHP中JSON字符串和PHP对象的转换#6.1 php中将PHP变量转换为字符串json_encode( mixed value[,intoptions = 0 ]) 对变量进行JSON编码，第二个参数一般不用$book = array('a'=&gt;'xiyouji','b'=&gt;'sanguo','c'=&gt;'shuihu','d'=&gt;'hongloumeng');$json = json_encode($book);echo $json;#6.2 php中将JSON字符串转换为PHP变量json_decode(string json[,boolassoc ]) :接受一个JSON格式的字符串并且把它转换为PHP变量 如果希望以关联数组的方式而非对象的方式操作数据，可以将 json_decode 的第二个参数设置为 true$obj = json_decode($json,true);var_dump($obj); 6.2.2. JSON 表述数据​ 有了 JSON 这种格式，我们就可以更加容易的表示拥有复杂结构的数据了。 12345678910111213141516171819202122232425262728293031323334[ &#123; \"id\": \"59d632855434e\", \"title\": \"错过\", \"artist\": \"梁咏琪\", \"images\": [\"/uploads/img/1.jpg\"], \"source\": \"/uploads/mp3/1.mp3\" &#125;, &#123; \"id\": \"59d632855434f\", \"title\": \"开始懂了\", \"artist\": \"孙燕姿\", \"images\": [\"/uploads/img/2.jpg\"], \"source\": \"/uploads/mp3/2.mp3\" &#125;, &#123; \"id\": \"59d6328554350\", \"title\": \"一生中最爱\", \"artist\": \"谭咏麟\", \"images\": [\"/uploads/img/3.jpg\"], \"source\": \"/uploads/mp3/3.mp3\" &#125;, &#123; \"id\": \"59d6328554351\", \"title\": \"爱在深秋\", \"artist\": \"谭咏麟\", \"images\": [\"/uploads/img/4.jpg\"], \"source\": \"/uploads/mp3/4.mp3\" &#125;][&#123;\"title\":\"zhangjie\",\"artist\":\"zhangjie\",\"images\":[\"uploads\\/bb.png\"],\"source\":\"uploads\\/\\u5f20\\u6770 - \\u6211\\u7684\\u672a\\u6765\\u4e0d\\u662f\\u68a6 (\\u4f34\\u594f).mp3\"&#125;,&#123;\"title\":\"22\",\"artist\":\"222\",\"images\":[\"uploads\\/bb.png\"],\"source\":\"uploads\\/\\u5f20\\u6770 - \\u6211\\u7684\\u672a\\u6765\\u4e0d\\u662f\\u68a6 (\\u4f34\\u594f).mp3\"&#125;] 6.3. 功能实现​ 在服务端开发领域中所谓的渲染指的是经过程序执行得到最终的 HTML 字符串这个过程。 6.3.1. 列表数据展示（展示类）1234567891011121314151617181920212223242526272829303132&lt;?php // 1. 读取文件内容 $json = file_get_contents('data.json'); // 2. 反序列化 // json_decode 第二个参数可以用来指定返回数据都采用 关联数组的方式 描述对象 $data = json_decode($json, true); // 3. 遍历数据渲染HTML // var_dump($data); if (!$data) &#123; // JSON 格式不正确 exit('数据文件异常'); &#125;?&gt;&lt;tbody class=\"text-center\"&gt; &lt;?php foreach ($data as $item): ?&gt; &lt;tr&gt; &lt;td class=\"text-center\"&gt;&lt;input type=\"checkbox\" name=\"\" id=\"\"&gt;&lt;/td&gt; &lt;td class=\"align-middle\"&gt;&lt;?php echo $item['title']; ?&gt;&lt;/td&gt; &lt;td class=\"align-middle\"&gt;&lt;?php echo $item['artist']; ?&gt;&lt;/td&gt; &lt;td class=\"align-middle\"&gt; &lt;?php foreach ($item['images'] as $img): ?&gt; &lt;img src=\"&lt;?php echo $img; ?&gt;\" alt=\"\"&gt; &lt;?php endforeach ?&gt; &lt;/td&gt; &lt;td class=\"align-middle\"&gt;&lt;audio src=\"&lt;?php echo $item['source']; ?&gt;\" controls&gt;&lt;/audio&gt;&lt;/td&gt; &lt;td class=\"align-middle\"&gt; &lt;a class=\"btn btn-outline-danger btn-sm\" href=\"del.php?id=&lt;?php echo $item['id']; ?&gt;\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach ?&gt;&lt;/tbody&gt; 6.3.2. 新增数据（表单类）123456781.表单普通字段的处理 empty 判断一个成员是否没定义或者值为 false（可以隐式转换为 false）2.上传文件的处理 文件数量 文件种类 如果需要考虑文件重名的情况，可以给上传的文件重新命名（唯一名称）3.单文件域多文件的上传 name 一定 以 [] 结尾，服务端会接收到一个数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;?php header(\"Content-type:text/html;charset=utf-8\"); //添加音乐的功能 function doadd()&#123; //表单验证 if(empty($_POST['title']))&#123; $GLOBALS['message'] = \"请输入标题\"; return; &#125; if(empty($_POST['artist']))&#123; $GLOBALS['message'] = \"请输入歌手\"; return; &#125; //创建一个$d用于存放用户上传的数据 $d['title'] = $_POST['title']; $d['artist'] = $_POST['artist']; //存放图片数组 $d['images'] = []; //验证图片的上传 $images = $_FILES['images']; $errors = $images['error']; foreach ($errors as $key=&gt;$error) &#123; //验证图片上传有没有错 if($error !== UPLOAD_ERR_OK)&#123; $GLOBALS['message'] = \"上传文件出错\"; return ; &#125; //上传文件的类型判断:我们期望用户所上传文件是以image开头的 $type = $images['type'][$key]; if(strpos($type, \"image/\") !== 0)&#123; $GLOBALS['message'] = \"上传文件类型错误\"; return ; &#125; //验证图片的大小 $size = $images['size'][$key]; if($size &gt; 2*1024*1024)&#123; $GLOBALS['message'] = \"上传文件太大了\"; return ; &#125; //上传成功了，保存图片 $sourceimg = $images['tmp_name'][$key]; $sourcename = $images['name'][$key]; //注意图片的中文问题 $dest = \"uploads/\" . iconv('UTF-8', 'GBK', $sourcename); if(move_uploaded_file($sourceimg, $dest))&#123; $GLOBALS['message'] = \"上传文件成功\"; $d['images'][] = iconv('GBK', 'UTF-8', $dest); &#125;; &#125; //音频数据的处理 $source = $_FILES['source']; //音频上传是否出错 if($source['error'] !== UPLOAD_ERR_OK)&#123; $GLOBALS['message'] = \"音频文件出错\"; return ; &#125; //如果没有错，则保存音频信息 $sourcefile = $source['tmp_name']; $sourcename = $source['name']; $dest1 = \"uploads/\" . iconv('UTF-8', 'GBK', $sourcename); //move_uploaded_file 里面路径如果有中文需要以GBK形式去编码 if(move_uploaded_file($sourcefile, $dest1))&#123; $GLOBALS['message'] = \"上传音频文件成功\"; //向$d中追加音频的数据 $d['source'] = iconv('GBK', 'UTF-8', $dest1); &#125;; //如果上面步骤都成功了，需要将$d数据写入到json文件中 //var_dump($d); //将用户提交音乐的信息写入到data.json中 $str = file_get_contents(\"data.json\"); $arr = json_decode($str,true); $arr[] = $d; $str = json_encode($arr); file_put_contents(\"data.json\", $str); //重新来到列表页面 header(\"Location: list.php\"); &#125; if($_SERVER['REQUEST_METHOD'] === 'POST')&#123; doadd(); &#125;?&gt; //add.php &lt;?php if (isset($error_message)): ?&gt;&lt;div class=\"alert alert-danger\"&gt; &lt;?php echo $error_message; ?&gt;&lt;/div&gt;&lt;?php endif ?&gt; &lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"title\"&gt;标题&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"title\" name=\"title\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"artist\"&gt;歌手&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"artist\" name=\"artist\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"images\"&gt;海报&lt;/label&gt; &lt;!-- multiple 可以在一个输入框中选择多个文件进行上传 --&gt; &lt;input type=\"file\" class=\"form-control\" id=\"images\" name=\"images[]\" accept=\"image/*\" multiple&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"source\"&gt;音乐&lt;/label&gt; &lt;!-- accept 可以设置两种值分别为 MIME Type / 文件扩展名 --&gt; &lt;input type=\"file\" class=\"form-control\" id=\"source\" name=\"source\" accept=\"audio/*\"&gt; &lt;/div&gt; &lt;button class=\"btn btn-primary btn-block\"&gt;保存&lt;/button&gt;&lt;/form&gt; 6.3.3. 删除数据12341.删除数据的思路：一般情况下，如果需要超链接点击发起的请求可以传递参数，我们可以采用 ? 的方式&lt;a href=\"/delete.php?id=123\"&gt;删除&lt;/a&gt; 2.array_splice(array,start,length,array)：从数组中移除元素，并用新元素取代它 123456789101112131415161718192021222324252627282930313233&lt;?php// 如何知道客户端想要删除哪一个数据：通过客户端在URL地址中的问号参数的不同来辨别要删除的数据// 接收 URL 中的不同的 IDif (empty($_GET['id'])) &#123; // 没有传递必要的参数 exit('&lt;h1&gt;必须指定参数&lt;/h1&gt;');&#125;$id = $_GET['id'];// 找到要删除的数据$data = json_decode(file_get_contents('data.json'), true);foreach ($data as $item) &#123; // 不是我们要的之间找下一条 if ($item['id'] !== $id) continue; // $item =&gt; 我们要删除的那一条数据 // 从原有数据中移除 $index = array_search($item, $data); array_splice($data, $index, 1); // 保存删除指定数据过后的内容 // echo '&lt;pre&gt;'; // var_dump($data); // echo '&lt;/pre&gt;'; $json = json_encode($data); file_put_contents('data.json', $json); // 跳转回列表页 header('Location: list.php');&#125; 7.参考链接HTML 中的 form 标签：http://www.w3school.com.cn/html/html_forms.aspPHP 中处理表单：http://www.w3school.com.cn/php/php_forms.asp HTTP 会话 Cookie技术：会话数据保存在浏览器客户端。 Session技术：会话数据保存在服务器端。 1.Cookie1.1 Cookie介绍​ HTTP 很重要的一个特点就是无状态（每一次见面都是“初次见面”），如果单纯的希望通过我们的服务端程序去记住每一个访问者是不可能的，所以必须借助一些手段或者说技巧让服务端记住客户端，这种手段就是 Cookie。 ​ Cookie 就像是在超级市场买东西拿到的小票，由超市（Server）发给消费者（Browser），超市方面不用记住每一个消费者的脸，但是他们认识消费者手里的小票（Cookie），可以通过小票知道消费者之前的一些消费信息（在服务端产生的数据）。 http://php.net/manual/zh/function.setcookie.php 1.2 Cookie的基本使用1234567891011121314#Cookie的创建&lt;?php//1.创建Cookie，该cookie关闭浏览器就销毁setcookie('key', 'value');//2.设置Cookie的有效时间：如果不设置有效时间默认就是会话级别的 Cookie(关闭浏览器就自动删除）setcookie('key2', 'value2', time() + 1 * 24 * 60 * 60);//3.Cookie的删除:只传递一个参数是删除Cookie// 原理：设置过期时间为一个过去时间setcookie('key');#Cookie的获取&lt;?php// 关联数组的方式访问客户端提交过来的 Cookievar_dump($_COOKIE); 1.3 Cookie的使用细节12345678910111213141516#设置Cookie的Path1.setcookie('key3', 'value3', time() + 1 * 24 * 60 * 60, '/users');2.path的含义/ ----&gt;网站根目录的所有url都可以访问这个Cookie/users ----&gt;users开头的url可以访问这个Cookie#设置Cookie的domain1.setcookie('key4', 'value4', time() + 1 * 24 * 60 * 60, '/users', 'day-10.io');2.domain的含义:设置cookie的作用域名范围 day-10.io ----&gt;所有day-10.io的所有子域可以访问 //例如aa.day-10.io是day-10.io的子域名 //例如bb.day-10.io是day-10.io的子域名 //但是day-10.aa.io不是day-10.io的子域名#Cookie的局限Cookie数据类型只能保存非中文字符串类型的，如果非要保存中文，需要转码。可以保存多个cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。 1.4 Cookie使用案例1.4.1.点击按钮屏蔽广告1234567891011121314151617181920212223242526272829303132//index.php&lt;?phpif (isset($_GET['action']) &amp;&amp; $_GET['action'] === 'close-ad') &#123; // 不想看到广告 setcookie('hide_ad', '1'); $_COOKIE['hide_ad'] === '1';&#125;?&gt; &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .ad &#123; height: 200px; background-color: #ff0; &#125; .ad a &#123; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;?php if (empty($_COOKIE['hide_ad']) || $_COOKIE['hide_ad'] !== '1'): ?&gt; &lt;div class=\"ad\"&gt; &lt;a href=\"index.php?action=close-ad\"&gt;不再显示&lt;/a&gt; &lt;/div&gt; &lt;?php endif ?&gt;&lt;/body&gt;&lt;/html&gt; 1.4.2 记住登录网站的用户名 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#参考豆瓣的记住用户名&lt;?php function docookie()&#123; //如果没有输入用户名密码，返回 if(empty($_POST['name']))&#123; $GLOBALS['message'] = '用户名不能为空'; return; &#125; if(empty($_POST['pwd']))&#123; $GLOBALS['message'] = '密码不能为空'; return; &#125; $name = $_POST['name']; $pwd = $_POST['pwd']; //如果勾选了自动登录，创建cookie if(!empty($_POST['rmbname']))&#123; $remember = $_POST['rmbname']; if($remember == \"on\")&#123; setcookie('name',$name,time()+3600); &#125; &#125; //如果没有勾选自动登录，销毁cookie else&#123; setcookie('name'); &#125; //如果账号密码正确，跳转用户页面 if($name === \"zhangsan\" &amp;&amp; $pwd === \"123\")&#123; header('Location: user.php'); &#125; &#125; if ($_SERVER['REQUEST_METHOD'] === 'POST') &#123; // 请求的方式是 POST，当前是点击按钮产生的请求 docookie(); &#125;?&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\"&gt; 用户名: &lt;?php if(!empty($_COOKIE['name'])): ?&gt; &lt;input type=\"text\" name=\"name\" value=\"&lt;?php echo $_COOKIE['name'] ?&gt;\"&gt;&lt;br/&gt; &lt;?php else : ?&gt; &lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; &lt;?php endif ?&gt; 密码:&lt;input type=\"text\" name=\"pwd\"&gt;&lt;br/&gt; &lt;input type=\"checkbox\" name=\"rmbname\"&gt;记住用户名&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;br&gt; &lt;?php if(!empty($GLOBALS['message'])): ?&gt; &lt;?php echo $message; ?&gt; &lt;?php endif ?&gt; &lt;/form&gt; 1.4.3. 记住上次的访问时间 12345678910111213141516171819202122232425262728&lt;?php date_default_timezone_set('PRC'); $time = date('y-m-d h:i:s'); setcookie(\"lastTime\",$time,time()+7*24*60*60);?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--怎么区分第一次和第n次访问--&gt; &lt;?php if(!empty($_COOKIE['lastTime'])): ?&gt; &lt;div&gt; 欢迎回来，您上次的访问事件是 &lt;?php echo $_COOKIE['lastTime']; ?&gt; &lt;/div&gt; &lt;?php else: ?&gt; &lt;div&gt; 您是首次访问本网站，当前时间是: &lt;?php date_default_timezone_set('PRC'); echo date('y-m-d h:i:s'); ?&gt; &lt;/div&gt; &lt;?php endif ?&gt;&lt;/body&gt;&lt;/html&gt; 2.Session2.1 Session介绍​ 由于 Cookie 是服务端下发给客户端由客户端本地保存的。换而言之客户端可以在本地对其随意操作，包括删除和修改。如果客户端随意伪造一个 Cookie 的话，对于服务端是无法辨别的，就会造成服务端被蒙蔽，构成安全隐患。而且Cookie只能保存非中文的字符串类型的数据，而且有严格的大小限制，决定了Cookie的使用场景会相对局限。 于是乎就有了另外一种基于 Cookie 基础之上的手段：Session ​ Session 区别于 Cookie 一个很大的地方就是：Session 数据存在了服务端，而 Cookie 存在了客户端本地，存在服务端最大的优势就是，不是用户想怎么改就怎么改了。 http://php.net/manual/zh/session.examples.basic.php 123456789101112131415161718192021222324252627282930313233343536373839404142#1.开启会话//给当前用户找一个属于他的箱子（没有箱子开箱子，有箱子找已有的箱子）session_start();#2.设置当前会话信息&lt;?phpsession_start();#2.1 session中保存普通字段$_SESSION['key1'] = 'value1';$_SESSION['age'] = 100;$_SESSION['isBoy'] = true;#2.2 session中保存数组$arr1 = array(\"北京\",\"小明\",\"hello\");$_SESSION['arr1'] = $arr1;#2.3 session中保存对象class Dog&#123; private $name; private $age; private $intro; function __construct($name,$age,$intro)&#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;intro = $intro; &#125;&#125; $dog1 = new Dog(\"大黄\",2,\"很听话\");$_SESSION['dog1'] = $dog1;//注意：在脚本结束的时候会执行SESSION写入操作，把$_SESSION中值写入到session_id命名的文件中，可能已经存在，可能需要创建新的文件。//可以在php.ini中的session.save_path指定的文件夹里去找名字为'SESS_'.session_id()的文件.//可以通过session_id()方法来查看session的id信息#3.获取当前会话中的信息&lt;?phpsession_start();foreach($_SESSION as $key=&gt;$value)&#123; echo $key . \":\"; var_dump($value); echo \"&lt;br/&gt;\";&#125; 2.2 Session的主要用途​ Session主要用于在服务端保存会话过程中的数据，一般用于多个页面之间的数据共享。 1234567891011121314151617181920212223242526//1.save.php&lt;?php session_start(); $_SESSION['name'] = 'TOM'; $_SESSION['age'] = 100;?&gt;//2.get.php&lt;?php session_start(); echo $_SESSION['name']; echo $_SESSION['age'];?&gt;//3.update.php&lt;?php session_start(); $_SESSION['name'] = 'CAT';?&gt;//4.delete.php&lt;?php session_start(); //unset($_SESSION['name']); session_destroy();?&gt; 2.3 Session登录案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#1.login.php&lt;?php function doLogin()&#123; session_start(); //如果没有输入用户名密码，返回 if(empty($_POST['name']))&#123; $GLOBALS['message'] = '用户名不能为空'; return; &#125; if(empty($_POST['pwd']))&#123; $GLOBALS['message'] = '密码不能为空'; return; &#125; $name = $_POST['name']; $pwd = $_POST['pwd']; //如果账号密码正确，将当前用户信息保存到Session中并跳转用户页面 if($name === \"zhangsan\" &amp;&amp; $pwd === \"123\")&#123; //其实这边的登录操作应该根据账号和密码从数据库查询是否有指定的用户再做登录 //这里面只是模拟登录操作 $userinfo = array( 'uid' =&gt; 10000, 'name' =&gt; 'zhangsan', 'pwd' =&gt; '123', 'email' =&gt; 'zhangsan@qq.com', 'sex' =&gt; 'gender', 'age' =&gt; '18' ); $_SESSION['uid'] = $userinfo['uid']; $_SESSION['name'] = $userinfo['name']; $_SESSION['userinfo'] = $userinfo; header('Location: usercenter.php'); &#125; &#125; if ($_SERVER['REQUEST_METHOD'] === 'POST') &#123; // 请求的方式是 POST，当前是点击按钮产生的请求 doLogin(); &#125;?&gt;&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"name\"&gt;&lt;br/&gt; 密码:&lt;input type=\"text\" name=\"pwd\"&gt;&lt;br/&gt; &lt;input type=\"checkbox\" name=\"rmbname\"&gt;记住用户名&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"&gt;&lt;br&gt; &lt;?php if(!empty($GLOBALS['message'])): ?&gt; &lt;?php echo $message; ?&gt; &lt;?php endif ?&gt; &lt;/form&gt; 1234567891011121314151617181920212223#2.usercenter.php&lt;?phpheader('Content-Type:text/html; charset=utf-8');session_start();if(!empty($_SESSION['userinfo']))&#123; var_dump($_SESSION['userinfo']);&#125;?&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;您好 &lt;?php if(!empty($_SESSION['name'])): ?&gt; &lt;?php echo $_SESSION['name']; ?&gt; &lt;?php endif ?&gt; ，欢迎回来！！！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 2.4 Session的实现原理 ​ Session 这种机制会更加适合于存放一些属于用户而又不能让用户修改的数据，因为客户端不再保存具体的数据，只是保存一把“钥匙”，伪造一把可以用的钥匙，可能性是极低的，所以不需要在意。 2.4.1 一次会话​ 一次会话： 打开浏览器 -&gt; 访问一些服务器内容 -&gt; 关闭浏览器 1234//通过切换浏览器窗口，可以发现：1.没有关闭浏览器，直接打开一个新窗口，可以访问session中存储的数据2.关闭当前的浏览器，再重新打开，访问不了session中的数据3.直接打开另一个新的浏览器，访问不了session中的数据 2.4.2 一次会话的原理123456789101112A、session_start()是session机制的开始B、session会判断当前是否有$_COOKIE[session_name()]，这个键可以从php.ini找到 session.name = PHPSESSID //默认值PHPSESSIDC、如果不存在PHPSESSID这个Cookie则会生成一个session_id,然后把生成的session_id作为COOKIE的值传递到客户端. setcookie('PHPSESSID', session_id);D、如果存在那么session_id =$_COOKIE[session_name]; 然后去session.save_path指定的文件夹里去找名字为'SESS_'.session_id()的文件. 读取文件的内容反序列化，然后放到$_SESSION中 #注意：//1.当关闭浏览器的时候，浏览器会清空cookie的PHPSESSID，再次打开浏览器访问服务器的时候，又得到一个新的session会话，所以无法取出原session中的数据。//2.关闭浏览器的时候并不会导致服务器session对象的销毁 2.4.3 如何避免关闭浏览器的一次会话问题12//修改Session的cookie的存活时间，目的是让关闭浏览器不自动销毁cookie，下次打开浏览器仍然可以访问之前的状态信息session.cookie_lifetime：86400 2.5 Session的回收12345678910111213#1.session的默认过期时间 (php.ini)php中的session有效期默认是1440秒（24分钟），也就是说，客户端超过24分钟没有刷新，当前session就过期了。#2.修改session的最大存活时间session.gc_maxlifetime：86400#3.过期Session的回收//php5里面session的过期使用了回收机制。上面设置Session的过期时间为86400秒，但是并不意味着86400秒之后Session不用就会被回收，Session真正的回收取决于GC(garbage collection)什么时候启动。//默认情况下，每一次php请求，就会有1/100的概率发生回收，所以可能简单的理解为“每100次php请求就有一次回收发生”。这个概率是通过以下参数控制：session.gc_probability = 1session.gc_divisor = 100 //不建议修改这个值，因为会影响PHP的执行效率//概率是gc_probability/gc_divisor,也就是每访问100次服务器有1次可能会启用PHP的GC。 2.6 猜数字游戏​ 参考：https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/A_first_splash 注意：这里是 JavaScript 的实现，经供参考 ​ 我想让你创建一个可以猜数字的游戏，它会在1~100以内随机选择一个数, 然后让玩家挑战在10轮以内猜出这个数字，每一轮都要告诉玩家正确或者错误， 如果出错了，则告诉他数字是低了还是高了，并且还要告诉玩家之前猜的数字是什么。 一旦玩家猜测正确，或者他们用完了回合，游戏将结束。 游戏结束后，可以让玩家选择再次开始。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#1.guess.php&lt;?php session_start();?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;猜数字&lt;/title&gt; &lt;style&gt; body &#123; padding: 100px 0; background-color: #2b3b49; color: #fff; text-align: center; font-size: 2.5em; &#125; input &#123; padding: 5px 20px; height: 50px; background-color: #3b4b59; border: 1px solid #c0c0c0; box-sizing: border-box; color: #fff; font-size: 20px; &#125; button &#123; padding: 5px 20px; height: 50px; font-size: 16px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;猜数字游戏&lt;/h1&gt; &lt;p&gt;Hi，我已经准备了一个0~100的数字，你需要在仅有的10机会之内猜对它。&lt;/p&gt; &lt;?php if (!empty($_SESSION['message'])): ?&gt; &lt;p&gt;&lt;?php echo $_SESSION['message']; ?&gt;&lt;/p&gt; &lt;?php endif ?&gt; &lt;form action=\"doguess.php\" method=\"get\"&gt; &lt;input type=\"number\" min=\"0\" max=\"100\" name=\"num\" placeholder=\"随便猜\"&gt; &lt;button type=\"submit\"&gt;试一试&lt;/button&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738#2.doguess.php&lt;?php// 找一个属于当前访问者的箱子// 并且把箱子的钥匙（session_id）交给用户（cookie）session_start();header('Content-Type: text/html; charset=utf-8');if (empty($_SESSION['num']))&#123; $num = rand(0, 100); // 存在 cookie 中不保险，存在服务端的箱子里 $_SESSION['num'] = $num; $_SESSION['count'] = 0;&#125; $count = $_SESSION['count'];$result = null;if ($count &lt; 10) &#123; //session中的数据是强类型的，不需要强制转换 $result = (int)$_GET['num'] - $_SESSION['num']; if ($result == 0) &#123; $message = $count.'次'.'我的数字'.(int)$_GET['num'].'随机数'.$_SESSION['num'].'猜对了'; unset($_SESSION['num']); unset($_SESSION['count']); &#125; elseif ($result &gt; 0) &#123; $message = $count.'次'.'我的数字'.(int)$_GET['num'].'随机数'.$_SESSION['num'].'太大了'; &#125; else &#123; $message = $count.'次'.'我的数字'.(int)$_GET['num'].'随机数'.$_SESSION['num'].'太小了'; &#125; $_SESSION['count'] = $count + 1; $_SESSION['message'] = $message;&#125;else&#123; $_SESSION['message'] = \"over\"; unset($_SESSION['num']); unset($_SESSION['count']);&#125;header('Location: guess.php');?&gt;","categories":[],"tags":[]},{"title":"","date":"2018-12-03T13:28:39.986Z","path":"2018/12/03/数据类型和类型检测/","text":"JavaScript数据类型和类型检测JavaScript数据类型JavaScript数据类型主要分为两大类： 1.基本数据类型：字符串(String)，数字(Number)，布尔(Boolean)，空(Null)，未定义(Undefined)，(Symbol) 注:Symbol 是 ES6 引入的一种新的原始数据类型，表示独一无二的值。 2.复杂数据类型 (引用数据类型)：对象(Object)，函数(Function) 基本类型String&amp;Number123var x; // x 为 undefinedvar x = 1; // x 为 numbervar x = &quot;hi&quot;; // x 为 string Boolean布尔（逻辑）只能有两个值：true 或 false。 Null&amp;Undefined1.Undefined 表示变量声明了但是没有赋值(未初始化)。 2.可以通过将变量的值设置为 null 来清空变量。 12var person = null;console.log(typeof person); // &quot;object&quot;","categories":[],"tags":[]}]