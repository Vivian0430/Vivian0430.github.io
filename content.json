[{"title":"win8 win10系统安装msi文件方法","date":"2018-12-18T16:00:00.000Z","path":"2018/12/19/win8 win10系统安装msi文件方法/","text":"win8 win10系统安装msi文件方法1.win+R，在运行框中输入”gpedit.msc”，在 “计算机配置/管理模板/windows组件/windows Installer”和 “用户配置/管理模板/windows组件/windows Installer”， 找到”始终以提升的权限进行安装”，双击改为”已启用”， 2.win+x，选择”命令提示符（管理员）” 3.在命令提示符窗口中输入： msiexec /package “你的安装文件的全路径” 例：d盘下的a.msi msiexec /package “d:\\a.msi”","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"关于github的基本使用","date":"2018-12-18T16:00:00.000Z","path":"2018/12/19/关于github的基本使用/","text":"关于github的基本使用github是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名github。 github于2008年4月10日正式上线，除了git代码仓库托管及基本的 Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱（报表）、代码片段分享（Gist）等功能。目前，其注册用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby on Rails、jQuery、python 等。 环境配置（git node npm）首先我们需要在自己的电脑上面安装git，node以及npm，npm会在安装node时自动安装，node下载网址自行访问另一篇文章，git下载地址：https://git-scm.com，在这里只进行一些基本的git操作和命令行语句（如果只是github的基本操作完全够用），如果想要学的更多，可以访问廖雪峰的git教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000。 上传github项目配置公钥首先，需要创建我们自己的电脑和github上远程仓库的一个连接，本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要配置一下加密的公钥和密钥。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，没有就通过下面命令创建： 直接在桌面右击-git bash，输入命令行语句 ssh-keygen -t rsa -C “注册github的邮箱地址” 然后在C:\\Users\\student（你的用户名）下会找到一个.ssh文件夹，点击进入，会有id_rsa和id_rsa.pub这两个文件，右击记事本打开id_rsa.pub，复制里面的全部内容，登录Github，找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key。至此，你的计算机和github账户就建立了一个连接，换电脑需要重新添加公钥。 （当然首先你得有一个github账户，直接访问github的官网然后sign up即可，就不给链接了直接baidu搜索github官网就可以了） git上传项目到github账户进入你需要上传的项目的根目录（必须是要上传的项目的根目录下），右击-git bash，以下是一系列的命令行语句： git config –global user.name “你的github用户名” git config –global user.email “你的github账户邮箱” git init （会生成一个.git隐藏文件夹，如果没有，baidu具体操作，给一个win10的链接：https://jingyan.baidu.com/article/acf728fd2853fef8e410a37f.html） git add .（添加你需要上传的文件，后面跟指定文件名，. 代表该文件夹下全部文件） git commit -m “提交时的注释信息”（这个操作是将文件提交到本地仓库） 你的github页面右上角有一个加号，点击加号，new repository新建一个公开的仓库，（私有的要钱） 一般同时要生成一个README.md文件，也就是描述你的项目用的。 git remote add origin 仓库地址 仓库地址就是右边展开的那个，.git结尾的。 git pull –rebase origin master （这个操作是把你github项目上的文件拉到本地，如果github上的文件本地没有，本地文件是无法push上去的，现在你的仓库里有一个README文件，所以要先下拉到本地才能执行上传操作，执行完以后你本地应该是有一个README.md的） git push origin master 至此全部结束。如果你在pull 的时候卡住了并且没有备份文件，文件全部丢失了的话，可以给我留言，我再详细说明如何恢复，在此不过多解说。 github删除文件这里呢有一个坑，很多人可能都和我一开始一样，直接在项目里删除不需要的或者误上传的文件，然后执行git add， git commit，git push一系列的操作，但是结果会是上传失败，为什么呢？原因和之前我们需要进行pull操作是一个，因为github仓库上的文件你本地没有，他就会让你进行pull操作，但是删掉的文件就又会被pull下来，白删了，删文件也是需要用命令行语句删的： git rm “需要删除的文件名” git push origin master github更新文件比如你修改了一些文件， git status （查看文件状态，这时下面会出现红色的提示 modified 你修改了的文件） git add “你修改了的文件名”（这时你再git status就会发现之前红色的字变成了绿色） git commit -m “注释信息” git push origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"hexo博客yilia主题的配置","date":"2018-12-18T16:00:00.000Z","path":"2018/12/19/hexo博客yilia主题的配置/","text":"hexo博客yilia主题的配置主题github地址： https://github.com/litten/hexo-theme-yilia 配置缺失模块从GitHub上面clone下来主题之后，点开左下角的全部文章，是没有办法直接显示文章目录的，点开的模块里也有解决的方法，需要配置一些代码。 首先要调出cmd黑窗口，查看自己电脑里安装的node版本（npm会在安装node时自动安装），node下载链接（http://nodejs.cn/download/）。win8和win10安装不了msi的安装包，具体步骤可以百度一下。 然后在博客根目录下左键git bash 执行 npm i hexo-generator-json-content –save 最后在博客根目录找到_config.yml，不是themes文件夹，themes文件夹下也有一个但是是做其他相关配置的，随便找一个空位放下页面提示让你放的那一段代码。 博客根目录git bash - hexo clean - hexo g - hexo d；预览效果的话用hexo g之后hexo s，开启服务器，然后本地输入localhost:4000就可以查看了，确认没问题再hexo d上传上去。 调整css样式，颜色字体等emmm，yilia主题自带的颜色个人表示不是很喜欢，不是一个风格的，调这个样式还是花了很多时间的，直接F12用那个小箭头找到自己需要修改样式的元素，控制台那里element style点开就可以看见相关的样式设置了，右上角会有他的来源文件，yilia主题基本样式都是放在themes/yilia/source/main.0cf68a.css里面，用sublime打开直接ctrl +F查找关键词找到你要修改的部分按照自己喜欢的来改就可以了。 目录不显示文章标题，tags标签怎么加，文章截断这个问题真的是困扰了我好久，因为不是在控制台里面生成的md文件，直接写好了放进src/_post文件夹里面上传上去的，这样比较方便，但是！！这样子点击所有文章出来的文章都没有标题，是空白，需要在md文件里面做一些配置，在md文件的最顶部写title，date，tags的信息，上面和下面的三个杠杠不能少，要注意用英文冒号。 还有一个就是文章截断的问题，不然会默认在主页显示整篇的文章，在你的md文件中（右击记事本打开）需要做截断的地方加上“”。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"JavaScript常用设计模式详解","date":"2018-12-17T16:00:00.000Z","path":"2018/12/18/JavaScript常用设计模式详解/","text":"JavaScript常用设计模式详解JavaScript中常用的设计模式有十种，分别为工厂模式，单体模式，模块模式，代理模式，职责链模式，命令模式，模板方法模式，策略模式，发布-订阅模式以及中介者模式。 都是为了降低代码的耦合度，提高性能。 其中，工厂模式，单例模式，模块模式，发布订阅模式比较重要，常用。 工厂模式简单工厂模式简单工厂模式就是用来解决多个类似对象的声明问题，无法判断所创建出的对象的类型。 1234567891011121314151617181920212223242526272829//创建对象function CreatePerson(name,age,sex) &#123; var obj = new Object(); //new了一个object对象 obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;//可以无数次调用这个函数，来获得包含三个属性一个方法的对象var p1 = new CreatePerson(&quot;longen&quot;,&apos;28&apos;,&apos;男&apos;);var p2 = new CreatePerson(&quot;tugenhua&quot;,&apos;27&apos;,&apos;女&apos;);console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实例(不知道对象的类型)console.log(typeof p1); // objectconsole.log(typeof p2); // objectconsole.log(p1 instanceof Object); // true 拓展： 除了string、number、Boolean、null、undefined之外，其他的数据都是对象。 对象的类型：1.内置对象（原生对象）=&gt;RegExp，Date，Math…(js语言本身预定义的对象) ​ 2.宿主对象=&gt;BOM对象：History，Location，Window，Navigate，Screen ​ DOM对象：Body，Style，Meta，Frame，Frameset… 复杂工厂模式将其对象成员的实例化推迟到子类当中，子类可以重写接口（overRide）来创建自己的对象类型。 父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。父类中只声明方法而具体的业务逻辑要在子类中写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 定义自行车的构造函数 父类=&gt;抽象类var BicycleShop = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, sellBicycle: function(model)&#123; var bicycle = this.createBicycle(model); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error(&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;); &#125; &#125;; //子类 var BicycleChild = function(name)&#123; this.name = name; // 继承构造函数父类中的属性和方法 BicycleShop.call(this,name); &#125;; // 子类继承父类原型方法 extend(BicycleChild,BicycleShop); // BicycleChild 子类重写父类的方法 BicycleChild.prototype.createBicycle = function()&#123; var A = function()&#123; console.log(&quot;执行A业务操作&quot;); &#125;; var B = function()&#123; console.log(&quot;执行B业务操作&quot;); &#125;; return &#123; A: A, B: B &#125;&#125;var childClass = new BicycleChild(&quot;捷安特&quot;);console.log(childClass);console.log(childClass.name);childClass.sellBicycle(&quot;model&quot;); extend子类继承父类原型方法函数的封装 12345678910111213141516171819202122function extend(Sub,Sup) &#123; //Sub表示子类，Sup表示超类 // 首先定义一个空函数 var F = function()&#123;&#125;; // 设置空函数的原型为超类的原型 F.prototype = Sup.prototype; // 实例化空函数，并把超类原型引用传递给子类 Sub.prototype = new F(); // 重置子类原型的构造器为子类自身 Sub.prototype.constructor = Sub; // 在子类中保存超类的原型,避免子类与超类耦合 Sub.sup = Sup.prototype; if(Sup.prototype.constructor === Object.prototype.constructor) &#123; // 检测超类原型的构造器是否为原型自身 Sup.prototype.constructor = Sup; &#125; &#125; 优点：1.弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。 ​ 2.重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。 单体模式(单例模式)对象以字面量的方式来创建单体模式 特点：如果可以实例化，只可以实例化一次 单体模式的基本结构：（使用一个变量来标识该类是否被实例化，如果未被实例化的话，那么我们可以实例化一次，否则的话，直接返回已经被实例化的对象。） 1234567891011121314151617181920212223// 单体模式var Singleton = function(name)&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;// 获取实例对象function getInstance(name) &#123;var instance = null; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;// 测试单体模式的实例var a = getInstance(&quot;aa&quot;);var b = getInstance(&quot;bb&quot;);console.log(a === b); // trueconsole.log(a.getName()); // aa 单体模式只能实例化一次console.log(b.getName()); // aa 单体模式实现弹窗一般情况下编写弹窗： 12345678910111213// 实现弹窗var createWindow = function()&#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是弹窗内容&quot;; div.style.display = &apos;none&apos;; document.body.appendChild(&apos;div&apos;); return div;&#125;;document.getElementById(&quot;Id&quot;).onclick = function()&#123; // 点击后先创建一个div元素 var win = createWindow(); //会频繁地创建div对象，降低性能 win.style.display = &quot;block&quot;;&#125; 用单例模式实现弹窗，只实例化一次 123456789101112131415161718// 实现单体模式弹窗var createWindow = (function()&#123; var div; return function()&#123; if(!div) &#123; div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是弹窗内容&quot;; div.style.display = &apos;none&apos;; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.getElementById(&quot;Id&quot;).onclick = function()&#123; // 点击后先创建一个div元素 var win = createWindow(); win.style.display = &quot;block&quot;;&#125; 封装单体模式函数123456var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); //调用当前对象的方法 &#125;&#125;; 测试单体模式函数 12345678910111213141516171819202122232425262728293031323334353637var createWindow = function()&#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是弹窗内容&quot;; div.style.display = &apos;none&apos;; div.style.border = &apos;1px solid red&apos;; div.style.width = &apos;100px&apos;; div.style.height = &apos;100px&apos;; document.body.appendChild(div); return div;&#125;;// 创建iframevar createIframe = function()&#123; var iframe = document.createElement(&quot;iframe&quot;); iframe.style.width = &apos;500px&apos;; iframe.style.height = &apos;300px&apos;; document.body.appendChild(iframe); return iframe;&#125;;// 获取实例的封装代码var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); &#125;&#125;;// 测试创建divvar createSingleDiv = getInstance(createWindow);document.getElementById(&quot;btn&quot;).onclick = function()&#123; var win = createSingleDiv(); win.style.display = &quot;block&quot;;&#125;;// 测试创建iframevar createSingleIframe = getInstance(createIframe);document.getElementById(&quot;btn2&quot;).onclick = function()&#123; var win = createSingleIframe(); win.src = &quot;http://baidu.com&quot;;&#125;; 模块模式为单体模式添加私有变量和私有方法能够减少全局变量的使用。降低了代码的耦合度。沙箱模式 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。 12345678910111213var singleMode = (function()&#123; // 创建私有变量 var privateNum = 112; // 创建私有函数 function privateFunc()&#123; // 实现自己的业务逻辑代码 &#125; // 返回一个对象包含公有方法和属性 return &#123; publicMethod1: publicMethod1, publicMethod2: publicMethod1 &#125;;&#125;)(); 模块增强模式 增强的模块模式的使用场合是：适合那些单列必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。 12345678910111213141516171819202122232425262728function CustomType() &#123; this.name = &quot;tugenhua&quot;;&#125;;CustomType.prototype.getName = function()&#123; return this.name;&#125;var application = (function()&#123; // 定义私有 var privateA = &quot;aa&quot;; // 定义私有函数 function A()&#123;&#125;; // 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法 var object = new CustomType(); // 添加公有属性 object.A = &quot;aa&quot;; // 添加公有方法 object.B = function()&#123; return privateA; &#125; // 返回该对象 return object;&#125;)();console.log(application.A);// aaconsole.log(application.B()); // aa //调用公有的函数访问私有数据console.log(application.name); // tugenhuaconsole.log(application.getName());// tugenhua 代理模式委托机制，新建一个对象代替本体对象被实例化。 比如现在京东ceo想送给奶茶妹一个礼物，但是呢假如该ceo不好意思送，或者由于工作忙没有时间送，那么这个时候他就想委托他的经纪人去做这件事，然后可以使用代理模式来编写如下代码： 123456789101112131415161718192021222324// 先申明一个奶茶妹对象var TeaAndMilkGirl = function(name) &#123; this.name = name;&#125;;// 这是京东ceo先生var Ceo = function(girl) &#123; this.girl = girl; // 送结婚礼物 给奶茶妹 this.sendMarriageRing = function(ring) &#123; console.log(&quot;Hi &quot; + this.girl.name + &quot;, ceo送你一个礼物：&quot; + ring); &#125;&#125;;// 京东ceo的经纪人是代理，来代替送var ProxyObj = function(girl)&#123; this.girl = girl; // 经纪人代理送礼物给奶茶妹 this.sendGift = function(gift) &#123; // 代理模式负责本体对象实例化 (new Ceo(this.girl)).sendMarriageRing(gift); &#125;&#125;;// 初始化var proxy = new ProxyObj(new TeaAndMilkGirl(&quot;奶茶妹&quot;));proxy.sendGift(&quot;结婚戒&quot;); // Hi 奶茶妹, ceo送你一个礼物：结婚戒 优点：1.代理对象可以代替本体被实例化，并使其可以被远程访问 ​ 2.它还可以把本体实例化推迟到真正需要的时候，对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象 使用虚拟代理实现图片预加载不使用代理模式预加载图片 1234567891011121314151617// 不使用代理的预加载图片函数如下var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = this.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = &quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;; img.src = src; &#125; &#125;&#125;)();// 调用方式myImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;); 使用代理模式预加载图片 12345678910111213141516171819202122232425//创建图片var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc(&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;); img.src = src; &#125; &#125;&#125;)();// 调用方式ProxyImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;); 优缺点： 第一种方案一般的方法代码的耦合性太高，一个函数内负责做了几件事情，比如创建img元素，和实现给未加载图片完成之前设置loading加载状态等多项事情，未满足面向对象设计原则中单一职责原则；并且当某个时候不需要代理的时候，需要从myImage 函数内把代码删掉，这样代码耦合性（关联程度）太高。 第二种方案使用代理模式，其中myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可。 虚拟代理合并http的请求比如在做后端系统中，有表格数据，每一条数据前面有复选框按钮，当点击复选框按钮时候，需要获取该id后需要传递给给服务器发送ajax请求，服务器端需要记录这条数据，去请求，如果我们每当点击一下向服务器发送一个http请求的话，对于服务器来说压力比较大，网络请求比较频繁，但是如果现在该系统的实时数据不是很高的话，我们可以通过一个代理函数收集一段时间内(比如说2-3秒)的所有id，一次性发ajax请求给服务器，相对来说网络请求降低了, 服务器压力减少了。 代理函数做一个暂存的功能，最后一次性提交。 缓存代理缓存代理的含义就是对第一次运行时候进行缓存，当再一次运行相同的时候，直接从缓存里面取，这样做的好处是避免重复一次运算功能，如果运算非常复杂的话，对性能很耗费，那么使用缓存对象可以提高性能。 发布-订阅模式（观察者模式）发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 例如：淘宝收藏店铺，卖家，买家的关系；angular框架的路由 优点 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。 缺点 创建订阅者需要消耗一定的时间和内存。 如何实现发布-订阅模式 首先要想好谁是发布者（比如卖家）。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。（在callback函数中传入描述商品信息的参数）。 简单的发布-订阅模式 123456789101112131415161718192021222324252627var shoeObj = &#123;&#125;; // 定义发布者 淘宝店铺卖家shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(fn) &#123; shoeObj.list.push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; for(var i = 0,fn; fn = this.list[i++];) &#123; fn.apply(this,arguments); &#125;&#125;// 小红订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(&quot;颜色是：&quot;+color); console.log(&quot;尺码是：&quot;+size); &#125;);// 小花订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(&quot;再次打印颜色是：&quot;+color); console.log(&quot;再次打印尺码是：&quot;+size); &#125;);shoeObj.trigger(&quot;红色&quot;,40);shoeObj.trigger(&quot;黑色&quot;,42); ​ 增强的发布-订阅模式（订阅者只订阅自己想要看的东西） 12345678910111213141516171819202122232425262728293031323334353637var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(key,fn) &#123; if(!this.list[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.list[key] = []; &#125; this.list[key].push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; var key = Array.prototype.shift.call(arguments); // 取出消息类型名称 var fns = this.list[key]; // 取出该消息对应的回调函数的集合 // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++]; ) &#123; fn.apply(this,arguments); // arguments 是发布消息时附送的参数 &#125;&#125;;// 小红订阅如下消息shoeObj.listen(&apos;red&apos;,function(size)&#123; console.log(&quot;尺码是：&quot;+size); &#125;);// 小花订阅如下消息shoeObj.listen(&apos;black&apos;,function(size)&#123; console.log(&quot;再次打印尺码是：&quot;+size); &#125;);shoeObj.trigger(&quot;red&quot;,40);shoeObj.trigger(&quot;black&quot;,42); 发布-订阅模式代码封装123456789101112131415161718192021var event = &#123; list: [], listen: function(key,fn) &#123; if(!this.list[key]) &#123; this.list[key] = []; &#125; // 订阅的消息添加到缓存列表中 this.list[key].push(fn); &#125;, trigger: function()&#123; var key = Array.prototype.shift.call(arguments); var fns = this.list[key]; // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;&#125;; 测试封装代码 12345678910111213141516171819var initEvent = function(obj) &#123; for(var i in event) &#123; //遍历 obj[i] = event[i]; &#125;&#125;;var shoeObj = &#123;&#125;;initEvent(shoeObj);// 小红订阅如下消息shoeObj.listen(&apos;red&apos;,function(size)&#123; console.log(&quot;尺码是：&quot;+size); &#125;);// 小花订阅如下消息shoeObj.listen(&apos;black&apos;,function(size)&#123; console.log(&quot;再次打印尺码是：&quot;+size); &#125;);shoeObj.trigger(&quot;red&quot;,40);shoeObj.trigger(&quot;black&quot;,42);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"ES6新特性promise","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/ES6-promise对象/","text":"ES6新特性promisepromise的含义Promise 是异步编程的一种解决方案，从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 存储多个等待的执行方法的容器。 promise的特点 对象状态不受外界影响。promise对象表示一个异步操作，有三种状态，pending（进行中），fulfilled（已成功）和rejected（已失败）。只有异步操作的结果可以决定当前处于哪种状态，其他操作都无法改变这个状态 一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。 promise的缺点 一旦新建，会立即执行，无法中途取消。 如果没有设置回调函数，promise内部抛出的错误无法反应到外部。 当处于pending状态时，无法得知当前进展到哪一阶段。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 1234567const promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); //已定型 &#125; else &#123; reject(error); //失败 &#125;&#125;); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 promise.then(promise对象状态变为resolved的回调函数,promise对象状态变为rejected的回调函数) 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 案例依次输出1,2,3 ES5实现方法1234567891011121314var showData = function(ms , cb)&#123; setTimeout(function()&#123; cb(); &#125; , ms); &#125;showData(2000 , function()&#123; console.log(1); showData(200 , function()&#123; console.log(2); showData(20 , function()&#123; console.log(3); &#125;); &#125;); &#125;); 注：以下代码可以达到相同效果，但是如果资源是图片，第一次请求的图片资源较大或者第二次请求资源较小时，依旧无法实现资源依次显示的效果。 123456showData(20 , function()&#123; console.log(1); &#125;);showData(200 , function()&#123; console.log(2); &#125;); ES6实现方法12345678910111213141516171819var showData = function(ms)&#123; var promise = new Promise(function(resolve)&#123; setTimeout(function()&#123; resolve(); &#125; , ms); &#125;); return promise; &#125; showData(2000).then(() =&gt; &#123; //2s后输出1 console.log(1); return showData(200); &#125;).then(() =&gt; &#123; //输出1后的0.2s后输出2 console.log(2); return showData(20); &#125;).then(() =&gt; &#123; console.log(3); &#125;);","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性let和const","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/ES6的新特性let和const/","text":"ES6的新特性let和constlet-块级作用域1.ES5中声明变量用var，ES6中用let声明变量，const声明常量。 2.在ES5中变量的作用域分为全局作用域和局部作用域，但是在ES6中新增了块级作用域。let的作用域是在声明变量最近的一对大括号内，var声明变量时是将变量添加到window下，而let不是。 1234567891011if(true)&#123; let i = 100; console.warn(i); //100 &#125; console.log(i); //undefined if(true)&#123; var i = 100; console.warn(i); //100 &#125;console.log(i); //100 3.在for循环遍历时适合使用let声明变量，来避免全局污染。 12345let globalValue = 100; for(let i = 0; i &lt; 10 ;i++)&#123; // i作用域 &#125; console.log(i); //i is not defined var和let的区别重复声明var可以重复声明变量，而let则不可以。 用var对变量再次声明时，最后一次的赋值会覆盖之前的，而let会报has been declared的错误。 123var a = 10;var a = 20;console.log(a); //20 变量提升var可以提升变量的声明，而let不可以。 12345console.log(a);var a = 10; //undefined a被定义了但是没有赋值，提升了变量声明console.log(a);let a = 10; //a is not defined a没有被定义 暂时性死区12345678910111213var i = 1;function foo()&#123; console.log(i); //undefined var i = &quot;hello&quot;; //局部变量声明提升&#125;let i = 1;function foo()&#123; //暂时性死区 console.log(i); //i is not defined i没有被定义 let i = &quot;hello&quot;; //暂时性死区&#125; const在ES6中用const声明常量，声明必须赋值且后期不能修改。 基本类型123const VALUE = 100;console.log(VALUE);VALUE = 200; //值不能改变 引用类型const声明一个对象时，可以修改对象成员 123456789const PERSON = &#123; name:&apos;Rose&apos;, age:18 &#125;; console.log(PERSON); //Rose 18 PERSON.name = &apos;Jack&apos;; PERSON.age = 100; console.log(PERSON); //Jack 100","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性Symbol","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/ES6-Symbol/","text":"Symbol1.Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值，减少命名冲突。 1234var a = Symbol(&apos;第一个symbol的值&apos;);var b = Symbol(&apos;第二个symbol的值&apos;);console.log(a === b);//falseconsole.log(a, b);//Symbol(第一个symbol的值) Symbol(第二个symbol的值) 2.Symbol值通过Symbol函数生成 12let s = Symbol();console.log(typeof s);//&quot;symbol&quot; 4.相同参数的Symbol函数的返回值是不相等的。 12345678//无参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2;//false//有参数的情况let s1 = Symbol(&apos;foo&apos;);let s2 = Symbol(&apos;foo&apos;);s1 === s2 // false 5.Symbol.for 1234var a = Symbol.for(&apos;keyA&apos;); // 创建一个Symbol的值var b = Symbol.for(&apos;keyA&apos;); // 存在，读取值console.log(a === b);//true 6.Symbol作为对象的属性名key（在ES5中key的值只能是字符串） 1234567891011121314151617var keyA = Symbol.for(&apos;KeyA&apos;); var person = &#123; name:&apos;Rose&apos;, age:18, [keyA]:&apos;abc&apos; &#125;; for(var key in person)&#123; //for-in遍历对象，不能遍历对象中的Symbol类型属性 console.log(key , person[key]); &#125;// name Rose// age 18 var keys = Object.getOwnPropertySymbols(person); //遍历对象中的Symbol类型属性 console.log(keys);// [Symbol(keyA)] 7.Symbol 值不能与其他类型的值进行运算，不能进行字符串的拼接。 8.Symbol可以转换为字符串类型和布尔类型，但是不能转换为数值类型。 123let sym = Symbol();String(sym)Boolean(sym)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"vue详解","date":"2018-09-30T16:00:00.000Z","path":"2018/10/01/VUE详解/","text":"1.Vue1.1 基本介绍1.1.1.为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程： 原生JS -&gt; Jquery之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率） 1.1.2.框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 1.从Jquery 切换到 Zepto 2.从 EJS 切换到 art-template 1.1.3.什么是Vue.js​ https://cn.vuejs.org/v2/api/ Vue.js是是一套用于构建用户界面的渐进式框架，是目前最火的一个前端框架，React是最流行的一个前端框架（React除了开发网站，还可以开发手机App， Vue语法也是可以用于进行手机App开发的，需要借助于Weex） Vue.js 是前端的主流框架之一，和Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue有配套的第三方类库，可以整合起来做大型项目的开发） 1.1.4. Vue的核心思想 数据驱动，没有dom操作，页面显示由数据驱动 组件化，一个页面可以划分成很多组件 状态管理 ，vuex，可用于在多个页面之间进行数据共享 ​ Vue.js 是一个提供了 MVVM 风格的双向数据绑定的 Javascript 库，专注于View 层。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性，这种轻量级的架构让前端开发更加高效、便捷。 1.1.5.MVC和MVVMa) MVC​ M - Model ：数据保存 ​ V - View : 用户界面 ​ C - Controller ： 业务逻辑 1用户操作--&gt; View (负责接受用户的输入操作)--&gt;Controller（业务逻辑处理）--&gt;Model（数据持久化）--&gt;View（将结果通过View反馈给用户） ​ MVC有两个很明显的问题： ​ 1.m层和v层直接打交道，导致这两层耦合度高 ​ 2.因为所有逻辑都写在c层，导致c层特别臃肿 b) MVVM​ 前端应用的复杂程度已不同往日，暴露出了三个痛点问题： 1.开发者在代码中大量调用相同的DOM API, 处理繁琐，操作冗余，使得代码难以维护。 2.大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 3.当 Model 频繁发生变化，开发者需要主动更新到View ；当用户的操作导致Model发生变化，开发者同样需要将变化的数据同步到Model中， 这样的工作不仅繁琐，而且很难维护复杂多变的数据状态。 早期 jQuery 的出现就是为了前端能更简洁的操作DOM 而设计的，但它只解决了第一个问题，另外两个问题始终伴随着前端一直存在。 ​ MVVM 的出现，完美解决了以上三个问题，MVVM 包含的三部分： 1.Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑； 2.View 代表UI 组件，它负责将数据模型转化成UI 展现出来 3.ViewModel 是一个同步View 和 Model的对象。View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互。ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图： ​ MVVM 模式采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。angular 和vue都采用这种模式。 c) 前后端的MVC​ 一般情况下，后端的框架中多数采用MVC模式，比如structs2、springMVC、ASP.MVC、Express等 ​ 前端MVC大部分都是MVVM，包括angularJS、vue等。前后端分离的情况下，后端的MVC框架主要负责JSON数据的返回。 1.2 Vue使用1.2.1 基本使用1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue的包 --&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- id=\"app\" : app指的是将来 new 的Vue实例，会控制这个元素中的所有内容 --&gt; &lt;!-- Vue 实例所控制的这个元素区域，就是我们的 View --&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; msg &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建一个Vue的实例，就是我们 MVVM中的 ViewModel // 当我们导入包之后，在浏览器的内存中，就多了一个 Vue 构造函数 var vm = new Vue(&#123; // 表示当前我们 new 的这个 Vue 实例，要控制页面上的哪个区域 el: '#app', // 这里的 data 就是 MVVM中的 Model，专门用来保存每个页面的数据的 data: &#123; // data 属性中，存放的是el中要用到的数据 msg: '欢迎学习Vue' // 通过 Vue 提供的指令，很方便的就能把数据渲染到页面上，程序员不再手动操作DOM元素了【前端的Vue之类的框架，不提倡我们去手动操作DOM元素了】 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.2 常用指令 v-cloak v-text v-html v-bind v-on 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 使用 v-cloak 能够解决 插值表达式闪烁的问题 vue-2.4.0.js的加载需要时间，在vue-2.4.0.js没有成功加载之前，页面会显示&#123; &#123;msg&#125;&#125;文本信息 --&gt; &lt;p v-cloak&gt;++++++++ &#123;&#123; msg &#125;&#125; ----------&lt;/p&gt; &lt;h4 v-text=\"msg\"&gt;==================&lt;/h4&gt; &lt;!-- 默认 v-text 是没有闪烁问题的 --&gt; &lt;!-- v-text会覆盖元素中原本的内容，但是插值表达式只会替换自己的这个占位符，不会把整个元素的内容清空 --&gt; &lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt; &lt;div v-text=\"msg2\"&gt;&lt;/div&gt; &lt;!-- v-html会覆盖元素中原本的内容，只不过会将msg2当做html文本进行解析 --&gt; &lt;div v-html=\"msg2\"&gt;1212112&lt;/div&gt; &lt;!-- v-bind: 是Vue中提供的用于绑定属性的指令，v-bind 中，可以写合法的JS表达式 --&gt; &lt;input type=\"button\" value=\"按钮1\" v-bind:title=\"mytitle + '123'\"&gt; &lt;!-- 注意： v-bind: 指令可以被简写为 :要绑定的属性 --&gt; &lt;input type=\"button\" value=\"按钮2\" :title=\"mytitle + '3455'\"&gt; &lt;!-- Vue 中提供了 v-on: 事件绑定机制 下面代码错误：因为vue会将alert理解为一个变量，而在Vue中我们并没有定义alert变量，所以找不到 --&gt; &lt;!-- &lt;input type=\"button\" value=\"按钮3\" :title=\"mytitle + '888'\" v-on:click=\"alert('hello')\"&gt;--&gt; &lt;!--v-on:click可以简写成@click--&gt; &lt;input type=\"button\" value=\"按钮4\" @click=\"show\"&gt; &lt;/div&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123', msg2: '&lt;h1&gt;哈哈，我是一个大大的H1， 我大，我骄傲&lt;/h1&gt;', mytitle: '这是一个自己定义的title' &#125;, methods: &#123; // 这个 methods属性中定义了当前Vue实例所有可用的方法 show: function () &#123; alert('Hello') &#125; &#125; &#125;) /* //在vue中不推荐我们再去使用dom操作的方法 document.getElementById('btn').onclick = function()&#123; alert('Hello') &#125; */ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.3 mustache 插值表达式123456//表达式的特点：必须是一句话，必须有返回值&#123;&#123;number+1&#125;&#125;&#123;&#123;ok?\"YES\":\"NO\"&#125;&#125;&#123;&#123;message.split(\"\").reverse().join(\"-\")&#125;&#125;#注意点：指令的值是一个变量，后面不可以跟表达式 1.2.4 跑马灯效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1. 导入Vue包 --&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2. 创建一个要控制的区域 --&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"浪起来\" @click=\"lang\"&gt; &lt;input type=\"button\" value=\"低调\" @click=\"stop\"&gt; &lt;h4&gt;&#123;&#123; msg &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;script&gt; // 注意：在VM实例中，如果想要获取data上的数据，或者想要调用methods中的方法，必须通过this.数据属性名或this.方法名来进行访问，这里的this，就表示我们new出来的VM 实例对象 var vm = new Vue(&#123; el: '#app', data: &#123; msg: '猥琐发育，别浪~~！', intervalId: null // 在data上定义定时器Id &#125;, methods: &#123; lang() &#123; if (this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; var start = this.msg.substring(0, 1) // 获取到后面的所有字符 var end = this.msg.substring(1) // 重新拼接得到新的字符串，并赋值给 this.msg this.msg = end + start &#125;, 400) // 注意： VM实例，会监听自己身上data中所有数据的改变，只要数据一发生变化，就会自动把最新的数据从data上同步到页面中去； //【好处：程序员只需要关心数据，不需要考虑如何重新渲染DOM页面】 &#125;, stop() &#123; //停止定时器 clearInterval(this.intervalId) //每当清除了定时器之后，需要重新把 intervalId 置为 null this.intervalId = null; &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.5 事件修饰符 .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; .inner &#123; height: 150px; background-color: darkcyan; &#125; .outer &#123; padding: 40px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"阻止冒泡\" @click.stop=\"btnHandler\"&gt; &lt;/div&gt; &lt;!-- 使用 .prevent 阻止默认行为 --&gt; &lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;阻止默认行为&lt;/a&gt; &lt;!-- 使用 .capture 实现捕获触发事件的机制 。打印顺序从外向里 --&gt; &lt;div class=\"inner\" @click.capture=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"捕获事件\" @click=\"btnHandler\"&gt; &lt;/div&gt; &lt;!-- 使用 .self 实现只有点击当前元素时候，才会触发事件处理函数 --&gt; &lt;div class=\"inner\" @click=\"div1Handler.self\"&gt; &lt;input type=\"button\" value=\"self\" @click=\"btnHandler\"&gt; &lt;/div&gt; &lt;!-- 使用 .once 只触发一次事件处理函数 --&gt; &lt;span href=\"http://www.baidu.com\" @click.once=\"spanClick\"&gt;只能触发一次&lt;/span&gt; &lt;!-- 演示： .stop 和 .self 的区别 --&gt; &lt;!--.stop阻止所有的冒泡--&gt; &lt;div class=\"outer\" @click=\"div2Handler\"&gt; &lt;div class=\"inner\" @click=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"stop\" @click.stop=\"btnHandler\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- .self 只有点击当前元素才会触发点击事件。如果子元素的事件冒泡到自己身上，不会执行该事件 --&gt; &lt;div class=\"outer\" @click=\"div2Handler\"&gt; &lt;div class=\"inner\" @click.self=\"div1Handler\"&gt; &lt;input type=\"button\" value=\"self\" @click=\"btnHandler\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; div1Handler() &#123; console.log('这是触发了 inner div 的点击事件') &#125;, btnHandler() &#123; console.log('这是触发了 btn 按钮 的点击事件') &#125;, linkClick() &#123; console.log('触发了连接的点击事件') &#125;, div2Handler() &#123; console.log('这是触发了 outer div 的点击事件') &#125;, spanClick()&#123; console.log('spanClick') &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.6 v-model和双向绑定​ 只有v-model指令实现了双向绑定， v-model 只能运用在表单元素中。如： input(radio, text, address, email….) select checkbox textarea 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=\"app\" action=\"#\"&gt; &lt;p&gt;&lt;input v-model=\"email\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input v-model=\"name\"&gt;&lt;/p&gt; &lt;button @click=\"modify\"&gt;点我修改数据源&lt;/button&gt; &lt;button @click=\"show\"&gt;改完表单再点我&lt;/button&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;&lt;script src=\"lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; email: 'zhangsan@qq.com', name: 'zhangsan' &#125;, methods:&#123; modify:function()&#123; this.email = 'lisi@.qq.com'; &#125;, show:function()&#123; alert(this.email); &#125; &#125; &#125;)&lt;/script&gt; 1.2.7 双向绑定-计算器案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"n1\"&gt; &lt;select v-model=\"opt\"&gt; &lt;option value=\"+\"&gt;+&lt;/option&gt; &lt;option value=\"-\"&gt;-&lt;/option&gt; &lt;option value=\"*\"&gt;*&lt;/option&gt; &lt;option value=\"/\"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type=\"text\" v-model=\"n2\"&gt; &lt;input type=\"button\" value=\"=\" @click=\"calc\"&gt; &lt;input type=\"text\" v-model=\"result\"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '+' &#125;, methods: &#123; calc() &#123; // 计算器算数的方法 // 逻辑： switch (this.opt) &#123; case '+': this.result = parseInt(this.n1) + parseInt(this.n2) break; case '-': this.result = parseInt(this.n1) - parseInt(this.n2) break; case '*': this.result = parseInt(this.n1) * parseInt(this.n2) break; case '/': this.result = parseInt(this.n1) / parseInt(this.n2) break; &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.8 双向绑定的原理1.2.8.1 页面–&gt;数据​ view更新data只需要添加DOM事件监听即可，比如input标签监听 ‘input’ 事件就可以实现 1.2.8.2 数据–&gt;页面​ 是通过数据劫持 + 发布者-订阅者模式的方式来实现的 a) 数据劫持​ vue是通过Object.defineProperty()来实现数据劫持的 1234567891011121314var book = &#123;&#125;Object.defineProperty(book, 'name', &#123; set: function (value) &#123; name = value; console.log('你取了一个书名叫做' + value); &#125;, get: function () &#123; return '《' + name + '》' &#125;&#125;)book.name = 'vue权威指南'; // 你取了一个书名叫做vue权威指南book.name = 'vue权威指南2'; // 你取了一个书名叫做vue权威指南console.log(book.name); // 《vue权威指南》 b) 发布者订阅模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1.消息订阅器，内部维护了所有订阅者的列表function Dep () &#123; this.subs = [];&#125;Dep.prototype = &#123; addSub: function(sub) &#123; this.subs.push(sub); &#125;, notify: function(value) &#123; this.subs.forEach(function(sub) &#123; sub.update(value); &#125;); &#125;&#125;;var dep = new Dep();//2.订阅者function Watcher() &#123;&#125;Watcher.prototype = &#123; update: function(value)&#123; console.log(\"数据源已经变动，新的数据是\"+value) &#125;&#125;var w1 = new Watcher();var w2 = new Watcher();dep.addSub(w1);dep.addSub(w2);//3.数据源，通过defineProperty监听数据源的变化var book = &#123;&#125;Object.defineProperty(book, 'name', &#123; set: function (value) &#123; name = value; //一旦数据源发生变化了，通知所有的订阅者更新数据 dep.notify(value); &#125;, get: function () &#123; return '《' + name + '》' &#125;&#125;)book.name = 'vue权威指南'; // 你取了一个书名叫做vue权威指南book.name = 'vue权威指南2'; // 你取了一个书名叫做vue权威指南console.log(book.name); // 《vue权威指南》 c) 数据绑定的实现流程​ 首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。 ​ 因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。 ​ 接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。 ​ 因此接下去我们执行以下3个步骤，实现数据的双向绑定： 1.监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知所有订阅者。 2.订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。 3.解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅者 ​ 参考链接：https://www.cnblogs.com/libin-1/p/6893712.html 1.2.9 vue样式操作a) class操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 1.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1 class=\"red thin\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意：这里的class需要使用 v-bind 做数据绑定 --&gt; &lt;h1 :class=\"['thin', 'italic']\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;h1 :class=\"['thin', 'italic', flag?'active':'']\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在数组中使用对象来代替三元表达式，提高代码的可读性 --&gt; &lt;h1 :class=\"['thin', 'italic', &#123;'active':flag&#125; ]\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在为class使用v-bind绑定对象的时候，对象的属性是类名，属性的值是一个标识符 --&gt; &lt;h1 :class=\"classObj\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; .red &#123; color: red; &#125; .thin &#123; font-weight: 200; &#125; .italic &#123; font-style: italic; &#125; .active &#123; letter-spacing: 1.5em; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;h1 class=\"red thin\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 第一种使用方式，直接传递一个数组，注意：这里的class需要使用 v-bind 做数据绑定 --&gt; &lt;h1 :class=\"['thin', 'italic']\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在数组中使用三元表达式 --&gt; &lt;h1 :class=\"['thin', 'italic', flag?'active':'']\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在数组中使用对象来代替三元表达式，提高代码的可读性 --&gt; &lt;h1 :class=\"['thin', 'italic', &#123;'active':flag&#125; ]\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;!-- 在为class使用v-bind绑定对象的时候，对象的属性是类名，由于对象的属性可带引号，也可不带引号，所以这里我没写引号;属性的值是一个标识符 --&gt; &lt;h1 :class=\"classObj\"&gt;这是一个很大很大的H1，大到你无法想象！！！&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: true, classObj: &#123; red: true, thin: true, italic: false, active: false &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b) style操作123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 对象就是无序键值对的集合 --&gt; &lt;h1 :style=\"styleObj1\"&gt;标题1&lt;/h1&gt; &lt;h1 :style=\"[styleObj1,styleObj2]\"&gt;标题2&lt;/h1&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; styleObj1: &#123; color: 'red', 'font-weight': 200 &#125;, styleObj2: &#123; 'font-style': 'italic' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.10 vue循环a) 循环普通数据12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;list[0]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[1]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[2]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[3]&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;list[4]&#125;&#125;&lt;/p&gt; &lt;p&gt;--------------------------------------------&lt;/p&gt; &lt;p v-for=\"(item, i) in list\"&gt;索引值：&#123;&#123;i&#125;&#125; --- 每一项：&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [1, 2, 3, 4, 5, 6] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b) 循环对象数组12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-for=\"(user, i) in list\"&gt;Id：&#123;&#123; user.id &#125;&#125; --- 名字：&#123;&#123; user.name &#125;&#125; --- 索引：&#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: 1, name: 'zs1' &#125;, &#123; id: 2, name: 'zs2' &#125;, &#123; id: 3, name: 'zs3' &#125;, &#123; id: 4, name: 'zs4' &#125; ] &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; c) 循环对象12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 注意：在遍历对象身上的键值对的时候， 除了 有 val key ,在第三个位置还有 一个 索引 --&gt; &lt;p v-for=\"(val, key, i) in user\"&gt;值是： &#123;&#123; val &#125;&#125; --- 键是： &#123;&#123;key&#125;&#125; -- 索引： &#123;&#123;i&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; user: &#123; id: 1, name: '托尼·屎大颗', gender: '男' &#125; &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; d) 循环数字1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- in 后面还可以放数字 --&gt; &lt;!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 --&gt; &lt;p v-for=\"count in 10\"&gt;这是第 &#123;&#123; count &#125;&#125; 次循环&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; e) 循环中key的使用​ 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 ​ 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=\"text\" v-model=\"id\"&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=\"text\" v-model=\"name\"&gt; &lt;/label&gt; &lt;input type=\"button\" value=\"添加\" @click=\"add\"&gt; &lt;/div&gt; &lt;!--:key的作用：保证数据和页面的关联，让数据和页面一一对应。这个地方如果不加key，在给某一个input打钩之后再新增数据就会出现问题--&gt; &lt;!-- 注意： v-for 循环的时候，key 属性的值只能是number或者string，否则报错 --&gt; &lt;p v-for=\"item in list\" :key=\"item.id\"&gt; &lt;input type=\"checkbox\"&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '李斯' &#125;, &#123; id: 2, name: '嬴政' &#125;, &#123; id: 3, name: '赵高' &#125;, &#123; id: 4, name: '韩非' &#125;, &#123; id: 5, name: '荀子' &#125; ] &#125;, methods: &#123; add() &#123; // 添加方法 this.list.unshift(&#123; id: this.id, name: this.name &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.11 v-if和v-show​ 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toffle1\" @click=\"toggle\"&gt; &lt;input type=\"button\" value=\"toggle2\" @click=\"flag=!flag\"&gt; &lt;!-- v-if 的特点：每次都会重新删除或创建元素,有较高的切换性能消耗 --&gt; &lt;!-- v-show 的特点： 每次不会重新进行DOM的删除和创建操作，只是切换了元素的 display:none 样式 --&gt; &lt;!-- 如果元素涉及到频繁的切换，最好不要使用 v-if, 而是推荐使用 v-show --&gt; &lt;!-- 如果元素可能永远也不会被显示出来被用户看到，则推荐使用 v-if --&gt; &lt;h3 v-if=\"flag\"&gt;这是用v-if控制的元素&lt;/h3&gt; &lt;h3 v-show=\"flag\"&gt;这是用v-show控制的元素&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; toggle() &#123; this.flag = !this.flag &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.12 品牌管理案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap-3.3.7.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; Id: &lt;input type=\"text\" class=\"form-control\" v-model=\"id\"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=\"text\" class=\"form-control\" v-model=\"name\"&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type=\"button\" value=\"添加\" class=\"btn btn-primary\" @click=\"add()\"&gt; &lt;label&gt; 搜索名称关键字： &lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;!-- 之前， v-for中的数据，都是直接从data上的list中直接渲染过来的 --&gt; &lt;!-- 现在， 我们自定义了一个search方法，调用这个方法获取数据 --&gt; &lt;!-- 在 search 方法内部，通过执行for循环， 把所有符合搜索关键字的数据，保存到 一个新数组中返回 --&gt; &lt;tr v-for=\"item in search()\" :key=\"item.id\"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td v-text=\"item.name\"&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keywords: '', // 搜索的关键字 list: [ &#123; id: 1, name: '奔驰', ctime: new Date() &#125;, &#123; id: 2, name: '宝马', ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; // 添加的方法 var car = &#123; id: this.id, name: this.name, ctime: new Date() &#125; this.list.push(car) this.id = this.name = '' &#125;, del(id) &#123; // 根据Id删除数据 var index = this.list.findIndex(item =&gt; &#123; if (item.id == id) &#123; return true; &#125; &#125;) this.list.splice(index, 1) &#125;, search() &#123; // 根据关键字，进行数据的搜索 // 注意： forEach some filter findIndex 这些都属于数组的新方法，都会对数组中的每一项，进行遍历，执行相关的操作； return this.list.filter(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) // 注意 ： ES6中，为字符串提供了一个新方法，叫做 String.prototype.includes('要包含的字符串')。如果包含，则返回 true ，否则返回 false if (item.name.includes(this.keywords)) &#123; return item &#125; &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.2.13 Vue-devtoolsa) 将vue-devtools拷贝到本地https://github.com/vuejs/vue-devtools.git b) 在vue-devtools目录下安装依赖包12cd vue-devtoolsnpm install c) 编译代码1npm run build d) 修改manifest.json文件​ 修改 vue-devtools/shells/chrome/manifest.json文件，将 persistent改成 true e) 添加谷歌扩展程序​ 打开开发者模式 ​ 启用vue-devtools ​ 允许访问文件地址 1.3 过滤器、按钮修饰符、自定义指令​ 概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 1.3.1 私有过滤器 HTML元素： 1&lt;p&gt;&#123;&#123; msg | msgFormat('疯狂+1', '123') | test &#125;&#125;&lt;/p&gt; 私有 filters 定义方式： 1234567891011121314151617181920&lt;body&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人' &#125;, methods: &#123;&#125;, filters: &#123; // 过滤器的三个参数：1.要过滤的文本 2.过滤的内容 3.替换的内容 // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 msgFormat: function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/少年/g, arg + arg2) &#125; &#125;, &#125;); &lt;/script&gt;&lt;/body&gt; 1.3.2 全局过滤器1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; msg | msgFormat('疯狂+1', '123') | test &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter('msgFormat', function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg + arg2) &#125;) Vue.filter('test', function (msg) &#123; return msg + '========' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人' &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt; 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 1.3.3 键盘修饰符以及自定义键盘修饰符a) 键盘修饰符https://cn.vuejs.org/v2/guide/events.html#%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6 1&lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.enter=\"add\"&gt; b) 自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 12//约定113对应f2Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 1&lt;input type=\"text\" v-model=\"name\" @keyup.f2=\"add\"&gt; 1.3.4 自定义指令https://cn.vuejs.org/v2/guide/custom-directive.html a) 自定义全局和局部的指令12345678910111213141516171819202122232425262728293031323334// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：// 其中：参数1 ： 指令的名称，注意，在定义的时候，指令的名称前面，不需要加 v- 前缀, 但是： 在调用的时候，必须 在指令名称前 加上 v- 前缀来进行调用// 参数2： 是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作Vue.directive('focus', &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个bind 函数，只执行一次 // 注意： 在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象 // 在元素刚绑定了指令的时候还没有插入到DOM中去的时候调用focus方法没有作用。因为，一个元素只有插入DOM之后才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】。和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 el.focus() &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125;&#125;)// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细：directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于把代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125;&#125; 自定义指令的使用方式： 1&lt;h3 v-color=\"'pink'\" v-fontweight=\"900\" v-fontsize=\"50\"&gt;这是h3标题&lt;/h3&gt; 1.3.5 品牌管理案例重写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap-3.3.7.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; Id: &lt;input type=\"text\" class=\"form-control\" v-model=\"id\"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;!-- 使用自定义键盘修饰符 --&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"name\" @keyup.f2=\"add\"&gt; &lt;/label&gt; &lt;!-- 在Vue中，使用事件绑定机制，为元素指定处理函数的时候，如果加了小括号，就可以给函数传参了 --&gt; &lt;input type=\"button\" value=\"添加\" class=\"btn btn-primary\" @click=\"add()\"&gt; &lt;label&gt; 搜索名称关键字： &lt;!-- 注意： Vue中所有的指令，在调用的时候，都以 v- 开头 v-focus v-color 自动获取焦点和设置文本颜色为绿色 --&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"keywords\" id=\"search\" v-focus v-color=\"'green'\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"item in search(keywords)\" :key=\"item.id\"&gt; &lt;td&gt;&#123;&#123; item.id &#125;&#125;&lt;/td&gt; &lt;td v-text=\"item.name\"&gt;&lt;/td&gt; &lt;!-- 过滤器调用时候的格式 &#123;&#123; name | 过滤器的名称 &#125;&#125; --&gt; &lt;td&gt;&#123;&#123; item.ctime | dateFormat() &#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"app2\"&gt; &lt;h3 v-color=\"'pink'\" v-fontweight=\"900\" v-fontsize=\"50\"&gt;&#123;&#123; dt | dateFormat &#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 全局的过滤器， 进行时间的格式化 // 所谓的全局过滤器，就是所有的VM实例都共享的 Vue.filter('dateFormat', function (dateStr, pattern = \"\") &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) // yyyy-mm-dd var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 // 压缩版的vue.js如果要开启Vue的devtools的需要设置下面代码 Vue.config.devtools = true // Vue.directive()定义全局的指令 v-focus Vue.directive('focus', &#123; bind: function (el) &#123; &#125;, inserted: function (el) &#123; el.focus() &#125;, updated: function (el) &#123; &#125; &#125;) // 自定义一个设置字体颜色的指令 Vue.directive('color', &#123; // 样式:只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function (el, binding) &#123; // el.style.color = 'red' // console.log(binding.name) // console.log(binding.value) // console.log(binding.expression) // 和样式相关的操作，一般都可以在 bind 执行 el.style.color = binding.value &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', keywords: '', // 搜索的关键字 list: [ &#123; id: 1, name: '奔驰', ctime: new Date() &#125;, &#123; id: 2, name: '宝马', ctime: new Date() &#125; ] &#125;, methods: &#123; add() &#123; // 添加的方法 var car = &#123; id: this.id, name: this.name, ctime: new Date() &#125; this.list.push(car) this.id = this.name = '' &#125;, del(id) &#123; // 根据Id删除数据 var index = this.list.findIndex(item =&gt; &#123; if (item.id == id) &#123; return true; &#125; &#125;) this.list.splice(index, 1) &#125;, search(keywords) &#123; // 根据关键字，进行数据的搜索 return this.list.filter(item =&gt; &#123; if (item.name.includes(keywords)) &#123; return item &#125; &#125;) &#125; &#125; &#125;); // 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123; // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 dateFormat: function (dateStr, pattern = '') &#123; // 根据给定的时间字符串，得到特定的时间 var dt = new Date(dateStr) var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2, '0') var d = dt.getDate().toString().padStart(2, '0') if (pattern.toLowerCase() === 'yyyy-mm-dd') &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125; else &#123; var hh = dt.getHours().toString().padStart(2, '0') var mm = dt.getMinutes().toString().padStart(2, '0') var ss = dt.getSeconds().toString().padStart(2, '0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125; ~~~~~~~` &#125; &#125; &#125;, directives: &#123; // 自定义私有指令 'fontweight': &#123; // 设置字体粗细的 bind: function (el, binding) &#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding) &#123; // 注意：这个 function 等同于把代码写到了 bind 和 update 中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.4 Vue的生命周期1.4.1 生命周期函数https://cn.vuejs.org/v2/guide/instance.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"修改msg\" @click=\"msg='No'\"&gt; &lt;h3 id=\"h3\"&gt;&#123;&#123; msg &#125;&#125;&lt;/h3&gt;&lt;/div&gt;&lt;template id=\"demo1\"&gt; &lt;h2&gt;标签模版&lt;/h2&gt;&lt;/template&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', //如果没有写template，则会将el的外部html作为模板进行编译 /*template:\"#demo1\",*/ data: &#123; msg: 'ok' &#125;, methods: &#123; show() &#123; console.log('执行了show方法') &#125; &#125;, beforeCreate() &#123; // 这是我们遇到的第一个生命周期函数，表示实例完全被创建出来之前会执行它 // console.log(this.msg) // this.show() // 注意： 在 beforeCreate 生命周期函数执行的时候，data 和 methods 中的数据都还没有没初始化 &#125;, created() &#123; // 这是遇到的第二个生命周期函数 // console.log(this.msg) // this.show() // 在 created 中，data 和 methods 都已经被初始化好了！ // 如果要调用 methods 中的方法，或者操作 data 中的数据，最早只能在 created 中操作 &#125;, beforeMount() &#123; // 这是遇到的第3个生命周期函数，表示模板已经在内存中编辑完成了，但是尚未把模板渲染到页面中 // console.log(document.getElementById('h3').innerText) // 在 beforeMount 执行的时候，页面中的元素还没有被真正替换过来，只是之前写的一些模板字符串 &#125;, mounted() &#123; // 这是遇到的第4个生命周期函数，表示内存中的模板已经真实的挂载到了页面中，用户已经可以看到渲染好的页面了 // console.log(document.getElementById('h3').innerText) // 注意： mounted是实例创建期间的最后一个生命周期函数，当执行完mounted就表示Vue实例已经被完全创建好了，此时如果没有其它操作的话，这个实例就静静的躺在我们的内存中一动不动 &#125;, // 接下来的是运行中的两个事件 beforeUpdate() &#123; // 这时候表示数据更新了但是界面还没有被更新 /* console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) */ // 得出结论： 当执行 beforeUpdate 的时候，页面中的显示的数据还是旧的，此时 data 数据是最新的，页面尚未和最新的数据保持同步 &#125;, updated() &#123; console.log('界面上元素的内容：' + document.getElementById('h3').innerText) console.log('data 中的 msg 数据是：' + this.msg) // updated 事件执行的时候，页面和 data 数据已经保持同步了，都是最新的 &#125; &#125;); //如果在创建vm实例的时候没有挂载el，可以通过代码手动挂载 vm.$mount(\"#app\");&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.4.2 Vue.nextTick()​ 该方法会在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 ​ 应用场景： 在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中 在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。 123456789101112created() &#123; //改变数据 vm.message = 'changed' //想要立即使用更新后的DOM。这样不行，因为设置message后DOM还没有更新 console.log(document.getElementById('testCount').innerHTML) // 并不会得到'changed' //这样可以，nextTick里面的代码会在DOM更新后执行 Vue.nextTick(function()&#123; console.log(document.getElementById('testCount').innerHTML) //可以得到'changed' &#125;)&#125;, 1.4.3 nextTick原理a) 异步说明 Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。 ​ 在 Vue 的文档中，说明 Vue 是异步执行 DOM 更新的。关于异步的解析，可以查看阮一峰老师的这篇文章，截取关键部分如下： ​ 具体来说，异步执行的运行机制如下。 （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。（4）主线程不断重复上面的第三步。 ​ 下图就是主线程和任务队列的示意图。 b) 时间循环说明​ 简单来说，Vue 在修改数据后，视图不会立刻更新，而是等同一事件循环中的所有数据变化完成之后，再统一进行视图更新。图解： 事件循环： ​ 第一个 tick（图例中第一个步骤，即’本次更新循环’）： 首先修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时还未涉及 DOM 。 Vue 开启一个异步队列，并缓冲在此事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。 ​ 第二个 tick（图例中第二个步骤，即’下次更新循环’）： ​ 同步任务执行完毕，开始执行异步 watcher 队列的任务，更新 DOM 。Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel 方法，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 ​ 第三个 tick（图例中第三个步骤）： ​ 此时就是文档所说的：下次 DOM 更新循环结束之后 ​ 此时通过 Vue.nextTick 获取到改变后的 DOM 。通过 setTimeout(fn, 0) 也可以同样获取到。 ​ 总结事件循环 ： 同步代码执行 -&gt; 查找异步队列，推入执行栈，执行Vue.nextTick[事件循环1] -&gt;查找异步队列，推入执行栈，执行Vue.nextTick[事件循环2]… ​ 异步是单独的一个tick，不会和同步在一个 tick 里发生，也是 DOM 不会马上改变的原因。 1.4.4 nextTick()案例12345678910//点击按钮显示文本输入框，同时让其获取焦点methods:&#123; showsou()&#123; this.showit = true this.$nextTick(function () &#123; // DOM 更新了 document.getElementById(\"keywords\").focus() &#125;) &#125;&#125; 1.5 Vue-resource使用​ 在vue中，我们可以使用vue-resource去发送请求，也可以使用axios来发送请求 1.5.1 GER/POST12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# 这边测试服务器使用品牌列表的服务器&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;!-- 注意：vue-resource 依赖于 Vue，所以先后顺序要注意 --&gt; &lt;!-- this.$http.jsonp --&gt; &lt;script src=\"./lib/vue-resource-1.3.4.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"get请求\" @click=\"getInfo\"&gt; &lt;input type=\"button\" value=\"post请求\" @click=\"postInfo\"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getInfo()&#123; this.$http.get('http://localhost:3000/api/getnewslist').then(function (result) &#123; // 通过 result.body 拿到服务器返回的成功的数据 console.log(result.body) &#125;) &#125;, postInfo()&#123; this.$http.post('http://localhost:3000/api/news/new', &#123; id: \"123\", name:\"网易新闻\" &#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; console.log(result.body) &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.5.2 JSONPa) 使用script标签发送JSONP请求1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function showInfo123(data) &#123; console.log(data) &#125; &lt;/script&gt;&lt;script src=\"http://127.0.0.1:3000/api/getscript?callback=showInfo123\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b) 使用$http.jsonp方法发送JSONP请求12345678910111213141516171819202122232425&lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;script src=\"./lib/vue-resource-1.3.4.js\"&gt;&lt;/script&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"jsonp请求\" @click=\"testjsonp\"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; testjsonp()&#123; # 这边如果修改了jsonp的值，服务器端的代码也要做对应的修改 # 服务器代码仍然参照品牌列表案例的服务器代码 this.$http.jsonp('http://localhost:3000/api/getscript',&#123;jsonp:\"callback\"&#125;).then(result =&gt; &#123; console.log(result.body) &#125;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 1.5.3 品牌列表案例重写(Vue-resource)​ 服务器代码参照资料中code—&gt;brand-list—&gt;server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script src=\"./lib/vue-resource-1.3.4.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap-3.3.7.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div class=\"panel panel-primary\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h3 class=\"panel-title\"&gt;添加品牌&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"panel-body form-inline\"&gt; &lt;label&gt; Name: &lt;input type=\"text\" v-model=\"name\" class=\"form-control\"&gt; &lt;/label&gt; &lt;input type=\"button\" value=\"添加\" @click=\"add\" class=\"btn btn-primary\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class=\"table table-bordered table-hover table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=\"item in list\" :key=\"item.id\"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=\"\" @click.prevent=\"del(item.id)\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script&gt; // 全局启用 emulateJSON 选项 Vue.http.options.emulateJSON = true; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; name: '', // 存放所有品牌列表的数组 list: [ ] &#125;, created() &#123; // 当 vm 实例 的 data 和 methods 初始化完毕后，vm实例会自动执行created 这个生命周期函数 this.getAllList() &#125;, methods: &#123; getAllList() &#123; // 获取所有的品牌列表 this.$http.get('http://localhost:3000/api/getnewslist').then(result =&gt; &#123; // 注意： 通过 $http 获取到的数据，都在 result.body 中放着 var result = result.body if (result.status === 0) &#123; // 成功了 this.list = result.message &#125; else &#123; // 失败了 alert('获取数据失败！') &#125; &#125;) &#125;, // 添加品牌列表到后台服务器 add() &#123; // 分析： // 1. 听过查看 数据API接口 要发送一个 Post 请求， this.$http.post // 2. this.$http.post() 中接收三个参数： // 2.1 第一个参数： 要请求的URL地址 // 2.2 第二个参数： 要提交给服务器的数据 ，要以对象形式提交给服务器 &#123; name: this.name &#125; // 3.3 第三个参数： 是一个配置对象，要以哪种表单数据类型提交过去， &#123; emulateJSON: true &#125;, 以普通表单格式，将数据提交给服务器 application/x-www-form-urlencoded // 3. 在 post 方法中，使用 .then 来设置成功的回调函数，如果想要拿到成功的结果，需要 result.body /* this.$http.post('api/addproduct', &#123; name: this.name &#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 成功了！ // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' &#125; else &#123; // 失败了 alert('添加失败！') &#125; &#125;) */ this.$http.post('http://localhost:3000/api/news/new', &#123; name: this.name &#125;).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 添加完成后，只需要手动，再调用一下 getAllList 就能刷新品牌列表了 this.getAllList() // 清空 name this.name = '' &#125; else &#123; // 失败了 alert('添加失败！') &#125; &#125;) &#125;, // 删除品牌 del(id) &#123; this.$http.get('http://localhost:3000/api/news/del/'+id).then(result =&gt; &#123; if (result.body.status === 0) &#123; // 删除成功 this.getAllList() &#125; else &#123; alert('删除失败！') &#125; &#125;) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;# 统一设置Vue-resource的请求信息Vue.http.options.emulateJSON = true;Vue.http.options.root = 'http://localhost:3000/'; 1.6 Vue中的动画https://cn.vuejs.org/v2/guide/transitions.html ​ Vue 在插入、更新或者移除 DOM 时，提供下面的多种不同方式的应用过渡效果。 在 CSS 过渡和动画中自动应用 class —过渡类名 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js ​ Vue 提供了内置的过渡封装组件，该组件用于包裹要实现过渡效果的组件。 1.6.1 不使用动画12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;h3 v-if=\"flag\"&gt;这是一个H3&lt;/h3&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6.2 使用过渡类名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt; &lt;style&gt; h3&#123; background-color:red; width:100px; &#125; /*全场动画：使用过渡类名*/ /* v-enter 【这是一个时间点】 是进入之前，元素的起始状态，此时还没有开始进入 */ /* v-leave-to 【这是一个时间点】 是动画离开之后，离开的终止状态，此时元素动画已经结束了 */ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; /* v-enter-active 【入场动画的时间段】 */ /* v-leave-active 【离场动画的时间段】 */ .v-enter-active&#123; transition: all 1.8s ease; &#125; .v-leave-active&#123; transition: all 0.8s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;!-- 1. 使用 transition 元素，把 需要被动画控制的元素，包裹起来 --&gt; &lt;!-- transition 元素，是 Vue 官方提供的 --&gt; &lt;transition&gt; &lt;h3 v-if=\"flag\"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6.3 修改动画前缀12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;!-- 2. 自定义两组样式，来控制 transition 内部的元素实现动画 --&gt; &lt;style&gt; .my-enter, .my-leave-to &#123; opacity: 0; transform: translateY(70px); &#125; .my-enter-active, .my-leave-active&#123; transition: all 0.8s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle2\" @click=\"flag2=!flag2\"&gt; &lt;transition name=\"my\"&gt; &lt;h6 v-if=\"flag2\"&gt;这是一个H6&lt;/h6&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false, flag2: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6.4 AnimateCSS​ animate.css是一个使用CSS3的animation制作的动画效果的CSS集合，里面预设了很多种常用的动画，且使用非常简单。 https://daneden.github.io/animate.css/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/animate.css\"&gt; &lt;!-- 入场 bounceIn 离场 bounceOut --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"toggle\" @click=\"flag=!flag\"&gt; &lt;!-- 需求： 点击按钮，让 h3 显示，再点击，让 h3 隐藏 --&gt; &lt;transition enter-active-class=\"animated bounceIn\" leave-active-class=\"animated bounceOut\"&gt; &lt;h3 v-if=\"flag\"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;!-- 使用 :duration=\"毫秒值\" 来统一设置 入场 和 离场 时候的动画时长 注意：这边duration时间设置过长无效--&gt; &lt;transition enter-active-class=\"bounceIn\" leave-active-class=\"bounceOut\" :duration=\"200\"&gt; &lt;h3 v-if=\"flag\" class=\"animated\"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;!-- 使用 :duration=\"&#123; enter: 200, leave: 400 &#125;\" 来分别设置 入场的时长 和 离场的时长 --&gt; &lt;transition enter-active-class=\"bounceIn\" leave-active-class=\"bounceOut\" :duration=\"&#123; enter: 200, leave: 400 &#125;\"&gt; &lt;h3 v-if=\"flag\" class=\"animated\"&gt;这是一个H3&lt;/h3&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6.5 动画的钩子函数​ Vue2实现动画的方式可以是css也可以js钩子，大部分情况下css3即可满足，但若是需要在实现动画过程中进行位置计算，那就需要使用js钩子函数来进行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; .ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"快到碗里来\" @click=\"flag=!flag\"&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\" @before-leave=\"beforeLeave\" @leave=\"leave\" @after-leave=\"afterLeave\"&gt; &lt;div class=\"ball\" v-show=\"flag\"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; //el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象 beforeEnter(el)&#123; // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式 el.style.transform = \"translate(0px, 0px)\" el.style.opacity = 0.0 &#125;, //当只有javascript过渡的时候，在enter和leave中必须使用done进行回调。done的作用其实是调用afterEnter和afterLeave方法 enter(el,done)&#123; //el.offsetWidth 会强制动画刷新 el.offsetWidth // enter 表示动画 开始之后的样式，在这里可以设置小球完成动画之后的结束状态 el.style.transform = \"translate(150px, 450px)\" el.style.transition = 'all 1s ease' el.style.opacity = 1.0 //过渡动画结束后调用afterEnter方法 el.addEventListener('transitionend', done); &#125;, afterEnter(el)&#123; // 动画完成之后，会调用 afterEnter console.log('ok111') &#125;, beforeLeave(el)&#123; //el.style.opacity = 1.0 el.style.transform = \"translate(150px, 450px)\" console.log(\"beforeLeave\") &#125;, leave(el,done)&#123; console.log(\"leave\") el.offsetWidth // leave 表示动画 离开 之后的样式，在这里可以设置小球完成动画之后的结束状态 el.style.transition = 'all 1s ease' el.style.opacity = 0 el.style.transform = \"translate(0px,0px)\" el.addEventListener('transitionend', done); &#125;, afterLeave(el)&#123; // 动画完成之后，会调用 afterEnter console.log('ok222') &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6.6 实现添加购物车的动画效果​ 需求：在添加购物车动画执行完毕之后就立马隐藏小球 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; .ball &#123; width: 15px; height: 15px; border-radius: 50%; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"快到碗里来\" @click=\"flag=!flag\"&gt; &lt;!-- 1. 使用 transition 元素把 小球包裹起来 --&gt; &lt;transition @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\"&gt; &lt;div class=\"ball\" v-show=\"flag\"&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123; //el，表示 要执行动画的那个DOM元素，是个原生的 JS DOM对象 beforeEnter(el)&#123; // beforeEnter 表示动画入场之前，此时，动画尚未开始，可以 在 beforeEnter 中，设置元素开始动画之前的起始样式 el.style.transform = \"translate(0px, 0px)\" &#125;, enter(el,done)&#123; //el.offsetWidth 会强制动画刷新 el.offsetWidth // enter 表示动画 开始之后的样式，在这里可以设置小球完成动画之后的结束状态 el.style.transform = \"translate(150px, 450px)\" el.style.transition = 'all 1s ease' el.addEventListener('transitionend', done); &#125;, afterEnter(el)&#123; //上面使用done之后会在动画执行完了就立马隐藏小球 console.log('ok') //解决afterEnter被触发后要过一段时间才能隐藏的问题 el.style.display = 'none' //动画分为上半场和下半场，上半场指的是 flag : false ---&gt; true // 下半场指的是 flag ： true ---&gt;false //这里让this.flag = !this.flag是执行下半场的动画(虽然我们没有定义过下半场动画)。如果没有这个代码，那我们点击一下按钮进行动画，再点击一下按钮进行动画就会有问题。 this.flag = !this.flag &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.6.7 列表动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; li &#123; border: 1px dashed #999; margin: 5px; line-height: 35px; padding-left: 5px; font-size: 12px; width: 100%; &#125; li:hover &#123; background-color: hotpink; transition: all 0.8s ease; &#125; /*整个列表进入动画*/ .v-enter, .v-leave-to &#123; opacity: 0; transform: translateY(80px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.6s ease; &#125; /*transition-group 不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用*/ /* 下面的 .v-move 和 .v-leave-active 配合使用，能够实现列表后续的元素，渐渐地漂上来的效果 。其原理是点击要删除的li的时候动态添加absulute样式，让其脱标，下面元素就可以顶上来了 */ .v-move &#123; /*列表排序过滤*/ transition: all 10.6s ease; &#125; .v-leave-active&#123; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;div&gt; &lt;label&gt; Id: &lt;input type=\"text\" v-model=\"id\"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type=\"text\" v-model=\"name\"&gt; &lt;/label&gt; &lt;input type=\"button\" value=\"添加\" @click=\"add\"&gt; &lt;/div&gt; &lt;!-- &lt;ul&gt; --&gt; &lt;!-- 在实现列表过渡的时候，如果需要过渡的元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup --&gt; &lt;!-- 如果要为 v-for 循环创建的元素设置动画，必须为每一个元素设置 :key 属性 --&gt; &lt;!-- 给 transition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 --&gt; &lt;!-- 通过 为 transition-group 元素，设置 tag 属性，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 --&gt; &lt;transition-group appear tag=\"ul\"&gt; &lt;li v-for=\"(item, i) in list\" :key=\"item.id\" @click=\"del(i)\"&gt; &#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/li&gt; &lt;/transition-group&gt; &lt;!-- &lt;/ul&gt; --&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; id: '', name: '', list: [ &#123; id: 1, name: '赵高' &#125;, &#123; id: 2, name: '秦桧' &#125;, &#123; id: 3, name: '严嵩' &#125;, &#123; id: 4, name: '魏忠贤' &#125; ] &#125;, methods: &#123; add() &#123; //this.list.push(&#123; id: this.id, name: this.name &#125;) this.list.splice(1,0,&#123; id: this.id, name: this.name &#125;) this.id = this.name = '' &#125;, del(i) &#123; this.list.splice(i, 1) &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.7 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js双向绑定的实现原理 pagekit/vue-resource navicat如何导入sql文件和导出sql文件 贝塞尔在线生成器 2. Vue组件2.1 定义Vue组件2.1.1 基本概念​ 什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可； ​ 组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用； 2.2.2 全局组件的定义a) 使用 Vue.extend 配合 Vue.component 方法：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 如果要使用组件，直接，把组件的名称，以 HTML 标签的形式，引入到页面中，即可 --&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;my-component2&gt;&lt;/my-component2&gt; &lt;my-component3&gt;&lt;/my-component3&gt; &lt;/div&gt; &lt;script&gt; //方式一：分成两步 // 1.1 使用 Vue.extend 来创建全局的Vue组件 var com1 = Vue.extend(&#123; template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件1&lt;/h3&gt;' // 通过 template 属性，指定了组件要展示的HTML结构 &#125;) // 1.2 使用 Vue.component注册组件 // 如果使用 Vue.component 定义全局组件的时候，组件名称使用了驼峰命名，则在引用组件的时候，需要把大写的驼峰改为小写的字母，同时两个单词之间使用 - 连接； // 如果不使用驼峰,则直接拿名称来使用即可; Vue.component('myComponent', com1) // 方式二：直接使用Vue.component注册组件 Vue.component('myComponent2', Vue.extend(&#123; template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件2&lt;/h3&gt;' &#125;)) // 方式三：上面代码也可以这样简写 Vue.component('myComponent3', &#123; template: '&lt;h3&gt;这是使用 Vue.extend 创建的组件3&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;# 注意：一个组件只可以有唯一的根元素 b) 模板字符串定义组件123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;/div&gt; &lt;!-- 在 被控制的 #app 外面,使用 template 元素,定义组件的HTML模板结构 --&gt; &lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素,在外部定义的组件结构,这个方式,有代码的只能提示和高亮&lt;/h1&gt; &lt;h4&gt;好用,不错!&lt;/h4&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; Vue.component('mycom3', &#123; template: '#tmpl' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 2.2.3 私有组建的定义123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;mycom3&gt;&lt;/mycom3&gt; &lt;login&gt;&lt;/login&gt; &lt;/div&gt; &lt;template id=\"tmpl\"&gt; &lt;h1&gt;这是私有的 login 组件&lt;/h1&gt; &lt;/template&gt; &lt;script&gt; var vm2 = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, filters: &#123;&#125;, directives: &#123;&#125;, // 定义实例内部私有组件的 components: &#123; login: &#123; template: '#tmpl' &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2.3 组件中数据和事件a) 基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; &lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;input type=\"button\" value=\"+1\" @click=\"increment\"&gt; &lt;h3&gt;&#123;&#123;count&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; var dataObj = &#123; count: 0 &#125; // 这是一个计数器的组件, 身上有个按钮,每当点击按钮,让 data 中的 count 值 +1 Vue.component('counter', &#123; template: '#tmpl', data: function () &#123; // 在组件中最好return一个独立的对象，每当创建一个新的组件实例，每一个组件实例之间是完全独立的 return &#123; count: 0 &#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; b) 为什么 组件中 data 必须是函数12345678910111213//伪代码var Component = function() &#123;&#125;;Component.prototype.data = &#123; demo: 123&#125;var component1 = new Component();var component2 = new Component();component1.data.demo = 456;console.log(component2.data.demo); // 456//1.从上面可以看出，两个实例都引用同一个对象，其中一个改变的时候，另一个也发生改变。//2.每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。//3.而data是函数，并且在函数中return一个独立对象的时候，每个vue组件的data都因为函数有了自己的作用域，互不干扰。 2.2.4 切换组件a) 使用flag标识符结合v-if和v-else切换组件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;a href=\"\" @click.prevent=\"flag=true\"&gt;登录&lt;/a&gt; &lt;a href=\"\" @click.prevent=\"flag=false\"&gt;注册&lt;/a&gt; &lt;login v-if=\"flag\"&gt;&lt;/login&gt; &lt;register v-else&gt;&lt;/register&gt; &lt;/div&gt; &lt;script&gt; Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; flag: false &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;# 缺点：只能切换两个组件 b) 使用component来切换不同的子组件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;a href=\"\" @click.prevent=\"comName='login'\"&gt;登录&lt;/a&gt; &lt;a href=\"\" @click.prevent=\"comName='register'\"&gt;注册&lt;/a&gt; &lt;!-- Vue提供了 component ,来展示对应名称的组件 --&gt; &lt;!-- component 是一个占位符, :is 属性,可以用来指定要展示的组件的名称 --&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; c) keep-alive组件​ 是Vue的内置组件，能在组件切换过程中将状态保留在内存中，而不是销毁他们，防止重复渲染DOM。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;a href=\"\" @click.prevent=\"comName='login'\"&gt;登录&lt;/a&gt; &lt;a href=\"\" @click.prevent=\"comName='register'\"&gt;注册&lt;/a&gt; &lt;!--keep-alive 将组件缓存--&gt; &lt;!--&lt;keep-alive&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;--&gt; &lt;!--仅缓存login登陆组件 include后面是组件名 --&gt; &lt;!--&lt;keep-alive include=\"login\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;--&gt; &lt;!--使用正则表达式，需要使用v-bind的方式，缓存login和register组件--&gt; &lt;!--&lt;keep-alive :include=\"/login|register/\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;--&gt; &lt;keep-alive :include=\"['login','register']\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!--&lt;keep-alive exclude=\"login\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;--&gt;&lt;/div&gt;&lt;script&gt; // 组件名称是 字符串 Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;input type=\"text\"&gt;&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;input type=\"text\"&gt;&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; d) 组件切换动画https://cn.vuejs.org/v2/guide/transitions.html#%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E8%BF%87%E6%B8%A1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(150px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;a href=\"\" @click.prevent=\"comName='login'\"&gt;登录&lt;/a&gt; &lt;a href=\"\" @click.prevent=\"comName='register'\"&gt;注册&lt;/a&gt; &lt;!-- 通过 mode 属性,设置组件切换时候的模式,out-in 表示原先的组件先出去，后来的组件再进来 --&gt; &lt;transition mode=\"out-in\"&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 组件名称是 字符串 Vue.component('login', &#123; template: '&lt;h3&gt;登录组件&lt;/h3&gt;' &#125;) Vue.component('register', &#123; template: '&lt;h3&gt;注册组件&lt;/h3&gt;' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; comName: 'login' // 当前 component 中的 :is 绑定的组件的名称 &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2 父子组件之间的传值2.2.1 父组件向子组件传值​ 使用步骤： 123456781.父组件给子组件绑定数据&lt;com1 v-bind:parentmsg=\"msg\"&gt;&lt;/com1&gt;2.子组件中提前声明绑定的keyprops: ['parentmsg'], 3.子组件使用props中声明的绑定的keytemplate: '&lt;h1 @click=\"change\"&gt;这是子组件 --- &#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;', 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;!-- 父组件，可以在引用子组件的时候， 通过属性绑定（v-bind:） 的形式, 把需要传递给子组件的数据以属性绑定的形式传递到子组件内部，供子组件使用 --&gt; &lt;com1 v-bind:parentmsg=\"msg\"&gt;&lt;/com1&gt;&lt;/div&gt;&lt;template id=\"tmpl\"&gt; &lt;h1 @click=\"change\"&gt;这是子组件 --- &#123;&#123; parentmsg &#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt; var com1 = &#123; data() &#123; //子组件中的 data 数据，并不是通过父组件传递过来的，而是子组件自身私有的。data 上的数据，都是可读可写的 return &#123; title: '123', content: 'qqq' &#125; &#125;, //子组件默认情况下无法直接访问父组件的数据 //可以通过父组件向子组件传值的方式来实现访问 template: '#tmpl', // 注意： 组件中的所有 props 中的数据，都是通过父组件传递给子组件的。props中的数据都是只读的，无法重新赋值 props: ['parentmsg'], methods: &#123; change() &#123; this.parentmsg = '被修改了' &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123 啊-父组件中的数据' &#125;, methods: &#123;&#125;, components: &#123; com1:com1 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;# 注意：子组件props中的数据只是从父组件传递过来，不可以在子组件中进行修改 2.2.2 子组件向父组件传值​ 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 父组件向子组件传递方法，使用的是事件绑定机制--&gt; &lt;com2 @func=\"show\"&gt;&lt;/com2&gt; &lt;/div&gt; &lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;input type=\"button\" value=\"这是子组件中的按钮 - 点击它，触发父组件传递过来的 func 方法\" @click=\"myclick\"&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 定义了一个字面量类型的组件模板对象 var com2 = &#123; template: '#tmpl', data() &#123; return &#123; sonmsg: &#123; name: '小头儿子', age: 6 &#125; &#125; &#125;, methods: &#123; myclick() &#123; // 当点击子组件的按钮的时候，通过emit触发父组件传递过来的方法。emit 英文原意： 是触发，调用、发射的意思 // 这边的func为父组件中绑定事件的key this.$emit('func', this.sonmsg) &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; datamsgFormSon: null &#125;, methods: &#123; show(data) &#123; this.datamsgFormSon = data console.log(this.datamsgFormSon); &#125; &#125;, components: &#123; com2: com2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 123456789#上面代码也可以简写#1.子组件&lt;input type=\"button\" value=\"这是子组件中的按钮 - 点击它，触发父组件传递过来的 func 方法\" @click=\"$emit('func', this.sonmsg)\"&gt;#2.父组件&lt;com2 @func=\"show\"&gt;&lt;/com2&gt;show(data) &#123; console.log(data);&#125; 2.2.3 插槽 slot​ 插槽使用场景是：子组件需要显示的内容并非来自本身而是父组件动态传递进来的，插槽的内容具体是什么是由父视图在调用的时候决定的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;com2&gt; &lt;!--使用插槽--&gt; &lt;h1 slot=\"header\"&gt;顶部&lt;/h1&gt; &lt;h1 slot=\"footer\"&gt;底部&lt;/h1&gt; &lt;/com2&gt; &lt;/div&gt; &lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;!--声明插槽--&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 定义了一个字面量类型的组件模板对象 var com2 = &#123; template: '#tmpl', data() &#123; return &#123; &#125; &#125;, methods: &#123; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; &#125;, components: &#123; com2: com2 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2.4 评论列表案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;link rel=\"stylesheet\" href=\"./lib/bootstrap-3.3.7.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--使用自定义组件--&gt; &lt;cmt-box @func=\"loadComments\"&gt;&lt;/cmt-box&gt; &lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\" v-for=\"item in list\" :key=\"item.id\"&gt; &lt;span class=\"badge\"&gt;评论人： &#123;&#123; item.user &#125;&#125;&lt;/span&gt; &#123;&#123; item.content &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--定义字符串模板--&gt; &lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;评论人：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" v-model=\"user\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;评论内容：&lt;/label&gt; &lt;textarea class=\"form-control\" v-model=\"content\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"button\" value=\"发表评论\" class=\"btn btn-primary\" @click=\"postComment\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //自定义组件 var commentBox = &#123; data() &#123; return &#123; user: '', content: '' &#125; &#125;, template: '#tmpl', methods: &#123; // 发表评论的方法 postComment() &#123; var comment = &#123; id: Date.now(), user: this.user, content: this.content &#125; // 从 localStorage 中获取所有的评论 var list = JSON.parse(localStorage.getItem('cmts') || '[]') // 添加评论 list.unshift(comment) // 重新保存最新的评论数据 localStorage.setItem('cmts', JSON.stringify(list)) this.user = this.content = '' // 触发父组件传递过来的方法 this.$emit('func') &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; list: [ &#123; id: Date.now(), user: '李白', content: '天生我材必有用' &#125;, &#123; id: Date.now(), user: '江小白', content: '劝君更尽一杯酒' &#125;, &#123; id: Date.now(), user: '小马', content: '我姓马， 风吹草低见牛羊的马' &#125; ] &#125;, beforeCreate()&#123; &#125;, created()&#123; //调用loadComments方法初始化 this.loadComments() &#125;, methods: &#123; //加载评论的方法 loadComments() &#123; var list = JSON.parse(localStorage.getItem('cmts') || '[]') this.list = list &#125; &#125;, //自定义组件 components: &#123; 'cmt-box': commentBox &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2.5 this.$refs 获取元素和组件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"button\" value=\"获取元素\" @click=\"getElement\" ref=\"mybtn\"&gt; &lt;h3 id=\"myh3\" ref=\"myh3\"&gt;哈哈哈， 今天天气太好了！！！&lt;/h3&gt; &lt;hr&gt; &lt;login ref=\"mylogin\"&gt;&lt;/login&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;', data() &#123; return &#123; msg: 'son msg' &#125; &#125;, methods: &#123; show() &#123; console.log('调用了子组件的方法') &#125; &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123; getElement() &#123; // 在vue中不再推荐使用dom操作获取元素了，我们可以使用ref来替换 // console.log(document.getElementById('myh3').innerText) console.log(this.$refs.myh3.innerText) console.log(this.$refs.mylogin.msg) this.$refs.mylogin.show() &#125; &#125;, components: &#123; login &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3 中央事件总线的使用数据传递中央事件总线 - 就是一个名字可以叫做Bus的vue空实例,里边没有任何内容。 它就像一个公交车一样，来回输送人，将组件A输送到组件B，再将组件B输送到组件A； 这里A，B组件可以是父、子组件，也可以是兄、弟组件，或者两个没有任何关系的组件； 12345678910//1.创建中央事件总线var bus = new Vue();//2.使用Bus中央事件总线在A组件中发送信息bus.$emit('自定义事件名'，'$on发送过来的数据')；//3.使用Bus中央事件总线在B组件中接收信息bus.$on('自定义事件名'，function()&#123; //然后执行什么你自己懂的。。。&#125;)； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;com1&gt;&lt;/com1&gt; &lt;com2&gt;&lt;/com2&gt;&lt;/div&gt;&lt;template id=\"tmpl1\"&gt; &lt;div&gt; &lt;h1&gt;这是子组件1&lt;/h1&gt; &lt;button @click=\"sendMessage\"&gt;向组件2发送数据&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=\"tmpl2\"&gt; &lt;div&gt; &lt;h1&gt;这是子组件2&lt;/h1&gt; &lt;h1&gt;&#123;&#123; fromComponentAMsg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //创建中央事件总线 var Bus = new Vue(&#123; name: 'bus', data () &#123; return &#123; // code &#125; &#125; &#125;) // 定义了一个字面量类型的组件模板对象 var com1 = &#123; template: '#tmpl1', data() &#123; return &#123; &#125; &#125;, methods: &#123; sendMessage() &#123; Bus.$emit('inceptMessage', \"组件B，你好\") &#125; &#125; &#125; // 定义了一个字面量类型的组件模板对象 var com2 = &#123; template: '#tmpl2', data() &#123; return &#123; fromComponentAMsg:'' &#125; &#125;, methods: &#123; &#125;, created () &#123; Bus.$on('inceptMessage',(msg) =&gt; &#123; this.fromComponentAMsg = msg &#125;) &#125; &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; &#125;, components: &#123; com1:com1, com2: com2 &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.4 Render方法渲染组件12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;p&gt;444444&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;这是登录组件&lt;/h1&gt;' &#125; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, // createElements 是一个方法，调用它能够把指定的组件模板渲染为html结构 render: function (createElements) &#123; return createElements(login); // 注意：这里 return 的结果，会替换页面中el指定的那个容器 &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;# 在一个el中，render只能渲染一个组件，这个组件会完全替换整个el 3.Vue路由3.1 什么是路由 对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时hash有一个特点，HTTP请求中不会包含hash相关的内容； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 3.2 前端路由案例3.2.1 路由使用步骤https://router.vuejs.org/zh/installation.html 123456789101112131415161718192021222324252627282930313233#1.导入 vue-router 组件类库：&lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt;#2.使用 router-link 组件来导航&lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt;&lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt;#3.使用 router-view 组件来显示匹配到的组件&lt;router-view&gt;&lt;/router-view&gt;#4.创建使用Vue.extend创建组件var login = Vue.extend(&#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;'&#125;);var register = Vue.extend(&#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;'&#125;);#5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;);#6.挂载路由var vm = new Vue(&#123; el: '#app', router: router // 使用 router 属性来使用路由规则&#125;); 3.2.1 路由案例​ 当切换登陆和注册的时候，可以发现url后面#/login和#/register在切换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;!-- 1. 安装 vue-router 路由模块 --&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt; &lt;style&gt; .router-link-active, .myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: green; &#125; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(140px); &#125; .v-enter-active, .v-leave-active &#123; transition: all 0.5s ease; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- &lt;a href=\"#/login\"&gt;登录&lt;/a&gt; --&gt; &lt;!-- &lt;a href=\"#/register\"&gt;注册&lt;/a&gt; --&gt; &lt;!-- router-link 默认渲染为一个a 标签 --&gt; &lt;router-link to=\"/login\" tag=\"span\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\" tag=\"a\"&gt;注册&lt;/router-link&gt; &lt;!-- 这是 vue-router 提供的元素专门用来当作占位符的，将来路由规则匹配到的组件，就会展示到这个 router-view 中去 --&gt; &lt;!-- 所以： 我们可以把 router-view 认为是一个占位符 --&gt; &lt;transition mode=\"out-in\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;script&gt; // 组件的模板对象 var login = &#123; template: '&lt;h1&gt;登录组件&lt;/h1&gt;' &#125; var register = &#123; template: '&lt;h1&gt;注册组件&lt;/h1&gt;' &#125; // 2. 创建一个路由对象，当导入vue-router包之后，在window全局对象中就有了一个路由的构造函数叫做VueRouter var routerObj = new VueRouter(&#123; // 路由匹配规则 routes: [ // 每个路由规则都是一个对象，这个规则对象有两个必须的属性： // 属性1 是 path，表示监听哪个路由链接地址 // 属性2 是 component，表示如果路由是前面匹配到的 path，则展示component对应的那个组件 // 注意： component的属性值，必须是一个组件的模板对象，不能是组件的引用名称 &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125;, &#123; path: '/', redirect: '/register' &#125; //当访问根路径的时候重定向到/register路径 ], //https://router.vuejs.org/zh/api/#tag //设定路由激活的选项的样式 linkActiveClass: 'myactive' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: routerObj // 将路由规则对象，注册到 vm 实例上，用来监听URL地址的变化，然后展示对应的组件 &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.3 路由导航模式​ 在vue-router中有mode这样一个参数，这个参数的可选值有”hash”、 “history”、”abstract”，主要使用hash和history两种。vue中默认是hash模式。 123var routerObj = new VueRouter(&#123; mode: 'hash',&#125;) ​ hash模式背后的原理是onhashchange事件,可以在window对象上监听这个事件 1234567window.onhashchange = function(event)&#123; console.log(event.oldURL, event.newURL); let hash = location.hash.slice(1); document.body.style.color = hash;&#125;//更关键的一点是，因为hash发生变化的url都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用了。这样一来，尽管浏览器没有请求服务器，但是页面状态和url一一关联起来，后来人们给它起了一个霸气的名字叫前端路由，成为了单页应用标配。 ​ history模式底层调用history.pushState()，存在浏览器兼容性问题。 ​ 通过history api，我们丢掉了丑陋的#，但是它也有个毛病，就是history模式会将URL修改的和正常请求后端的URL一样，比如 http://oursite.com/user/id ，这样的话如果后端没有配置对应的user/id这样一个地址的话就会返回404，官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源，找不到资源就返回index.html ​ 而在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带hash的，所以hash的变化不会再次请求服务器，所以没有问题。 3.4 keep-alive结合导航实现缓存12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;keep-alive&gt; &lt;router-view v-if=\"$route.meta.cache\"&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;!-- 不缓存 --&gt; &lt;router-view v-if=\"!$route.meta.cache\"&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var login = &#123; template: '&lt;h3&gt;登录&lt;input type=\"text\"&gt;&lt;/h3&gt;' &#125; var register = &#123; template: '&lt;h3&gt;注册&lt;input type=\"text\"&gt;&lt;/h3&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login , meta: &#123; cache: false &#125; &#125;, &#123; path: '/register', component: register, meta: &#123; cache: true &#125; &#125; ] &#125;) // 创建Vue实例得到ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.5 路由参数的传递3.5.1 URL传参123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!-- 如果在路由中，使用查询字符串给路由传递参数，则不需要修改路由规则的path属性 --&gt; &lt;router-link to=\"/login?id=10&amp;name=zs\"&gt;登录&lt;/router-link&gt; &lt;!-- 也可以这样使用，注意to前面的冒号 --&gt; &lt;router-link :to=\"&#123;path:'login',query:&#123;name:'zs',id:20&#125;&#125;\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.query.id &#125;&#125; --- &#123;&#123; $route.query.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // created()中就可以获取url中的参数信息了 // console.log(this.$route) // console.log(this.$route.query.id) &#125; &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) // 创建Vue实例，得到ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.5.2 Params方式传参12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/login/12/ls\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.params.id &#125;&#125; --- &#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125; &#125; var register = &#123; template: '&lt;h1&gt;注册&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/login/:id/:name', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) // 创建Vue实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router: router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.6 路由的导航钩子函数​ 路由钩子函数：在路由切换的不同阶段调用不同的节点函数，路由钩子函数主要用来拦截导航，让它完成跳转或取消。 ​ 有三种方式设置路由的导航钩子函数 全局的 单个路由独享的 组件级的 a) 组件级钩子函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //路由组件 复用 '路由参数传递' 中的代码var login = &#123; template: '&lt;h1&gt;登录 --- &#123;&#123; $route.params.id &#125;&#125; --- &#123;&#123; $route.params.name &#125;&#125;&lt;/h1&gt;', data()&#123; return &#123; msg: '123' &#125; &#125;, created()&#123; // 组件的生命周期钩子函数 console.log(this.$route.params.id) &#125;, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不能获取组件实例 `this`, 因为当钩子执行前，组件实例还没被创建 console.log(\"login路由进入之前\") next() &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` console.log(\"login组件被复用\") next() &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` console.log(\"login组件离开之前\") next() &#125;&#125;/*next()：进入管道中的下一个钩子，如果全部的钩子执行完了，则导航的状态就是 confirmed（确认的）next(false)：这代表中断掉当前的导航，即 to 代表的路由对象不会进入，被中断，此时该表 URL 地址会被重置到 from 路由对应的地址next(‘/’) 和 next(&#123;path: ‘/’&#125;)：在中断掉当前导航的同时，跳转到一个不同的地址next(error)：如果传入参数是一个 Error 实例，那么导航被终止的同时会将错误传递给 router.onError() 注册过的回调*/ &lt;div id=\"app\"&gt; &lt;router-link to=\"/login/12/ls\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/login/12/ls2\"&gt;登录2&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; b) 全局路由钩子函数12345678910//你可以使用 router.beforeEach 注册一个全局前置守卫(进来之前的守卫)：const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; &#125;)//同样可以注册一个全局的 after 钩子(后置守卫)，不过它不像 before 钩子那样，after 钩子没有 next 方法，不能改变导航router.afterEach((to, from) =&gt; &#123; &#125;) c) 某个路由独享的钩子123456789101112var router = new VueRouter(&#123; routes: [ &#123; path: '/login/:id/:name', component: login , beforeEnter: (to, from, next) =&gt; &#123; console.log(\"login的beforeEnter\") next() &#125; &#125;, &#123; path: '/register', component: register &#125; ]&#125;) d) 路由钩子的应用场景12345678910111213141516171819202122232425//1.清除当前组件中的定时器beforeRouteLeave (to, from, next) &#123; window.clearInterval(this.timer) //清除定时器 next()&#125;//2.当页面中有未关闭的窗口, 或未保存的内容时, 阻止页面跳转beforeRouteLeave (to, from, next) &#123; //判断是否弹出框的状态和保存信息与否 if (this.dialogVisibility === true) &#123; this.dialogVisibility = false //关闭弹出框 next(false) //回到当前页面, 阻止页面跳转 &#125;else if(this.saveMessage === false) &#123; //弹出警告 next(false) //回到当前页面, 阻止页面跳转 &#125;else &#123; next() //否则允许跳转 &#125;&#125;//3.保存相关内容到Vuex中或Session中beforeRouteLeave (to, from, next) &#123; localStorage.setItem(name, content); //保存到localStorage中 next()&#125; f) 通过meta配置登录验证123456789101112131415161718router.beforeEach((to, from, next) =&gt; &#123; window.document.title = to.meta.title; //查找to.matched数组，条件是如果mathed数组中有一个对象的meta.auth为true的时候，则返回那个对象 if(to.matched.some(function(item)&#123; return item.meta.auth &#125;))&#123; //验证逻辑 if(\"已经登录\")&#123; next() &#125; else&#123; next(&#123; path:\"/login\" &#125;) &#125; &#125; else&#123; next() &#125;&#125;) 3.7 路由嵌套12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/account\"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id=\"tmpl\"&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to=\"/account/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/account/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // 组件的模板对象 var account = &#123; template: '#tmpl' &#125; var login = &#123; template: '&lt;h3&gt;登录&lt;/h3&gt;' &#125; var register = &#123; template: '&lt;h3&gt;注册&lt;/h3&gt;' &#125; var router = new VueRouter(&#123; routes: [ &#123; path: '/account', component: account, // 使用children属性实现子路由，同时路由的path前面不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 children: [ &#123; path: 'login', component: login &#125;, &#123; path: 'register', component: register &#125; ] &#125;, //不能在这里写子路由，当前路由和/account路由是平级关系，当url改掉之后，当前路由会完全占据之前的router-view的坑 //&#123; path: '/account/login', component: login &#125;, //&#123; path: '/account/register', component: register &#125; ] &#125;) // 创建Vue实例得到ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.8 命名视图​ 有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt; &lt;style&gt; html, body &#123; margin: 0; padding: 0; &#125; .header &#123; background-color: orange; height: 80px; &#125; h1 &#123; margin: 0; padding: 0; font-size: 16px; &#125; .container &#123; display: flex; height: 600px; &#125; .left &#123; background-color: lightgreen; flex: 2; &#125; .main &#123; background-color: lightpink; flex: 8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;!--没有指定router-view的name,默认就放default组件--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=\"container\"&gt; &lt;!--指定了router-view的name为left,呈现left组件--&gt; &lt;router-view name=\"left\"&gt;&lt;/router-view&gt; &lt;!--指定了router-view的name为main,呈现main组件--&gt; &lt;router-view name=\"main\"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var header = &#123; template: '&lt;h1 class=\"header\"&gt;Header头部区域&lt;/h1&gt;' &#125; var leftBox = &#123; template: '&lt;h1 class=\"left\"&gt;Left侧边栏区域&lt;/h1&gt;' &#125; var mainBox = &#123; template: '&lt;h1 class=\"main\"&gt;mainBox主体区域&lt;/h1&gt;' &#125; // 创建路由对象 var router = new VueRouter(&#123; routes: [ //要实现上面header、左边left、右边main，下面方式做不了，只能做到三选一，在某一路径下，要么header呈现，要么left呈现，要么main呈现 /* &#123; path: '/', component: header &#125;, &#123; path: '/', component: leftBox &#125;, &#123; path: '/', component: mainBox &#125; */ &#123; path: '/', components: &#123; //默认情况下显示的组件 'default': header, //left情况下显示的组件 'left': leftBox, //main情况下显示的组件 'main': mainBox &#125; &#125; ] &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.9 watch属性的使用​ 考虑一个问题：想要实现 第一个文本框 和 第二个文本框 两个文本框的内容改变，则全名的文本框中的值也跟着改变，如何实现？ 3.9.1 使用keyup事件12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstname\" @keyup=\"getFullname\"&gt; + &lt;input type=\"text\" v-model=\"lastname\" @keyup=\"getFullname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', fullname: '' &#125;, methods: &#123; getFullname() &#123; this.fullname = this.firstname + '-' + this.lastname &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.9.2 使用watch监听文本框变化​ watch的作用：主要用来监听data属性值的变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstname\"&gt; + &lt;input type=\"text\" v-model=\"lastname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt; &lt;/div&gt; &lt;script&gt; // 创建Vue实例得到ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', fullname: '' &#125;, methods: &#123;&#125;, // 使用watch属性可以监视data中指定数据的变化，然后触发watch中对应的function处理函数 watch: &#123; 'firstname': function (newVal, oldVal) &#123; // console.log('监视到了 firstname 的变化') // this.fullname = this.firstname + '-' + this.lastname // console.log(newVal + ' --- ' + oldVal) this.fullname = newVal + '-' + this.lastname &#125;, 'lastname': function (newVal) &#123; this.fullname = this.firstname + '-' + newVal &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.9.3 使用watch监听路由地址的变化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt; &lt;!-- 1. 导入包 --&gt; &lt;script src=\"./lib/vue-router-3.0.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;router-link to=\"/login\"&gt;登录&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;!-- 容器 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; // 2. 创建子组件 var login = &#123; template: '&lt;h3&gt;这是登录子组件，这个组件是 奔波霸 开发的。&lt;/h3&gt;' &#125; var register = &#123; template: '&lt;h3&gt;这是注册子组件，这个组件是 霸波奔 开发的。&lt;/h3&gt;' &#125; // 3. 创建一个路由对象 var router = new VueRouter(&#123; routes: [ // 路由规则数组 &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ], linkActiveClass: 'myactive' &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router, watch: &#123; // this.$route.path '$route.path': function (newVal, oldVal) &#123; if (newVal === '/login') &#123; console.log('欢迎进入登录页面') &#125; else if (newVal === '/register') &#123; console.log('欢迎进入注册页面') &#125; &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.10 computed属性的使用​ computed属性的作用：当前的属性值是由data中的其他若干属性值推导出来的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=\"./lib/vue-2.4.0.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt; &lt;input type=\"text\" v-model=\"firstname\"&gt; + &lt;input type=\"text\" v-model=\"middlename\"&gt; + &lt;input type=\"text\" v-model=\"lastname\"&gt; = &lt;input type=\"text\" v-model=\"fullname\"&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123; fullname &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; firstname: '', lastname: '', middlename: '' &#125;, methods: &#123;&#125;, computed: &#123; // 在computed中可以定义一些属性，这些属性叫做【计算属性】，计算属性的本质就是一个方法，只不过我们在使用这些计算属性的时候是把它们的名称直接当作属性来使用的，并不会把计算属性当作方法去调用 // 注意1： 计算属性在引用的时候，一定不要加()去调用，直接把它当作普通属性去使用就好了； // 注意2： 在计算属性的function中所用到的任何data中的数据发送了变化，就会立即重新计算这个计算属性的值 // 注意3： 计算属性的求值结果会被缓存起来，方便下次直接使用。 'fullname': function () &#123; console.log('ok') return this.firstname + '-' + this.middlename + '-' + this.lastname &#125; &#125; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.11 watch、computed和methods之间的对比 computed当前属性的值是依赖于其他属性的值求出来的，计算属性的结果会被缓存，除非依赖的属性变化才会重新计算，主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作; 4.相关文章 URL中的hash（井号）","categories":[],"tags":[{"name":"vue详解","slug":"vue详解","permalink":"http://yoursite.com/tags/vue详解/"}]},{"title":"vue常见问题","date":"2018-09-02T16:00:00.000Z","path":"2018/09/03/vue面试题/","text":"1.vue组件传值几种方式 父组件通过prop向子组件传值 子组件通过事件向父组件传值 子组件与子组件之间不能直接传值，需要通过父组件来做间接传值，在这种情况下推荐使用vuex 中央事件总线 具体例子请看官方文档 2.vue-router原理说简单点，vue-router的原理就是通过对URL地址变化的监听，继而对不同的组件进行渲染。每当URL地址改变时，就对相应的组件进行渲染。原理是很简单，实现方式可能有点复杂，主要有hash模式和history模式。 3.构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？12345671、vue.js：vue-cli工程的核心，主要特点是 双向数据绑定 和 组件系统。2、vue-router：vue官方推荐使用的路由框架。3、vuex：专为 Vue.js 应用项目开发的状态管理器，主要用于维护vue组件间共用的一些 变量 和 方法。4、axios（ 或者 fetch 、ajax ）：用于发起 GET 、或 POST 等 http请求，基于 Promise 设计。5、vux等：一个专为vue设计的移动端UI组件库。6、创建一个emit.js文件，用于vue事件机制的管理。7、webpack：模块加载和vue-cli工程打包器。 4.vue-cli 工程常用的 npm 命令有哪些？1234npm install npm run dev npm run build npm run build --report 用于查看 vue-cli 生产环境部署资源文件大小 5.请说出vue-cli工程中每个文件夹和文件的用处 6.vue.confog.js 的对于工程 开发环境 和 生产环境 的配置1234567891011121314151617configureWebpack: config =&gt; &#123; if (debug) &#123; // 开发环境配置 // sourcemap 参考：https://www.cnblogs.com/hhhyaaon/p/5657469.html config.devtool = &apos;#cheap-module-eval-source-map&apos; &#125; else &#123; // 生产环境配置 &#125; Object.assign(config, &#123; // 开发生产共同配置 resolve: &#123; alias: &#123; &apos;@&apos;: path.resolve(__dirname, &apos;./src&apos;), &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos; &#125; &#125; &#125;)&#125;, 7.请你详细介绍一些 package.json 里面的配置1234567891011121314151617181920212223242526272829303132333435363738394041&#123; &quot;name&quot;: &quot;cli-study&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;scripts&quot;: &#123; &quot;serve&quot;: &quot;vue-cli-service serve&quot;, &quot;build&quot;: &quot;vue-cli-service build&quot;, &quot;lint&quot;: &quot;vue-cli-service lint&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.21&quot;, &quot;vue-router&quot;: &quot;^3.0.1&quot;, &quot;vuex&quot;: &quot;^3.0.1&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vue/cli-plugin-babel&quot;: &quot;^3.3.0&quot;, &quot;@vue/cli-plugin-eslint&quot;: &quot;^3.3.0&quot;, &quot;@vue/cli-service&quot;: &quot;^3.3.0&quot;, &quot;@vue/eslint-config-prettier&quot;: &quot;^4.0.1&quot;, &quot;babel-eslint&quot;: &quot;^10.0.1&quot;, &quot;eslint&quot;: &quot;^5.8.0&quot;, &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;, &quot;less&quot;: &quot;^3.0.4&quot;, &quot;less-loader&quot;: &quot;^4.1.0&quot;, &quot;lint-staged&quot;: &quot;^8.1.0&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.21&quot; &#125;, &quot;gitHooks&quot;: &#123; &quot;pre-commit&quot;: &quot;lint-staged&quot; &#125;, &quot;lint-staged&quot;: &#123; &quot;*.js&quot;: [ &quot;vue-cli-service lint&quot;, &quot;git add&quot; ], &quot;*.vue&quot;: [ &quot;vue-cli-service lint&quot;, &quot;git add&quot; ] &#125;&#125; 常用对象解析： scripts：npm run xxx 命令调用node执行的 .js 文件 dependencies：生产环境依赖包的名称和版本号，即这些 依赖包 都会打包进 生产环境的JS文件里面 devDependencies：开发环境依赖包的名称和版本号，即这些 依赖包 只用于 代码开发 的时候，不会打包进 生产环境js文件 里面 8.vue.js的核心1、数据驱动，也叫双向数据绑定。 Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。 2、组件系统。 .vue组件的核心选项: 1、模板（template）：模板声明了数据和最终展现给用户的DOM之间的映射关系。2、初始数据（data）：一个组件的初始数据状态。对于可复用的组件来说，这通常是私有的状态。3、接受的外部参数(props)：组件之间通过参数来进行数据的传递和共享。4、方法（methods）：对数据的改动操作一般都在组件的方法内进行。5、生命周期钩子函数（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，最新2.0版本对于生命周期函数名称改动很大。6、私有资源（assets）：Vue.js当中将用户自定义的指令、过滤器、组件等统称为资源。一个组件可以声明自己的私有资源。私有资源只有该组件和它的子组件可以调用。等等。 3、vuex。 9.对于 Vue 是一套 构建用户界面 的 渐进式框架 的理解渐进式代表的含义是：没有多做职责之外的事。 vue.js只提供了 vue-cli 生态中最核心的 组件系统 和 双向数据绑定。 像vuex、vue-router都属于围绕 vue.js开发的库。 比如说，你要使用Angular，必须接受以下东西： 必须使用它的模块机制 必须使用它的依赖注入- 必须使用它的特殊形式定义组件（这一点每个视图框架都有，难以避免） 所以Angular是带有比较强的排它性的，如果你的应用不是从头开始，而是要不断考虑是否跟其他东西集成，这些主张会带来一些困扰。 比如说，你要使用React，你必须理解： 函数式编程的理念， 需要知道什么是副作用， 什么是纯函数， 如何隔离副作用 它的侵入性看似没有Angular那么强，主要因为它是软性侵入。 Vue与React、Angular的不同是，但它是渐进的： 你可以在原有大系统的上面，把一两个组件改用它实现，当jQuery用； 也可以整个用它全家桶开发，当Angular用； 还可以用它的视图，搭配你自己设计的整个下层用。 你可以在底层数据逻辑的地方用OO和设计模式的那套理念， 也可以函数式，都可以，它只是个轻量视图而已，只做了最核心的东西。 10.请说出vue几种常用的指令 v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。 v-show：根据表达式之真假值，切换元素的 display CSS 属性。 v-for：循环指令，基于一个数组或者对象渲染一个列表，vue 2.0以上必须需配合 key值 使用。 v-bind：动态地绑定一个或多个特性，或一个组件 prop 到表达式。 v-on：用于监听指定元素的DOM事件，比如点击事件。绑定事件监听器。 v-model：实现表单输入和应用状态之间的双向绑定 v-pre：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。 v-once：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。 11.请问 v-if 和 v-show 有什么区别共同点： v-if 和 v-show 都是动态显示DOM元素。 区别： 1、编译过程： v-if 是 真正 的 条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性display。 2、编译条件： v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做。直到条件第一次变为真时，才会开始渲染条件块。v-show不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 3、性能消耗： v-if有更高的切换消耗。v-show有更高的初始渲染消耗。 4、应用场景： v-if适合运行时条件很少改变时使用。v-show适合频繁切换。 12.vue常用的修饰符v-on 指令常用修饰符： .stop - 调用 event.stopPropagation()，禁止事件冒泡。 .prevent - 调用 event.preventDefault()，阻止事件默认行为。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 123456789注意： 如果是在自己封装的组件或者是使用一些第三方的UI库时，会发现并不起效果，这时就需要用`·.native修饰符了，如：//使用示例：&lt;el-input v-model=&quot;inputName&quot; placeholder=&quot;搜索你的文件&quot; @keyup.enter.native=&quot;searchFile(params)&quot; &gt;&lt;/el-input&gt; v-bind 指令常用修饰符： .prop - 被用于绑定 DOM 属性 (property)。(差别在哪里？) .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持) .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。 v-model 指令常用修饰符： .lazy - 取代 input 监听 change 事件 .number - 输入字符串转为数字 .trim - 输入首尾空格过滤 13.v-on可以监听多个方法吗？v-on可以监听多个方法，例如： 1&lt;input type=&quot;text&quot; :value=&quot;name&quot; @input=&quot;onInput&quot; @focus=&quot;onFocus&quot; @blur=&quot;onBlur&quot; /&gt; 但是同一种事件类型的方法，只会响应第一个，例如： 1&lt;a href=&quot;javascript:;&quot; @click=&quot;methodsOne&quot; @click=&quot;methodsTwo&quot;&gt;&lt;/a&gt; 只会响应methodsOne方法。 14.vue中 key 值的作用key值：用于 管理可复用的元素。因为Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做使 Vue 变得非常快，但是这样也不总是符合实际需求。 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 15.vue事件中如何使用event对象注意在事件中要使用 $ 符号 1234567891011//html部分&lt;a href=&quot;javascript:void(0);&quot; data-id=&quot;12&quot; @click=&quot;showEvent($event)&quot;&gt;event&lt;/a&gt;//js部分showEvent(event)&#123; //获取自定义data-id console.log(event.target.dataset.id) //阻止事件冒泡 event.stopPropagation(); //阻止默认 event.preventDefault()&#125; 16.什么是$nextTick因为Vue的异步更新队列，$nextTick是用来知道什么时候DOM更新完成的。 17.Vue 组件中 data 为什么必须是函数1234567891011//为什么data函数里面要return一个对象&lt;script&gt; export default &#123; data() &#123; return &#123; // 返回一个唯一的对象，不要和其他组件共用一个对象进行返回 menu: MENU.data, poi: POILIST.data &#125; &#125; &#125;&lt;/script&gt; 因为一个组件是可以共享的，但他们的data是私有的，所以每个组件都要return一个新的data对象，返回一个唯一的对象，不要和其他组件共用一个对象。 18.v-for 与 v-if 的优先级当它们处于同一节点，v-for的优先级比v-if更高，这意味着 v-if将分别重复运行于每个 v-for循环中。 19.vue中子组件调用父组件的方法通过v-on 监听 和$emit触发来实现： 1、在父组件中 通过v-on 监听 当前实例上的 自定义事件。 2、在子组件 中 通过&#39;$emit&#39;触发 当前实例上的 自定义事件。 示例： 父组件： 1234567891011121314151617181920212223&lt;template&gt; &lt;div class=&quot;fatherPageWrap&quot;&gt; &lt;h1&gt;这是父组件&lt;/h1&gt; &lt;!-- 引入子组件，v-on监听自定义事件 --&gt; &lt;emitChild v-on:emitMethods=&quot;fatherMethod&quot;&gt;&lt;/emitChild&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; import emitChild from &apos;@/page/children/emitChild.vue&apos;; export default&#123; data () &#123; return &#123;&#125; &#125;, components : &#123; emitChild &#125;, methods : &#123; fatherMethod(params)&#123; alert(JSON.stringify(params)); &#125; &#125; &#125;&lt;/script&gt; 子组件： 12345678910111213141516&lt;template&gt; &lt;div class=&quot;childPageWrap&quot;&gt; &lt;h1&gt;这是子组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default&#123; data () &#123; return &#123;&#125; &#125;, mounted () &#123; //通过 emit 触发 this.$emit(&apos;emitMethods&apos;,&#123;&quot;name&quot; : 123&#125;); &#125; &#125;&lt;/script&gt; 结果： 子组件 会调用 父组件的fatherMethod 方法，该并且会alert 传递过去的参数：{&quot;name&quot;:123} 20.vue中 keep-alive 组件的作用keep-alive：主要用于保留组件状态或避免重新渲染。 属性： include:字符串或正则表达式。只有匹配的组件会被缓存。 exclude：字符串或正则表达式。任何匹配的组件都不会被缓存。 21.vue中如何编写可复用的组件在编写组件的时候，时刻考虑组件是否可复用是有好处的。一次性组件跟其他组件紧密耦合没关系，但是可复用组件一定要定义一个清晰的公开接口。 Vue.js组件 API 来自 三部分：prop、事件、slot： prop 允许外部环境传递数据给组件，在vue-cli工程中也可以使用vuex等传递数据。 事件允许组件触发外部环境的 action slot 允许外部环境将内容插入到组件的视图结构内。 代码示例： 12345678910&lt;my-component :foo=&quot;bar&quot; :bar=&quot;qux&quot; //子组件调用父组件方法 @event-a=&quot;doThis&quot; @event-b=&quot;doThat&quot;&gt; &lt;!-- content --&gt;&lt;img slot=&quot;icon&quot; src=&quot;...&quot; /&gt;&lt;p slot=&quot;main-text&quot;&gt;Hello!&lt;/p&gt;&lt;/my-component&gt; 22.什么是vue生命周期和生命周期钩子函数vue 的生命周期是： vue 实例从创建到销毁，也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程。 在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 23.vue生命周期钩子函数有哪些 生命周期钩子函数（11个） 类型 详细 beforeCreate Function 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created Function 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)， 属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount Function 在挂载开始之前被调用：相关的 render 函数首次被调用。 mounted Function el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 beforeUpdate Function 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 updated Function 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 activated Function keep-alive 组件激活时调用。该钩子在服务器端渲染期间不被调用。 deactivated Function keep-alive 组件停用时调用。该钩子在服务器端渲染期间不被调用。 beforeDestroy Function 实例销毁之前调用。在这一步，实例仍然完全可用。该钩子在服务器端渲染期间不被调用。 destroyed Function Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 errorCaptured（2.5.0+ 新增） (err: Error, vm: Component, info: string) =&gt; ?boolean 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 注意： 1、mounted、updated不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用vm.$nextTick替换掉mounted、updated： 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been re-rendered &#125;)&#125; 2、http请求建议在 created 生命周期内发出vue生命周期图示： 24.vue如何监听键盘事件中的按键按键修饰符: 在监听键盘事件时，我们经常需要检查常见的键值。Vue允许为 v-on在监听键盘事件时添加按键修饰符： 123&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 可以通过全局 config.keyCodes 对象自定义按键修饰符别名： 12// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 系统修饰键： 2.1.0 新增 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符 2.5.0 新增 .exact修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 鼠标按钮修饰符： 2.2.0 新增 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 25.vue更新数组时触发视图更新的方法Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse() 26.vue中对象更改检测的注意事项由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value)方法向嵌套对象添加响应式属性。例如，对于： 1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: &apos;Anika&apos; &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile对象： 1Vue.set(vm.userProfile, &apos;age&apos;, 27) 你还可以使用 vm.$set实例方法，它只是全局Vue.set 的别名： 1vm.$set(vm.userProfile, &apos;age&apos;, 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign()或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样： 1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 应该这样做： 1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: &apos;Vue Green&apos;&#125;) 27.如何解决非工程化项目，网速慢时初始化页面闪动问题？使用v-cloak指令，v-cloak不需要表达式，它会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:none配合使用。 1234567891011&lt;div id=&quot;app&quot; v-cloak&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;script&gt;var app = new Vue(&#123; el:&quot;#app&quot;, data:&#123; message:&quot;这是一段文本&quot; &#125;&#125;)&lt;/script&gt; 这时虽然已经加了指令v-cloak，但其实并没有起到任何作用，当网速较慢、Vue.js 文件还没加载完时，在页面上会显示的字样，直到Vue创建实例、编译模版时，DOM才会被替换，所以这个过程屏幕是有闪动的。只要加一句CSS就可以解决这个问题了： 123[v-cloak]&#123; display:none;&#125; 在一般情况下，v-cloak是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用。 28.v-for产生的列表，如何实现active样式的切换？通过设置当前 currentIndex 实现： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;toggleClassWrap&quot;&gt; &lt;ul&gt; &lt;li @click=&quot;currentIndex = index&quot; v-bind:class=&quot;&#123;clicked: index === currentIndex&#125;&quot; v-for=&quot;(item, index) in desc&quot; :key=&quot;index&quot;&gt; &lt;a href=&quot;javascript:;&quot;&gt;&#123;&#123;item.ctrlValue&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default&#123; data () &#123; return &#123; desc:[&#123; ctrlValue:&quot;test1&quot; &#125;,&#123; ctrlValue:&quot;test2&quot; &#125;,&#123; ctrlValue:&quot;test3&quot; &#125;,&#123; ctrlValue:&quot;test4&quot; &#125;], currentIndex:0 &#125; &#125; &#125;&lt;/script&gt;&lt;style type=&quot;text/css&quot; lang=&quot;less&quot;&gt;.toggleClassWrap&#123; .clicked&#123; color:red; &#125;&#125;&lt;/style&gt; 29.vue-cli工作中如何自定义一个过滤器？私有过滤器 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;曾经，我也是一个单纯的少年，单纯的我，傻傻的问，谁是世界上最单纯的男人&apos; &#125;, methods: &#123;&#125;, filters: &#123; // 过滤器的三个参数：1.要过滤的文本 2.过滤的内容 3.替换的内容 // 过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 msgFormat: function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/少年/g, arg + arg2) &#125; &#125;, &#125;);&lt;/script&gt; 全局过滤器 12345// 定义一个 Vue 全局的过滤器，名字叫做 msgFormat Vue.filter(&apos;msgFormat&apos;, function (msg, arg, arg2) &#123; // 字符串的 replace 方法，第一个参数，除了可写一个 字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, arg + arg2) &#125;) 使用过滤器 1&lt;p&gt;&#123;&#123; msg | msgFormat(&apos;疯狂+1&apos;, &apos;123&apos;) | test &#125;&#125;&lt;/p&gt; 30.vue-cli工作中常用的过滤器常用的过滤器，filter/filter.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236//去除空格 type 1-所有空格 2-前后空格 3-前空格 4-后空格function trim(value, trim) &#123; switch (trim) &#123; case 1: return value.replace(/\\s+/g, &quot;&quot;); case 2: return value.replace(/(^\\s*)|(\\s*$)/g, &quot;&quot;); case 3: return value.replace(/(^\\s*)/g, &quot;&quot;); case 4: return value.replace(/(\\s*$)/g, &quot;&quot;); default: return value; &#125;&#125;//任意格式日期处理//使用格式：// &#123;&#123; &apos;2018-09-14 01:05&apos; | formaDate(yyyy-MM-dd hh:mm:ss) &#125;&#125; // &#123;&#123; &apos;2018-09-14 01:05&apos; | formaDate(yyyy-MM-dd) &#125;&#125; // &#123;&#123; &apos;2018-09-14 01:05&apos; | formaDate(MM/dd) &#125;&#125; 等function formaDate(value, fmt) &#123; var date = new Date(value); var o = &#123; &quot;M+&quot;: date.getMonth() + 1, //月份 &quot;d+&quot;: date.getDate(), //日 &quot;h+&quot;: date.getHours(), //小时 &quot;m+&quot;: date.getMinutes(), //分 &quot;s+&quot;: date.getSeconds(), //秒 &quot;w+&quot;: date.getDay(), //星期 &quot;q+&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 &quot;S&quot;: date.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &quot;&quot;).substr(4 - RegExp.$1.length)); for (var k in o) &#123; if(k === &apos;w+&apos;) &#123; if(o[k] === 0) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周日&apos;); &#125;else if(o[k] === 1) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周一&apos;); &#125;else if(o[k] === 2) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周二&apos;); &#125;else if(o[k] === 3) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周三&apos;); &#125;else if(o[k] === 4) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周四&apos;); &#125;else if(o[k] === 5) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周五&apos;); &#125;else if(o[k] === 6) &#123; fmt = fmt.replace(&apos;w&apos;, &apos;周六&apos;); &#125; &#125;else if (new RegExp(&quot;(&quot; + k + &quot;)&quot;).test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : ((&quot;00&quot; + o[k]).substr((&quot;&quot; + o[k]).length))); &#125; &#125; return fmt; &#125;//字母大小写切换/*type 1:首字母大写 2：首页母小写 3：大小写转换 4：全部大写 5：全部小写 * */function changeCase(str, type) &#123; function ToggleCase(str) &#123; var itemText = &quot;&quot; str.split(&quot;&quot;).forEach( function (item) &#123; if (/^([a-z]+)/.test(item)) &#123; itemText += item.toUpperCase(); &#125; else if (/^([A-Z]+)/.test(item)) &#123; itemText += item.toLowerCase(); &#125; else &#123; itemText += item; &#125; &#125;); return itemText; &#125; switch (type) &#123; case 1: return str.replace(/\\b\\w+\\b/g, function (word) &#123; return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); &#125;); case 2: return str.replace(/\\b\\w+\\b/g, function (word) &#123; return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); &#125;); case 3: return ToggleCase(str); case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125;//字符串循环复制,count-&gt;次数function repeatStr(str, count) &#123; var text = &apos;&apos;; for (var i = 0; i &lt; count; i++) &#123; text += str; &#125; return text;&#125;//字符串替换function replaceAll(str, AFindText, ARepText) &#123; raRegExp = new RegExp(AFindText, &quot;g&quot;); return str.replace(raRegExp, ARepText);&#125;//字符替换*，隐藏手机号或者身份证号等//replaceStr(字符串,字符格式, 替换方式,替换的字符（默认*）)//ecDo.replaceStr(&apos;18819322663&apos;,[3,5,3],0)//result：188*****663//ecDo.replaceStr(&apos;asdasdasdaa&apos;,[3,5,3],1)//result：***asdas***//ecDo.replaceStr(&apos;1asd88465asdwqe3&apos;,[5],0)//result：*****8465asdwqe3//ecDo.replaceStr(&apos;1asd88465asdwqe3&apos;,[5],1,&apos;+&apos;)//result：&quot;1asd88465as+++++&quot;function replaceStr(str, regArr, type, ARepText) &#123; var regtext = &apos;&apos;, Reg = null, replaceText = ARepText || &apos;*&apos;; //repeatStr是在上面定义过的（字符串循环复制），大家注意哦 if (regArr.length === 3 &amp;&amp; type === 0) &#123; regtext = &apos;(\\\\w&#123;&apos; + regArr[0] + &apos;&#125;)\\\\w&#123;&apos; + regArr[1] + &apos;&#125;(\\\\w&#123;&apos; + regArr[2] + &apos;&#125;)&apos; Reg = new RegExp(regtext); var replaceCount = this.repeatStr(replaceText, regArr[1]); return str.replace(Reg, &apos;$1&apos; + replaceCount + &apos;$2&apos;) &#125; else if (regArr.length === 3 &amp;&amp; type === 1) &#123; regtext = &apos;\\\\w&#123;&apos; + regArr[0] + &apos;&#125;(\\\\w&#123;&apos; + regArr[1] + &apos;&#125;)\\\\w&#123;&apos; + regArr[2] + &apos;&#125;&apos; Reg = new RegExp(regtext); var replaceCount1 = this.repeatStr(replaceText, regArr[0]); var replaceCount2 = this.repeatStr(replaceText, regArr[2]); return str.replace(Reg, replaceCount1 + &apos;$1&apos; + replaceCount2) &#125; else if (regArr.length === 1 &amp;&amp; type === 0) &#123; regtext = &apos;(^\\\\w&#123;&apos; + regArr[0] + &apos;&#125;)&apos; Reg = new RegExp(regtext); var replaceCount = this.repeatStr(replaceText, regArr[0]); return str.replace(Reg, replaceCount) &#125; else if (regArr.length === 1 &amp;&amp; type === 1) &#123; regtext = &apos;(\\\\w&#123;&apos; + regArr[0] + &apos;&#125;$)&apos; Reg = new RegExp(regtext); var replaceCount = this.repeatStr(replaceText, regArr[0]); return str.replace(Reg, replaceCount) &#125;&#125;//格式化处理字符串//ecDo.formatText(&apos;1234asda567asd890&apos;)//result：&quot;12,34a,sda,567,asd,890&quot;//ecDo.formatText(&apos;1234asda567asd890&apos;,4,&apos; &apos;)//result：&quot;1 234a sda5 67as d890&quot;//ecDo.formatText(&apos;1234asda567asd890&apos;,4,&apos;-&apos;)//result：&quot;1-234a-sda5-67as-d890&quot;function formatText(str, size, delimiter) &#123; var _size = size || 3, _delimiter = delimiter || &apos;,&apos;; var regText = &apos;\\\\B(?=(\\\\w&#123;&apos; + _size + &apos;&#125;)+(?!\\\\w))&apos;; var reg = new RegExp(regText, &apos;g&apos;); return str.replace(reg, _delimiter);&#125;//现金额大写转换函数//ecDo.upDigit(168752632)//result：&quot;人民币壹亿陆仟捌佰柒拾伍万贰仟陆佰叁拾贰元整&quot;//ecDo.upDigit(1682)//result：&quot;人民币壹仟陆佰捌拾贰元整&quot;//ecDo.upDigit(-1693)//result：&quot;欠人民币壹仟陆佰玖拾叁元整&quot;function upDigit(n) &#123; var fraction = [&apos;角&apos;, &apos;分&apos;, &apos;厘&apos;]; var digit = [&apos;零&apos;, &apos;壹&apos;, &apos;贰&apos;, &apos;叁&apos;, &apos;肆&apos;, &apos;伍&apos;, &apos;陆&apos;, &apos;柒&apos;, &apos;捌&apos;, &apos;玖&apos;]; var unit = [ [&apos;元&apos;, &apos;万&apos;, &apos;亿&apos;], [&apos;&apos;, &apos;拾&apos;, &apos;佰&apos;, &apos;仟&apos;] ]; var head = n &lt; 0 ? &apos;欠人民币&apos; : &apos;人民币&apos;; n = Math.abs(n); var s = &apos;&apos;; for (var i = 0; i &lt; fraction.length; i++) &#123; s += (digit[Math.floor(n * 10 * Math.pow(10, i)) % 10] + fraction[i]).replace(/零./, &apos;&apos;); &#125; s = s || &apos;整&apos;; n = Math.floor(n); for (var i = 0; i &lt; unit[0].length &amp;&amp; n &gt; 0; i++) &#123; var p = &apos;&apos;; for (var j = 0; j &lt; unit[1].length &amp;&amp; n &gt; 0; j++) &#123; p = digit[n % 10] + unit[1][j] + p; n = Math.floor(n / 10); &#125; s = p.replace(/(零.)*零$/, &apos;&apos;).replace(/^$/, &apos;零&apos;) + unit[0][i] + s; //s = p + unit[0][i] + s; &#125; return head + s.replace(/(零.)*零元/, &apos;元&apos;).replace(/(零.)+/g, &apos;零&apos;).replace(/^整$/, &apos;零元整&apos;);&#125; //保留2位小数function toDecimal2(x)&#123; var f = parseFloat(x); if (isNaN(f)) &#123; return false; &#125; var f = Math.round(x * 100) / 100; var s = f.toString(); var rs = s.indexOf(&apos;.&apos;); if (rs &lt; 0) &#123; rs = s.length; s += &apos;.&apos;; &#125; while (s.length &lt;= rs + 2) &#123; s += &apos;0&apos;; &#125; return s;&#125;export&#123; trim, changeCase, repeatStr, replaceAll, replaceStr, checkPwd, formatText, upDigit, toDecimal2, formaDate&#125; 31.vue等单页面应用及其优缺点单页Web应用（single page web application，SPA）： 就是只有一张Web页面的应用。单页应用程序 (SPA) 是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。因此，对单页应用来说模块化的开发和设计显得相当重要。 单页Web应用的优点： 1、提供了更加吸引人的用户体验：具有桌面应用的即时性、网站的可移植性和可访问性。 2、单页应用的内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。 3、单页应用没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象 4、单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。 5、良好的前后端分离。后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。 单页Web应用的缺点： 1、首次加载耗时比较多。 2、SEO问题，不利于百度，360等搜索引擎收录。 3、容易造成Css命名冲突。 4、前进、后退、地址栏、书签等，都需要程序进行管理，页面的复杂度很高，需要一定的技能水平和开发成本高。 32.什么是vue的计算属性？计算属性：对于任何复杂的计算逻辑，当前属性值是根据其他属性计算出来的，都应当使用计算属性。 例子： 1234&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt; 12345678910111213var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 33.vue-cli提供的几种脚手架模板在使用之前，可以先用 vue-list命令查询可用的模板。 详解： vue-cli提供了的常用的脚手架模板： webpack：基于 webpack 和 vue-loader 的目录结构，而且支持热部署、代码检查、测试及 css 抽取。 webpack-simple：基于 webpack 和 vue-loader 的目录结构。 browerify：基于 Browerfiy 和 vueify(作用于 vue-loader 类似)的结构，支持热部署、代码检查及单元测试。 browerify-simple：基于 Browerfiy 和 vueify 的结构。 simple：单个引入 Vue.js 的 index.html 页面。 这里我们主要会使用 webpack 作为常用脚手架，可以运行vue init webpack my-project 来生成项目。 34.vue父组件如何向子组件中传递数据通过 v-bind 向子组件传递数据： 12345&lt;!-- 动态赋予一个变量的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title&quot;&gt;&lt;/blog-post&gt;&lt;!-- 动态赋予一个复杂表达式的值 --&gt;&lt;blog-post v-bind:title=&quot;post.title + &apos; by &apos; + post.author.name&quot;&gt;&lt;/blog-post&gt; 在上述两个示例中，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 prop。 子组件接受： 123456789101112export default &#123; props : [&quot;title&quot;] &#125; //或者 export default &#123; props : &#123; title:&#123; type:string, default:&quot;&quot; &#125; &#125; &#125; 34.如何在组件中使用全局常量第一步，在 src 下新建 const 文件夹下 新建 const.js 1234567.├── src│ ├── const│ │ ├── const.js│ │ │ └── main.js└── ... 第二步，如何在 const.js 文件下，设置常量 123456789export default &#123; install(Vue,options)&#123; Vue.prototype.global = &#123; title:&apos;全局&apos;, isBack: true, isAdd: false, &#125;; &#125; &#125; 第三步，在 main.js 下全局引入： 123//引入全局常量import constant from &apos;./const/const.js&apos;Vue.use(constant); 第四步，即可在 .vue 组件中使用： 1234//通过js方式使用：this.global.title//或在 html 结构中使用&#123;&#123;global.title&#125;&#125; 35.vue如何禁止弹窗后面的滚动条滚动1234567891011121314methods : &#123; //禁止滚动 stop()&#123; var mo=function(e)&#123;e.preventDefault();&#125;; document.body.style.overflow=&apos;hidden&apos;; document.addEventListener(&quot;touchmove&quot;,mo,false);//禁止页面滑动 &#125;, /***取消滑动限制***/ move()&#123; var mo=function(e)&#123;e.preventDefault();&#125;; document.body.style.overflow=&apos;&apos;;//出现滚动条 document.removeEventListener(&quot;touchmove&quot;,mo,false); &#125;&#125; 36.请说出计算属性的缓存和方法调用的有什么区别？ 计算属性必须返回结果 计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值。 使用计算属性还是methods取决于是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存。 计算属性是根据依赖自动执行的，methods需要事件调用。 37.什么是vue.js中的自定义指令 自定义一些指令对底层DOM进行操作 更多参考 Vue里面有许多内置的指令，比如v-if和v-show，这些丰富的指令能满足我们的绝大部分业务需求，不过在需要一些特殊功能时，我们仍然希望对DOM进行底层的操作，这时就要用到自定义指令。 123456789101112131415Vue.directive(&apos;focus&apos;, &#123; bind: function (el) &#123; // 每当指令绑定到元素上的时候，会立即执行这个bind 函数，只执行一次 // 注意： 在每个函数中，第一个参数永远是el，表示被绑定了指令的那个元素，这个el参数，是一个原生的JS对象 // 在元素刚绑定了指令的时候还没有插入到DOM中去的时候调用focus方法没有作用。因为，一个元素只有插入DOM之后才能获取焦点 // el.focus() &#125;, inserted: function (el) &#123; // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】。和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 el.focus() &#125;, updated: function (el) &#123; // 当VNode更新的时候，会执行 updated， 可能会触发多次 &#125;&#125;) 38.自定义指令的几个钩子函数 bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 。 componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 39.自定义指令钩子函数参数 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM 。 binding：一个对象，包含以下属性： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为2。 oldValue：指令绑定的前一个值，仅在update和 componentUpdated钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo中，参数为 “foo”。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为{ foo: true, bar: true }。 vnode：Vue 编译生成的虚拟节点。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 40.vue-router如何响应 路由参数 的变化 问题：当使用路由参数时，例如从 /content?id=1 到 content?id=2，此时原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用，此时vue应该如何响应路由参数 的变化？ 参考答案： 本题是对侦听器 watch的考察。 复用组件时，想对路由参数的变化作出响应的话， 可以watch (监测变化) $route 对象： 12345678const User = &#123; template: &apos;...&apos;, watch: &#123; &apos;$route&apos; (to, from) &#123; // 对路由变化作出响应... &#125; &#125;&#125; 41.完整的 vue-router 导航解析流程1、导航被触发。 2、在失活的组件里调用离开守卫。 3、调用全局的 beforeEach 守卫。 4、在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。 5、在路由配置里调用 beforeEnter。 6、解析异步路由组件。 7、在被激活的组件里调用 beforeRouteEnter。 8、调用全局的 beforeResole 守卫 (2.5+)。 9、导航被确认。 10、调用全局的 afterEach 钩子。 11、触发 DOM 更新。 12、用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 42.vue-router有哪几种导航钩子（ 导航守卫 ）？1、全局守卫： router.beforeEach 2、全局解析守卫： router.beforeResolve 3、全局后置钩子： router.afterEach 4、路由独享的守卫： beforeEnter 5、组件内的守卫： beforeRouteEnter、beforeRouteUpdate (2.2 新增)、beforeRouteLeave 43.vue-router的几种实例方法以及参数传递实例方法： 实例方法 说明 this.$router.push(location, onComplete?, onAbort?) 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。并且点击 &lt;router-link :to=&quot;...&quot;&gt;等同于调用 router.push(...)。 this.$router.replace(location, onComplete?, onAbort?) 这个方法不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录，所以，当用户点击浏览器后退按钮时，并不会回到之前的 URL。 this.$router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 参数传递方式： vue-router提供了params、query、meta三种页面间传递参数的方式。 示例： 12345678910111213141516171819202122232425262728// 字符串，不带参数this.$router.push(&apos;home&apos;)// 对象，不带参数this.$router.push(&#123; path: &apos;home&apos; &#125;)// params（推荐）：命名的路由，params 必须和 name 搭配使用this.$router.push(&#123; name:&apos;user&apos;,params: &#123; userId: 123 &#125;&#125;)// 这里的 params 不生效this.$router.push(&#123; path:&apos;/user&apos;,params: &#123; userId: 123 &#125;&#125;)// query：带查询参数，变成 /register?plan=privatethis.$router.push(&#123; path: &apos;register&apos;, query: &#123; plan: &apos;private&apos; &#125;&#125;)//meta方式：路由元信息export default new Router(&#123; routes: [ &#123; path: &apos;/user&apos;, name: &apos;user&apos;, component: user, meta:&#123; title:&apos;个人中心&apos; &#125; &#125; ]&#125;) 在组件中使用： 1234//通过 $route 对象获取，注意是route，么有rthis.$route.paramsthis.$route.querythis.$route.meta 44.$route 和 $router 的区别$route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。$router是“路由实例”对象包括了路由的跳转方法，钩子函数等。 45.vue-router的动态路由匹配以及使用动态路径匹配：\b即把某种模式匹配到的所有路由，全都映射到同个组件。使用动态路由参数来实现。 12345678910const User = &#123; template: &apos;&lt;div&gt;User&lt;/div&gt;&apos;&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数 以冒号开头 &#123; path: &apos;/user/:id&apos;, component: User &#125; ]&#125;) 这样，像/user/foo和/user/bar都将映射到相同的路由。 12345//一个“路径参数”使用冒号 :标记。当匹配到一个路由时，参数值会被设置到 this.$route.params，可以在每个组件内使用。const User = &#123; template: &apos;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&apos;&#125; 46.vue-router如何定义嵌套路由嵌套路由:是路由的多层嵌套。 第一步：需要在一个被渲染的组件中嵌套 &lt;router-view&gt;组件。例如，在 User 组件的模板添加一个 &lt;router-view&gt;： 12345678const User = &#123; template: ` &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;User&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125; 第二步：在嵌套的出口中渲染组件，在VueRouter 的参数中使用children配置： 12345678910111213141516171819202122const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/user/:id&apos;, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;profile&apos;, component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: &apos;posts&apos;, component: UserPosts &#125; ] &#125; ]&#125;) 47.&lt;router-link&gt;&lt;/router-link&gt;组件及其属性&lt;router-link&gt; 组件:用于支持用户在具有路由功能的应用中 (点击) 导航。 可以通过to 属性指定目标地址，默认渲染成带有正确链接的 &lt;a&gt; 标签，可以通过配置 tag 属性生成别的标签.。 另外，当目标路由成功激活时，链接元素自动设置一个表示激活的 CSS 类名。 常用属性： \b属性 类型 说明 示例 to string \\ Location 表示目标路由的链接。当被点击后，内部会立刻把to的值传到router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 &lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt; replace boolean（默认flase） 设置replace属性的话，当点击时，会调用 router.replace()而不是 router.push()，于是导航后不会留下 history 记录。 &lt;router-link :to=&quot;{ path: &#39;/abc&#39;}&quot; replace&gt;&lt;/router-link&gt; append boolean（默认flase） 设置append属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 /a导航到一个相对路径 b，如果没有配置 append，则路径为/b，如果配了，则为/a/b &lt;router-link :to=&quot;{ path: &#39;relative/path&#39;}&quot; append&gt;&lt;/router-link&gt; tag string（默认 ‘a’） 有时候想要 渲染成某种标签，例如 &lt;li&gt;于是我们使用tagprop 类指定何种标签，同样它还是会监听点击，触发导航。 &lt;router-link to=&quot;/foo&quot; tag=&quot;li&quot;&gt;foo&lt;/router-link&gt; active-class string（默认 “router-link-active”） 设置 链接激活时使用的CSS 类名。默认值可以通过路由的构造选项linkActiveClass来全局配置。 exact boolean（默认 false） “是否激活” 默认类名的依据是 inclusive match (全包含匹配)。 举个例子，如果当前的路径是 /a 开头的，那么 也会被设置 CSS 类名。 这个链接只会在地址为 / 的时候被激活： &lt;router-link to=&quot;/&quot; exact&gt; event string \\ Array （默认 ‘click’） 声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。 exact-active-class string 默认 ‘router-link-exact-active’ 配置当链接被精确匹配的时候应该激活的 class。注意默认值也是可以通过路由构造函数选项linkExactActiveClass进行全局配置的。 48.vue-router实现动态加载路由组件（ 懒加载 ）当打包构建应用时，Javascript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。 第一步：定义一个能够被 Webpack 自动代码分割的异步组件。 12//在src/router/index.js里面引入异步引入组件const index = () =&gt; import(&apos;../page/list/index.vue&apos;); 第二步：在路由配置中什么都不需要改变，只需要像往常一样使用 index。 12345const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/index&apos;, component: index,name:&quot;index&quot; &#125; ]&#125;) 第三步：在build/webpack.base.conf.js下的output属性，新增chunkFilename。 123456789output: &#123; path: config.build.assetsRoot, filename: &apos;[name].js&apos;, //新增chunFilename属性 chunkFilename: &apos;[name].js&apos;, publicPath: process.env.NODE_ENV === &apos;production&apos; ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, 49.vue-router路由的两种模式vue-router路由提供了两种路由模式：hash模式和history模式。 hash模式： vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。 history模式： 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 12345//设置mode属性，设置路由模式const router = new VueRouter(&#123; mode: &apos;history&apos;, routes: [...]&#125;) 不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 50.什么是vuex？ 回答：Vuex 是一个专为 Vue.js 应用程序开发的状态管理器，采用 集中式存储 管理应用的所有组件的状态。 vuex的原理其实非常简单，它为什么能实现所有的组件共享同一份数据？因为vuex生成了一个store实例，并且把这个实例挂在了所有的组件上，所有的组件引用的都是同一个store实例。store实例上有数据，有方法，方法改变的都是store实例上的数据。由于其他组件引用的是同样的实例，所以一个组件改变了store上的数据，导致另一个组件上的数据也会改变，就像是一个对象的引用。如果对vuex的实现有兴趣，可以看看我自己造的一个vue轮子对应的vuex插件。它实现了除vuex模块外的所有功能。 51.使用vuex的核心概念 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。 vuex的核心概念和核心概念图： 1、state - Vuex store实例的根状态对象，用于定义共享的状态变量。2、Action -动作，向store发出调用通知，执行本地或者远端的某一个操作（可以理解为store的methods）3、Mutations -修改器，它只用于修改state中定义的状态变量。4、getter -读取器，外部程序通过它获取变量的具体值，或者在取值前做一些计算（可以认为是store的计算属性） 52.如何在vuex中使用异步修改？在调用vuex中的方法action的时候，用promise实现异步修改 12345678910const actions = &#123; asyncInCrement(&#123; commit &#125;, n)&#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; commit(types.TEST_INCREMENT, n); resolve(); &#125;,3000) &#125;) &#125;&#125; 53.Promise对象是什么？ 必答： Promise对象是ES6（ ECMAScript 2015 ）对于异步编程提供的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 123456789101112131415function func1(a)&#123; return new Promise((resolve,reject) =&gt; &#123; if(a &gt; 10)&#123; resolve(a) &#125;else&#123; reject(b) &#125; &#125;)&#125;;func1(&apos;11&apos;).then(res =&gt; &#123; console.log(&apos;success&apos;);&#125;).catch(err =&gt; &#123; console.log(&apos;error&apos;);&#125;) Promise构造函数接受一个函数作为参数，该函数的两个参数分别resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是： 将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 fulfilled），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是： 将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise对象实例的方法，then 和 catch： .then方法： 用于指定调用成功时的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例），因此可以采用链式写法，即then方法后面再调用另一个then方法。 .catch方法： 用于指定发生错误时的回调函数。 54.axios、fetch与ajax有什么区别？主要区别是 axios、fetch请求后都支持Promise对象API，ajax只能用回调函数。 55.axios有什么特点？1、Axios 是一个基于 promise 的 HTTP 库，支持promise所有的API2、它可以拦截请求和响应3、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON类型的数据4、安全性更高，客户端支持防御 XSRF 56.vue组件的scoped属性的作用 当 &lt;style&gt; 标签有scoped 属性时，它的 CSS 只作用于当前组件中的元素 你可以在一个组件中同时使用有 scoped 和 非scoped 样式： 1234567&lt;style&gt;/* 全局样式 */&lt;/style&gt;&lt;style scoped&gt;/* 本地样式 */&lt;/style&gt; 57.vue中集成的UI组件库常用的UI组件库有： vux： Vue.js 移动端 UI 组件库 Amaze ~ 妹子 UI Element：饿了么组件库，适用于开发应用后台 mint-ui：移动端 UI 组件库 58.如何适配移动端？【 经典 】postcss可以被理解为一个平台，可以让一些插件在上面跑。它提供了一个解析器，可以将CSS解析成抽象语法树。通过PostCSS这个平台，我们能够开发一些插件，来处理CSS。热门插件如autoprefixer a) 使用flexible和 postcss-px2rem​ 之前使用rem适配的思路：使用媒体查询，确定不同屏幕下html标签的font-size (即1rem单位)，然后在写css样式的时候，就可以使用1rem , 2rem这样的单位来做适配了。 ​ 但是这种适配的问题是需要手动把px单位换算成rem单位，比较麻烦。对应的，我们可以使用flexible和 postcss-px2rem来解决这个问题 12345678//1.安装flexible。 flexible主要是实现在各种不同的移动端界面实现一稿搞定所有的设备兼容自适应问题npm install lib-flexible --save//2.main.js引入flexibleimport 'lib-flexible'//此时运行程序会看到html中自动加上了font-size font-size的默认值为viewport的十分之一//在页面中引入flexible.js后，flexible会在&lt;html&gt;标签上增加一个data-dpr属性和font-size样式（如下图）。 ​ 1234567891011121314151617//1.安装postcss-pxtoremnpm install postcss-pxtorem --save-dev//2.修改postcss.config.jsmodule.exports = &#123; plugins: &#123; //autoprefixer 自动补全css前缀的东西 'autoprefixer': &#123; //兼容的机型 browsers: ['Android &gt;= 4.0', 'iOS &gt;= 7'] &#125;, 'postcss-pxtorem': &#123; rootValue: 37.5, //换算基数，一般和html的font-size一致 propList: ['*'] //哪些css属性需要换算 &#125; &#125;&#125;; b) 使用postcss-px-to-viewport​ vw 与 vh单位，以viewport为基准，1vw 与 1vh分别为window.innerWidth 与 window.innerHeight的百分之一。 ​ vw/vh 单位其实出现比较早了，只是以前支持性不太好，现在随着浏览器的发展，大部分（92%以上）的浏览器已经支持了vw/vh 123456789101112131415161718192021222324252627282930npm i postcss-px-to-viewport -save -dev//修改postcss.config.jsmodule.exports = &#123; plugins: &#123; autoprefixer: &#123; //兼容的机型 browsers: ['Android &gt;= 4.0', 'iOS &gt;= 7'] &#125;, //px转换为vw单位的插件 \"postcss-px-to-viewport\": &#123; //1vw = 3.2 viewportWidth: 320, //1vh = 5.68 viewportHeight: 568, // px to vw无法整除时，保留几位小数 unitPrecision: 5, // 转换成vw单位 viewportUnit: 'vw', //不转换的类名 selectorBlackList: [], // 小于1px不转换 minPixelValue: 1, //允许媒体查询中转换 mediaQuery: false, //排除node_modules文件中第三方css文件 exclude: /(\\/|\\\\)(node_modules)(\\/|\\\\)/ &#125;, &#125;&#125;; 59.vue-cli工程中如何使用背景图？ 第一种方法：通过 import 引入 首先，引入要使用的背景图片： 123456&lt;script type=&quot;text/javascript&quot;&gt; import cover from &quot;../assets/images/cover.png&quot;; export default&#123; ... &#125;&lt;/script&gt; 然后，通过 v-bind:style 使用： 1&lt;div :style=&quot;&#123; backgroundImage:&apos;url(&apos; + cover + &apos;)&apos; &#125;&quot;&gt;&lt;/div&gt; 第二种方法：通过 require 引入： 直接通过 v-bind 和 require 配合使用 1&lt;div :style=&quot;&#123; backgroundImage:&apos;url(&apos; + require(&apos;../assets/images/couver.png&apos;) + &apos;)&apos; &#125;&quot;&gt;&lt;/div&gt; 60.vue中如何实现tab切换功能？在 vue 中，实现 Tab 切换主要有三种方式： 1、使用 component 动态组件实现 Tab切换 [推荐移动端使用] 2、使用 vue-router 路由配合&lt;router-view&gt;&lt;/router-view&gt;标签实现 3、使用第三方插件 61.vue中如何利用&lt;keep-alive&gt;&lt;/keep-alive&gt;标签实现某个组件缓存功能？vue-cli工程中实现某个组件的缓存功能，可用 keep-alive 标签，与 vue-router的meta形式数据传递配合完成。 第一步：在 app.vue 里面 template部分 使用 &lt;keep-alive&gt;&lt;/keep-alive&gt; 组件： 12345678&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive&gt; &lt;router-view v-if=&quot;$router.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; &lt;router-view v-if=&quot;!$router.meta.keepAlive&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 在src/router.js: 123456789101112131415161718192021222324import account from &apos;../page/demo/account.vue&apos;import course from &apos;../page/demo/course.vue&apos;export default new Router(&#123; //路由配置 routes: [ &#123; path: &apos;/account&apos;, name: &apos;account&apos;, component: Account, meta:&#123; keepAlive:false //false为不缓存 &#125; &#125;， &#123; path: &apos;/course&apos;, name: &apos;course&apos;, component: course, meta:&#123; keepAlive:true //true为缓存 &#125; &#125; ]&#125;) 62.vue中实现切换页面时为左滑出效果左滑效果实现，需要使用 &lt;transition&gt;&lt;/transition&gt; 组件配合 css3 动画效果实现。 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;!-- 使用transiton来规定页面切换时候的样式--&gt; &lt;transition name=&quot;slide-left&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;style lang=&quot;less&quot;&gt; /*左滑动效*/ .slide-left-enter-active &#123; animation: slideLeft 0.3s; &#125; /****自定义动画**/ @keyframes slideLeft &#123; from &#123; transform: translate3d(100%, 0, 0);/*横坐标,纵坐标,z坐标*/ visibility: visible; &#125; to &#123; transform: translate3d(0, 0, 0); &#125; &#125;&lt;/style&gt; 63.在vue-cli工程中如何实现无痕刷新？一般常用的两种刷新方法： window.location.reload()，原生 js 提供的方法； this.$router.go(0)，vue 路由里面的一种方法； 这两种方法都可以达到页面刷新的目的，简单粗暴，但是用户体验不好，相当于按 F5 刷新页面，页面的重新载入，会有短暂的白屏。 无痕刷新 原理： 先在全局组件注册一个方法，用该方法控制router-view的显示与否，然后在子组件调用。 步骤： v-if控制&lt;router-view&gt;&lt;/router-view&gt;的显示。 provide：全局注册方法。 methods：设置reload方法。 第一步 在app.vue里面设置， 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view v-if=&quot;isRouterAlive&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; provide()&#123; return&#123; reload:this.reload &#125; &#125;, data()&#123; return &#123; isRouterAlive:true &#125; &#125;, methods:&#123; reload()&#123; this.isRouterAlive = false; this.$nextTick(function()&#123; this.isRouterAlive = true; &#125;) &#125; &#125;&#125;&lt;/script&gt; 在.vue组件中使用，先用inject注册，然后即可通过this调用。 12345678&lt;script&gt;export default&#123; inject:[&apos;reload&apos;], mounted()&#123; this.reload(); &#125;&#125;&lt;/script&gt; 64.vue中中央事件总线？中央事件总线 - 就是一个名字可以叫做Bus的vue空实例,里边没有任何内容。 它就像一个公交车一样，来回输送人，将组件A输送到组件B，再将组件B输送到组件A； 这里A，B组件可以是父、子组件，也可以是兄、弟组件，或者两个没有任何关系的组件； 12345678910//1.创建中央事件总线var bus = new Vue();//2.使用Bus中央事件总线在A组件中发送信息Bus.$emit('自定义事件名'，'$on发送过来的数据')；//3.使用Bus中央事件总线在B组件中接收信息Bus.$on('自定义事件名'，function()&#123; //然后执行什么你自己懂的。。。&#125;)； 65.vue开发命令 npm run dev 输入后的执行过程【 拓展 】首先来看执行npm run dev时候最先执行的build/dev-server.js文件，该文件主要完成下面几件事情： 1、检查node和npm的版本、引入相关插件和配置 2、webpack对源码进行编译打包并返回compiler对象 3、创建express服务器 4、配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware） 5、挂载代理服务和中间件 6、配置静态资源 7、启动服务器监听特定端口（8080） 8、自动打开浏览器并打开特定网址（localhost:8080） 66.vue打包命令是什么？vue-cli 生成 生产环境部署资源 的 npm命令： 1npm run build 用于查看 vue-cli 生产环境部署资源文件大小的 npm命令： 1npm run build --report 67.vue打包后会生成哪些文件？默认生产 dist 文件夹： 生产index.html单页面文件 将组件中的 css 编译合并成一个 app.[hash].css 的文件， js 则在合并后又拆解成 了 3 个文件： app.[hash].js 包含了所有 components 中的 js 代码 vendor.[hash].js 包含了生产环境所有引用的 node_modules 中的代码 mainfest.[hash].js 则包含了 webpack 运行环境及模块 化所需的 js 代码 0.[hash].js 则是 vue-router 使用了按需加载生产的js文件 这样拆分的好处是：每块组件修改重新编译后不影响其他未修改的 js 文件 的 hash 值，这样能够最大限度地使用缓存，减少 HTTP 的请求数。 68.如何配置 vue 打包生成文件的路径？12345678//vue.config.js//部署应用包时的基本URL，如果是生产环境，部署到 /cli-study/dist 路径；如果是开发环境，部署到根路径 publicPath: process.env.NODE_ENV === &apos;production&apos; ? &apos;/cli-study/dist&apos; : &apos;/&apos;, //输出文件路径 outputDir: &apos;dist&apos;, 69.vue如何优化首屏加载速度？ 问题描述： 在Vue项目中，引入到工程中的所有js、css文件，编译时都会被打包进vendor.js，浏览器在加载该文件之后才能开始显示首屏。若是引入的库众多，那么vendor.js文件体积将会相当的大，影响首屏的体验。 解决方法是： 将引用的外部js、css文件剥离开来，不编译到vendor.js中，而是用资源的形式引用，这样浏览器可以使用多个线程异步将vendor.js、外部的js等加载下来，达到加速首开的目的。外部的库文件，可以使用CDN资源，或者别的服务器资源等。 几种常用的优化方法： 使用npm run build --report命令进行大文件定位。参考链接：大文件定位 路由的按需加载 将打包生成后 index.html页面 里面的JS文件引入方式放在 body 的最后 用文档的cdn文件代替 npm 安装包 UI库的按需加载 开启 Gzip 压缩 70.什么是mvvmMVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离把Model和View关联起来的就是ViewModel。 ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由viewModel完成，在这里指VUE） 因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理 71.MVVM模式的优点以及与MVC模式的区别MVVM模式的优点： 1、低耦合：视图（View）可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的”View”上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。 2、可重用性：你可以把一些视图逻辑放在一个ViewModel里面，让很多 view 重用这段视图逻辑。 3、独立开发：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。 4、可测试：界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。 MVVM 和 MVC 的区别： mvc 和 mvvm 其实区别并不大。都是一种设计思想。 主要区别 mvc 中 Controller演变成 mvvm 中的 viewModel， mvvm 通过数据来显示视图层而不是节点操作。 mvvm主要解决了: mvc中大量的DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验。 72.常见的实现数据绑定的做法有哪些实现数据绑定的做法有大致如下几种： 发布者-订阅者模式（backbone.js）脏值检查（angular.js）数据劫持（vue.js） 1、发布者-订阅者模式: 观察者模式又叫发布订阅模式（Publish/Subscribe），它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。 2、脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图， 最简单的方式就是通过 setInterval() 定时轮询检测数据变动， angular只有在指定的事件触发时进入脏值检测，大致如下： 1234567891、DOM事件，譬如用户输入文本，点击按钮等。( ng-click )2、XHR响应事件 ( $http )3、浏览器Location变更事件 ( $location )4、Timer事件( $timeout , $interval )5、执行 $digest() 或 $apply() 3、数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式， 通过Object.defineProperty()来劫持各个属性的setter，getter， 在数据变动时发布消息给订阅者，触发相应的监听回调。 73.Object.defineProperty()方法的作用是什么？ Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 语法： 1Object.defineProperty(obj, prop, descriptor) 参数说明： 123obj：必需。目标对象 prop：必需。需定义或修改的属性的名字descriptor：必需。目标属性所拥有的特性 返回值： 1传入函数的对象。即第一个参数obj 针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历。 74.Vue项目中常用到的加载器： vue-loader – 用于加载与编译 *.vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 HTML 模版 template，再分别把它们交给对应的 Loader 去处理。 vue-style-loader – 用于加载 *.vue 文件中的样式 style-loader – 用于将样式直接插入到页面的&lt;style&gt;内 css-loader – 用于加载 *.css 样式表文件; less-loader – 用于编译与加载 *.less 文件（需要依赖less库） babel-loader – 用于将 ES6 编译成为浏览器兼容的ES5 file-loader – 用于直接加载文件 url-loader – 用于加载 URL 指定的文件，多用于字体与图片的加载 json-loader – 用于加载 *.json 文件作为 JS 实例。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"Webpack","date":"2018-07-06T16:00:00.000Z","path":"2018/07/07/WebPack/","text":"1.Webpack1.1 引入1.1.1 网页中常见的静态资源 JS ： .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS ： .css .less .sass .scss Images ： .jpg .png .gif .bmp .svg 字体文件（Fonts）： .svg .ttf .eot .woff .woff2 模板文件 ： .ejs .jade .vue【这是在webpack中定义组件的方式，推荐这么用】 1.1.2 静态资源带来的问题 网页加载速度慢， 因为我们要发起很多的二次请求； 要处理错综复杂的依赖关系 1.1.3 如何解决上述两个问题 合并、压缩、精灵图、图片的Base64编码 可以使用之前学过的requireJS、也可以使用webpack可以解决各个包之间的复杂依赖关系； 1.1.4 完美实现上述问题的2种解决方案 使用Gulp， 是基于 task 任务的，是前端构建工具； 使用browserify/Webpack， 是预编译的模块化方案； 1.1.5 gulp​ gulp是基于Node.js的前端自动化构建工具，能自动化地完成 JavaScript/sass/html/image/css 等文件的的测试、检查、合并、压缩混淆、格式化、浏览器自动刷新、部署文件生成等操作，同时可以对文件进行监听，如果文件有改动，可以自动处理生成新的文件。 ​ 所以gulp解决了开发效率(修改代码后自动更新页面)、资源整合(代码的压缩合并)、代码质量(代码的检查 自动化测试)、代码转换(es6–&gt;es5)等问题 ​ 官网​ 中文网 a) gulp的核心方法 gulp.task(‘任务名’,function(){}) // 创建任务。 gulp.src(‘./*.css’) // 指定想要处理的文件 gulp.dest() // 指定最终处理后的文件的存放路径 gulp.watch() // 自动的监视文件的变化，然后执行相应任务。 gulp.run(‘任务名’) // 直接执行相应的任务。 b) 安装gulp使用 1.通过npm安装:npm install gulp-cli -g 安装全局的命令行，可以在终端中使用gulp相关命令 2.在当前项目中也要安装gulp: npm install gulp --save 3.还需要在当前项目中新建一个文件: gulpfile.js 123456789101112var gulp = require('gulp');// 创建任务// 第一个参数: 任务名// 第二个参数: 回调函数,当我们执行任务时就会执行这个函数gulp.task('test', function()&#123; console.log(123) return gulp.src('src/js2/*.js');&#125;)//执行任务: gulp 任务名gulp test c) 对js进行压缩混淆和合并 npm install gulp-uglify --save 压缩混淆 npm install gulp-concat --save 合并 12345678910111213141516var gulp = require('gulp');var uglify = require('gulp-uglify');var concat = require('gulp-concat');gulp.task('script', function()&#123; // 1.要匹配到要处理的文件 // 指定指定的文件:参数是匹配的规则 // 参数也可以是数组，数组中的元素就是匹配的规则 return gulp.src('src/js2/*.js') // concat 的参数是合并之后的文件名字 .pipe(concat('index.js')) // 压缩混淆 .pipe(uglify()) // dest方法参数，指定输出文件的路径 .pipe(gulp.dest('dist/js2'))&#125;)gulp.run('script') d) 对css进行压缩操作 npm install gulp-cssnano --save 123456789101112131415var concat = require('gulp-concat');var cssnano = require('gulp-cssnano');// 新建一个任务，对css进行处理gulp.task('style', function()&#123; // 对项目中的2个css文件进行合并，压缩操作 // 1.匹配到要处理的文件 return gulp.src('src/css/*.css') // 2.合并文件 .pipe(concat('index.css')) // 3.压缩操作 .pipe(cssnano()) // 4.输出到指定目录 .pipe(gulp.dest('dist/css'))&#125;)gulp.run('style') e) 对html进行压缩 npm install gulp-htmlmin --save 1234567891011var htmlmin = require('gulp-htmlmin');// 新建一个任务，对html进行压缩gulp.task('html', function()&#123; // 1.匹配到要处理的文件 return gulp.src('src/index.html') // 2.压缩操作 .pipe(htmlmin(&#123;collapseWhitespace:true&#125;)) // 3.指定输出目录 .pipe(gulp.dest('dist'))&#125;)gulp.run('html') f) gulp.watch 监视文件的变化，然后执行相应的任务 123456789// gulp.watch 监视文件变化，执行相应任务gulp.task('mywatch', function()&#123; // 1.监视js文件的变化，然后执行script任务 // 第一个参数：要监视的文件的规则 // 第二个参数：是要执行的任务 gulp.watch(\"src/js2/*.js\",gulp.series(\"script\"))&#125;)//然后使用gulp mywatch启动监听，然后一旦源文件修改了，会立刻同步编译新的目标文件 g) gulp对requirejs的打包和压缩1234#1.初始化项目，安装gulpnpm init -ynpm install gulpnpm install gulp-requirejs-optimize //gulp对于requireJS依赖处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#1.index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;requirejs-gulp&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;demo&lt;/h2&gt; &lt;div&gt;相加的值：&lt;span class=\"math\"&gt;&lt;/span&gt;&lt;/div&gt; &lt;!--data-main指定js文件的入口--&gt; &lt;script src=\"./require.js\" data-main=\"./js/entry.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;#2.math.js//定义math模块，该模块依赖于jquery模块，入参$define(['jquery'], function($)&#123; var math = &#123; add: function(i,j)&#123; $('.math').text(i+j) &#125; &#125; //requireJS模块需要返回一个对象 return math;&#125;)#3.entry.js//require配置require.config(&#123; path: &#123; \"jquery\": \"./jquery\", \"math\": \"./math\", &#125;, //requireJS加载非AMD规范的模块，需要用shim(AMD规范是用define和require定义和引入规范) shim: &#123; \"jquery\": &#123; //exports的值要与文件中暴露出全局变量名称一致 exports: '$' &#125; &#125;&#125;);//入口文件引入math模块，function中的入参需要是模块名require(['math'], function(math)&#123; math.add(3,5);&#125;);#4.项目中引入require.js，然后使用浏览器运行index.html打开network，查看index.html的请求资源数#5.使用gulp进行打包构建，在项目根目录下创建gulpfile.jsvar gulp = require('gulp');var requirejsOptimize = require('gulp-requirejs-optimize');//要进行的任务gulp.task('rjs', function()&#123; //源文件 return gulp.src('src/js/*.js') .pipe( requirejsOptimize(&#123; optimize: 'none', /*optimize: 'uglify',*/ /*uglify 压缩所有文件*/ paths:&#123; //.的含义是task任务所在的js文件路径，即生成模块的路径，所以.代表src/js目录，这里要用.. \"jquery\": '../js/jquery', 'entry': '../js/entry', 'math': '../js/math', &#125; &#125;)) //配置详解：https://blog.csdn.net/xuelang532777032/article/details/55096057 .pipe(gulp.dest('dist/js/'));&#125;);#6.修改index.html中的请求资源路径，再查看浏览器中network中的请求资源数 &lt;script src=\"./require.js\" data-main=\"../dist/js/entry.js\"&gt;&lt;/script&gt; 1.1.6 webpack webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 借助于webpack这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 123456789# 在没有使用webpack之前：举个例子：index.html里面有一大堆的css和js文件，如a.js b.js c.js d.js等等（1）a.js要用到b.js里面的一个函数，则a.js要放在b.js后面（2）c.js要用到a.js里面的一个函数，则c.js要放在a.js后面（3）b.js又要用到d.js文件里面的函数，则b.js就要放在d.js后面如果有N多个js文件，需要手动处理他们的关系，即容易出错。# 使用webpack：webpack的理念就是一切皆模块化，把一堆的css文件和js文件放在一个总的入口文件，通过require引入，剩下的事情webpack会处理，包括所有模块的前后依赖关系，打包、压缩、合并成一个js文件，公共代码抽离成一个js文件、某些自己指定的js单独打包，模块可以是css/js/images/font等等。 1.1.7 Gulp和webpack对比​ gulp、grunt、webpack都是前端自动化构建工具。 a) gulp gulp 和 grunt 非常类似，gulp强调的是前端开发的工作流程，核心都是基于一个个的任务(task)进行项目构建，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 只是grunt 会频繁进行 IO 操作，而 gulp 则不需要(基于管道流)，可以更高效的完成操作。 PS：简单说就一个Task Runner b) webpack Webpack与Gulp、Grunt没有什么可比性，它把项目看成一个整体，是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。 PS：webpack is a module bundle 1.2 webpack的安装​ WebPack官网 运行npm i webpack@4.27.1 -g全局安装webpack，这样就能在全局使用webpack的命令 123配置环境变量npm install webpack-cli@3.1.2 -g 在项目根目录中运行npm i webpack@4.27.1 --save-dev安装到项目依赖中 123npm info webpack //查看npm上的webpack的信息webpack -v //查看当前安装的webpack的版本信息 1.3 webpack打包构建https://webpack.docschina.org/guides/getting-started 1.3.1 webpack 列表隔行变色案例 运行npm init -y初始化项目，使用npm管理项目中的依赖包 创建项目基本的目录结构 使用npm i jquery --save安装jquery类库 index.html 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;!--不推荐这样用，这样使用会导致当前文件依赖于其他文件--&gt; &lt;!--&lt;script type=\"text/javascript\" src=\"../node_modules/jquery/jquery.js\"&gt;&lt;/script&gt;--&gt; &lt;!--所以我们把主要的逻辑代码写到main.js中，只要引入一个main.js就可以了--&gt; &lt;!--&lt;script type=\"text/javascript\" src=\"main.js\"&gt;&lt;/script&gt;--&gt; &lt;!--使用打包后的路径--&gt; &lt;script type=\"text/javascript\" src=\"../dist/bundle.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--使用jquery实现隔行渐变--&gt; &lt;ul&gt; &lt;li&gt;A&lt;/li&gt; &lt;li&gt;B&lt;/li&gt; &lt;li&gt;C&lt;/li&gt; &lt;li&gt;D&lt;/li&gt; &lt;li&gt;E&lt;/li&gt; &lt;li&gt;F&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 创建main.js并书写各行变色的代码逻辑： 12345678910111213// 1. 导入 Jquery// import *** from *** 是ES6中导入模块的方式// 由于 ES6的代码，太高级了，浏览器解析不了，所以，这一行执行会报错import $ from 'jquery'//const $ = require('jquery') express导包的语法，vue中使用es6导包的语法，import .. from ..// 设置偶数行背景色，索引从0开始，0是偶数$(function () &#123; $('li:odd').css('backgroundColor', 'yellow') $('li:even').css('backgroundColor', function () &#123; return '#' + 'D97634' &#125;)&#125;) 注意点 123451. 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的JS语法，需要使用webpack进行处理，webpack默认会把这种高级的语法转换为低级的浏览器能识别的语法；2. 运行webpack 入口文件路径 输出文件路径对main.js进行处理： webpack ./src/main.js -o ./dist/bundle.js3.webpack使用的是CommonJS模块化规范，即require引入模块，module.exports导出模块 Vue中使用的是ES6的模块化规范，即import ** from **引入模块，export /export default导出模块 webstorm中的cmd 12点击左下角的Terminal如果要运行package.json中的指令，可以选择tools--&gt;run gulp/grunt/npm task 1.3.2 webpack配置文件使用 在项目根目录中创建webpack.config.js 由于运行webpack命令的时候，webpack需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： 1234567891011// 导入处理路径的模块var path = require('path');// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, 'src/main.js'), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, 'dist'), // 配置输出的路径 filename: 'bundle.js' // 配置输出的文件名 &#125;&#125; 使用命令打包构建 12345678# 使用webpack命令即可打包项目webpack --config webpack.config.js// 当我们在控制台，直接输入 webpack 命令执行的时候，webpack 做了以下几步：// 1. 首先webpack 发现我们并没有通过命令的形式给它指定入口和出口// 2. webpack 就会去项目的根目录中查找一个叫做 `webpack.config.js` 的配置文件// 3. 当找到配置文件后，webpack会去解析执行这个配置文件，当解析执行完配置文件后，就得到了 配置文件中，导出的配置对象// 4. 当 webpack拿到配置对象后，就拿到了配置对象中指定的入口和出口，然后进行打包构建； 1.3.3 webpack实时打包构建 由于每次重新修改代码之后，都需要手动运行webpack打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 安装webpack-dev-server 12npm i webpack-dev-server@3.1.9 --save-devnpm i webpack@4.27.1 --save-dev //项目中安装webpack 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，因为它不是全局命令，不可以直接使用。 我们借助于package.json文件中的指令来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包 1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server\"&#125; 运行项目 1npm run dev 但是dist目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中。把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 12Project is running at [1m [34mhttp://localhost:8084/ [39m[22mwebpack output is served from / ​ 此时我们可以通过http://localhost:8083/bundle.js 文件，因为webpack-dev-server默认是将bundle.js文件打包到根路径，所以要能做到修改main.js之后页面也要同步变化，需要修改页面的script标签： 1&lt;script type=&quot;text/javascript&quot; src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 6.指定启动参数： ​ 为了能在访问http://localhost:8080/的时候直接访问到index首页，可以使用--contentBase src指令来修改dev指令，指定启动的根目录： 123456789\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --open --port 3001 --contentBase src --hot\" &#125;, // --open含义：构建完成自动打开浏览器 // --port 3001 : 指定运行的端口 // --contentBase src : 指定运行的根目录是src，即认为src就是项目根目录 // --hot : 以补丁的方式修改文件，而不是修改全部文件 ​ 7.解决webpack4.0之后打包大小警告和热更新慢的问题 ​ https://cloud.tencent.com/developer/section/1477466 12345678910111213141516#main.js const path = require('path')module.exports = &#123; //1.设置为开发模式，不然热更新会比较缓慢 mode:\"development\", entry: path.resolve(__dirname, 'src/main.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, //2.打包文件大小警告和错误的问题 performance: &#123; hints:false &#125;&#125; 1.3.3 使用配置文件生成参数(了解)12345678910111213141516171819202122const path = require('path')// 启用热更新的 第2步const webpack = require('webpack')module.exports = &#123; entry: path.join(__dirname, './src/main.js'), output: &#123; path: path.join(__dirname, './dist'), filename: 'bundle.js' &#125;, devServer: &#123; // 这是配置 dev-server 命令参数的第二种形式，相对来说，这种方式麻烦一些 // --open --port 3000 --contentBase src --hot open: true, // 自动打开浏览器 port: 3000, // 设置启动时候的运行端口 contentBase: 'src', // 指定托管的根目录 hot: true // 启用热更新 的 第1步 &#125;, plugins: [ // 配置插件的节点 new webpack.HotModuleReplacementPlugin(), // new 一个热更新的 模块对象， 这是 启用热更新的第 3 步 ],&#125; 1.3.4 html-webpack-plugin插件配置启动页面​ https://www.npmjs.com/package/html-webpack-plugin ​ html-webpack-plugin插件可以将指定页面配置生成到内存中，并且可以将打包的bundle.js配置到内存中生成的html页面中，使用步骤如下： 运行npm i html-webpack-plugin@3.2.0 --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718const path = require('path')// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './src/main.js'), output: &#123; path: path.join(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;) ],&#125; 修改package.json中script节点中的dev指令如下： 1234\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --open --port 3001 --contentBase src --hot\"&#125;, 将index.html中script标签注释掉，因为html-webpack-plugin插件会自动把bundle.js注入到index.html页面中！ 1.3.5 使用webpack打包css文件​ 一般情况下，我们并不推荐在html页面中直接引入其他css文件，这样会导致过多的请求。对应的，我们可以使用webpack来构建。使用步骤如下： 运行 npm i style-loader css-loader --save-dev main.js中引入index.css 1import \"./css/index.css\" 修改webpack.config.js这个配置文件： 1234567// 用来配置第三方loader模块的module: &#123; rules: [ // 匹配以.css结尾的文件 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;//处理css文件的规则 ]&#125; webpack 处理第三方文件类型的过程 12341. 发现这个要处理的文件不是JS文件，然后就去配置文件中，查找有没有对应的第三方 loader 规则2. 如果能找到对应的规则， 就会调用对应的loader处理这种文件类型；3. 在调用loader的时候，use中相关loader模块的调用顺序是从后向前调用的；4. 当最后的一个loader调用完毕，会把处理的结果直接交给 webpack 进行打包合并，最终输出到 bundle.js 中去 1.3.6 使用webpack打包less文件 运行npm i less-loader less，需要同时安装less-loader和less main.js中引入index.less 1import \"./css/index.less\" 修改webpack.config.js这个配置文件： 123456module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125; ]&#125; 1.3.7 使用webpack打包scss文件 运行npm i sass-loader node-sass --save-dev main.js中引入index.scss 12//注意：文件名是scss结尾import \"./css/index.scss\" 在webpack.config.js中添加处理scss文件的loader模块： 1234567module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ]&#125; 1.3.8 使用webpack处理css中的路径 运行npm i url-loader file-loader --save-dev 在webpack.config.js中添加处理url路径的loader模块： 12345678module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader' &#125; ] &#125; index.css 12345div&#123; width: 600px; height: 450px; background-image: url(../images/1.jpg);&#125; ​ 注意点：url-loader默认情况下会将图片转换为base64编码的图片，好处是可以减少图片的二次请求。但是这种方式一般情况下适用于小图，如果是大图，我们可以像下面这样去使用： 1234567891011121314151617181920212223module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name:'[hash:8]-[name].[ext]' &#125; &#125; ] &#125; ]&#125;//limit ： 当图片大小小于等于指定的值时会进行base64编码//name =[name].[ext]： 不给图片重命名，还是使用原图名。如果没有这个属性，则默认会使用hashcode的方式来给图片重命名。//给图片重命名的好处是：如果在多个不同的目录下有两张同名的图片(内容不同)，不会产生冲突。(默认情况下webpack会将图片也打包到根路径下)//如果既想多个文件夹下的同名的图片被打包后不冲突，又想保留原来的图片名字，可以这样使用：name=[hash:8]-[name].[ext] ， [hash:8]表示保留8位hash值，然后再去追加原来的[name] 1.3.9 使用webpack处理字体图标1.运行npm i bootstrap@3.3.5安装boostrap 2.main.js引入bootstrap 12//注意：这边import的时候不需要加上 node_modules目录，import前面没有路径的时候会自动从node_modules目录下去查找import \"bootstrap/dist/css/bootstrap.css\" 3.index.html 1&lt;span class=\"glyphicon glyphicon-heart-empty\"&gt;&lt;/span&gt; 4.webpack.config.js修改匹配规则。因为boostrap的字体文件中也使用了url，所以字体文件的路径一样要处理 1234567891011121314151617181920212223242526module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name:'[hash:8]-[name].[ext]' &#125; &#125; ] &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: [ &#123; loader:'url-loader' &#125; ] &#125;, // 处理 字体文件的 loader ]&#125; 1.3.10 webpack中babel的配置​ 在 webpack 中，默认只能处理一部分 ES6 的新语法；这时候就需要借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader可以把高级语法转为低级的语法，然后再把结果交给 webpack 去打包到 bundle.js 中 运行npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev安装babel的相关loader包 (babel的转换工具) 运行npm i babel-preset-env babel-preset-stage-0 --save-dev安装babel转换的语法 (es6的语法和es5的语法的对应关系) 在webpack.config.js中添加相关loader模块，其中需要注意的是，一定要把node_modules文件夹添加到排除项： 1234567891011module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;, // 处理 字体文件的 loader //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉 &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, ]&#125; 在项目根目录中添加.babelrc文件，并修改这个配置文件如下(这个文件必须符合json的语法，不能有注释。字符串必须使用双引号)： 1234&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]&#125; 注意：之前用的比较多的语法插件babel-preset-es2015更新为babel-preset-env，它包含了所有的ES相关的语法； 1.3.11 所有配置总结12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# 1.安装npm i webpack@4.20.1 --save-dev //安装webpacknpm init -y //项目初始化npm i webpack-dev-server@3.1.9 --save-dev //实时打包构建npm i webpack-cli@3.1.2 npm i html-webpack-plugin@3.2.0 --save-dev //配置内存页面npm i style-loader css-loader --save-dev //css加载器npm i less-loader less //less加载器npm i sass-loader node-sass --save-dev //sass加载器npm i url-loader file-loader --save-dev //url加载器npm i babel-core@6.26.3 babel-loader@7.1.5 babel-plugin-transform-runtime --save-dev //babel转换工具npm i babel-preset-env babel-preset-stage-0 --save-dev //babel转换的语法#2.webpack.config.jsconst path = require('path')// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './src/main.js'), output: &#123; path: path.join(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;) ], module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;,//处理css文件的规则 &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;, // 处理 字体文件的 loader //配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉 &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, ] &#125;&#125;#3.项目入口文件import \"./css/index.css\"console.log(\"ok\");class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; showInfo()&#123; console.log(this.name); &#125;&#125;var p = new Person(\"xiaoming\",18);console.log(p.name);#4.package.json \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --open --port 3000 --contentBase src --hot\" &#125;#5.项目根目录 .babelrc&#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\"]&#125; 1.4 相关文章babel-preset-env：你需要的唯一Babel插件Runtime transform 运行时编译es6 2.Vue结合webpack的使用2.1 基本使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#1.安装vue 运行npm i vue@2.3.4将vue安装为运行依赖 #2.main.js/* 注意：在webpack中使用 import Vue from 'vue'导入的Vue构造函数功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式； import Vue from 'vue' 导入包的规则： 1. 找项目根目录中有没有 node_modules 的文件夹 2. 在node_modules中根据包名，找对应的vue文件夹 3. 在vue文件夹中，找一个叫做 package.json 的包配置文件 4. 在package.json文件中，查找一个 main 属性【main属性指定了这个包在被加载时候的入口文件】，这里我们发现入口文件为vue.runtime.common.js，并不是vue.js文件 解决方案有两种： 1.在webpack.config.js下新增配置： resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.js' &#125; &#125; 然后使用 import Vue from 'vue' 就可以了 2.手动修改导包的路径为：import Vue from 'vue/dist/vue''，此时无需修改配置文件*/import Vue from 'vue'var login = &#123; template: '&lt;h1&gt;这是login组件，是使用网页中形式创建出来的组件&lt;/h1&gt;'&#125;var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, components:&#123; login &#125;&#125;)#3.index.html&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;#4.webpack.config.jsresolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.js' &#125;&#125;#5.package.json、.babelrc还有webpack的所需要安装的内容和之前一致 2.2 使用.vue文件的方式生成组件​ webstorm中支持vue文件的提示，需要安装插件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#1. 新建login.vue文件&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 &lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;#2.main.js引入.vue文件，并使用import Vue from 'vue'import login from './login.vue'var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, components:&#123; login &#125;&#125;)#3. index.html&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;login&gt;&lt;/login&gt;&lt;/div&gt;#4.安装vue-loader和 vue-template-compiler(默认情况下不支持import方式引入.vue文件，需要安装下面两个文件)npm i vue-loader@15.4.2 vue-template-compiler@2.3.4//注意：这里vue-template-compiler版本需要和当前使用的vue版本一致#5.webpack.config.jsconst path = require('path')var htmlWebpackPlugin = require('html-webpack-plugin');//1.引入VueLoaderPlugin插件(在vue-loader15版本以后需要配置这个)const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; entry: path.join(__dirname, './src/main.js'), output: &#123; path: path.join(__dirname, './dist'), filename: 'bundle.js' &#125;, plugins: [ new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, 'src/index.html'),//模板路径 filename:'index.html'//自动生成的HTML文件的名称 &#125;), // 2.配置VueLoaderPlugin插件 new VueLoaderPlugin() ], module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.less$/, use: ['style-loader', 'css-loader', 'less-loader'] &#125;, &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125;, &#123; test: /\\.(png|jpg|gif|bmp|jpeg)$/, use: 'url-loader?limit=1024&amp;name=[hash:8]-[name].[ext]' &#125;, &#123; test: /\\.(ttf|eot|svg|woff|woff2)$/, use: 'url-loader' &#125;, &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125;, //3.处理 .vue 文件的 loader &#123; test: /\\.vue$/, use: 'vue-loader' &#125; ] &#125;, resolve: &#123; alias: &#123; 'vue$': 'vue/dist/vue.js' &#125; &#125;&#125; 2.3 render渲染组件123456789101112131415#main.jsimport Vue from 'vue'import login from './login.vue'var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, render: c =&gt; c(login)&#125;)//注意：此种方式会替换页面内容 2.4 .vue组件中的数据2.4.1 模块的导出 ES6语法： 在ES6中使用 export default 和 export 导出模块中的成员; (Node中使用 module.exports 和 export导出成员) 使用 import from 和 import ‘路径’ 还有 import {a, b} from ‘模块标识’ 导入其他模块 123456789101112131415161718192021222324252627282930#1. 新建test.js// 在 ES6 中，使用 export default 和 export 向外暴露成员：var info = &#123; name: 'zs', age: 20&#125;export default info/* 注意： export default 向外暴露的成员，可以使用任意的变量来接收 在一个模块中，export default 只允许向外暴露1次 在一个模块中，可以同时使用 export default 和 export 向外暴露成员*/export var title = '小星星'export var content = '哈哈哈'/*注意： 使用 export 向外暴露的成员，只能使用 &#123; &#125; 的形式来接收，这种形式叫做 【按需导出】 export 可以向外暴露多个成员， 同时如果某些成员在我们import 的时候不需要，则可以不在 &#123;&#125; 中定义 使用 export 导出的成员，必须严格按照导出时候的名称来使用 &#123;&#125; 按需接收； 使用 export 导出的成员，如果想换个名称来接收，可以使用 as 来起别名；*/#2. main.jsimport minfo3, &#123; title as title123, content &#125; from './test.js'console.log(minfo3) //这里的minfo3就是test.js中所暴露出来的default infoconsole.log(title123 + ' --- ' + content) 2.4.2 .vue中的数据导出123456789101112131415161718192021222324#login.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;button @click=\"show\"&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; // 注意：组件中的 data 必须是 function return &#123; msg: \"123321\" &#125;; &#125;, methods: &#123; show() &#123; console.log(\"调用了 login.vue 中的 show 方法\"); &#125; &#125; &#125;;&lt;/script&gt; 2.5 vue-router使用​ vue-router官网 2.5.1 基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#1. 安装路由模块npm install vue-router --save#2.login.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;button @click=\"show\"&gt;点我&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; // 注意：组件中的 data 必须是 function return &#123; msg: \"123321\" &#125;; &#125;, methods: &#123; show() &#123; console.log(\"调用了 login.vue 中的 show 方法\"); &#125; &#125; &#125;;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;#3.register.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是注册组件&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;#4.main.jsimport Vue from 'vue'//1.导入VueRouter并且安装import VueRouter from 'vue-router'Vue.use(VueRouter)//2.导入组件import login from './login.vue'import register from './register.vue'//3.创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ]&#125;);var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, //4.挂载路由 router:router&#125;)#5.index.html&lt;div id=\"app\"&gt; &lt;router-link to=\"/login\"&gt;登陆&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;#6.webpack.config.js参照之前的配置 2.5.2 vue-router和render结合使用12345678910111213141516171819202122232425262728# 在上面案例的基础上#1.新增account.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;账户组件&lt;/h1&gt; &lt;!--组件中的路由--&gt; &lt;router-link to=\"/login\"&gt;登陆&lt;/router-link&gt; &lt;router-link to=\"/register\"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;#2.main.jsimport account from './account.vue'var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, //渲染组件替换el render:e=&gt;e(account), router:router&#125;)#3.index.html&lt;div id=\"app\"&gt;&lt;/div&gt; 2.5.3 路由嵌套123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 在上面案例的基础上#1. 新建subcom/findpwd.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;找回密码&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;#2. 新建subcom/thirdpartlogin.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;微信登陆&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;#3.修改login.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是登录组件，使用 .vue 文件定义出来的 --- &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;button @click=\"show\"&gt;点我&lt;/button&gt; &lt;router-link to=\"/login/findpwd\"&gt;找回密码&lt;/router-link&gt; &lt;router-link to=\"/login/thirdpartlogin\"&gt;第三方登陆&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; // 注意：组件中的 data 必须是 function return &#123; msg: \"123321\" &#125;; &#125;, methods: &#123; show() &#123; console.log(\"调用了 login.vue 中的 show 方法\"); &#125; &#125; &#125;;&lt;/script&gt;#4.在main.js中配置子路由var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login, children:[ &#123;path:'findpwd',component:findpwd&#125;, &#123;path:'thirdpartlogin',component:thirdpartlogin&#125; ] &#125;, &#123; path: '/register', component: register &#125; ]&#125;); 2.6 组件样式12345678910111213141516171819202122# 在上面代码的基础上#login.vue新增样式&lt;style scoped&gt; /*scoped作用域，如果不加scoped，则h1的样式会默认使用为全局而非当前组件*/ h1&#123; color: red; &#125;&lt;/style&gt;#account.vue新增样式&lt;style lang=\"scss\" scoped&gt; /*要编译sass只需要lang=\"scss\"就可以 scoped 推荐使用*/ body&#123; h1&#123; background-color: blue; &#125; &#125;&lt;/style&gt;//scoped的原理：scoped实际上是给当前组件的所有元素加上data-v-f626523的属性来实现的样式隔离 2.7 抽离路由为单独的模块1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#1.main.jsimport Vue from 'vue'//导入VueRouter并且安装import VueRouter from 'vue-router'Vue.use(VueRouter)import account from './account.vue'//导入路由模块import router from './router.js'var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, render:e=&gt;e(account), //挂载路由 router:router&#125;)#2.router.jsimport VueRouter from 'vue-router'//导入组件import login from './login.vue'import register from './register.vue'import findpwd from './subcom/findpwd.vue'import thirdpartlogin from './subcom/thirdpartlogin.vue'//创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login, children:[ &#123;path:'findpwd',component:findpwd&#125;, &#123;path:'thirdpartlogin',component:thirdpartlogin&#125; ] &#125;, &#123; path: '/register', component: register &#125; ]&#125;);//导出路由对象export default router; 3.vuex介绍3.1 vuex概念​ https://vuex.vuejs.org/zh/installation.html ​ vuex 是 Vue 配套的 公共数据管理工具，它可以把一些共享的数据保存到 vuex 中，方便 整个程序中的任何组件直接获取或修改我们的公共数据； 3.2 vuex的基本使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#1.拷贝原项目中除了node_modules之外的其他信息，运行npm install安装模块 #2.安装vuex npm i vuex -S#3.main.jsimport Vue from 'vue'import Vuex from 'vuex'// 注册vuex到vue中Vue.use(Vuex)// new Vuex.Store()实例，得到一个数据仓储对象// 可以在组件中通过this.$store.state.xx 来访问store中的数据var store = new Vuex.Store(&#123; //state相当于组件中的data state: &#123; count: 0 &#125;, //如果要修改store中state的值，需要调用 mutations提供的方法，可以通过this.$store.commit('方法名')来调用 mutations: &#123; increment(state) &#123; state.count++ &#125;, //mutations函数参数列表中最多支持两个参数，其中参数1是state； 参数2是通过commit提交过来的参数； subtract(state, obj) &#123; console.log(obj) state.count -= obj.step; &#125; &#125;, getters: &#123; //这里的getters只负责对外提供数据，不负责修改数据，如果想要修改 state 中的数据需要在mutations中修改 optCount: function (state) &#123; return '当前最新的count值是：' + state.count &#125; &#125;&#125;)// 总结：// 1. state中的数据，不能直接修改，如果想要修改，必须通过 mutations// 2. 如果组件想要直接 从 state 上获取数据： 需要 this.$store.state.***// 3. 如果组件想要修改数据，必须使用 mutations 提供的方法，需要通过 this.$store.commit('方法的名称'， 唯一的一个参数)// 4. store中state上的数据在对外提供的时候建议做一层包装，推荐使用 getters。调用的时候则用this.$store.getters.***import App from './App.vue'const vm = new Vue(&#123; el: '#app', render: c =&gt; c(App), //将vuex创建的store挂载到VM实例上，只要挂载到了 vm 上，任何组件都能使用store来存取数据 store&#125;)#4.index.html&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;#5.App.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;这是 App 组件&lt;/h1&gt; &lt;hr&gt; &lt;counter&gt;&lt;/counter&gt; &lt;hr&gt; &lt;amount&gt;&lt;/amount&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import counter from \"./components/counter.vue\"; import amount from \"./components/amount.vue\"; export default &#123; data() &#123; return &#123;&#125;; &#125;, components: &#123; counter, amount &#125; &#125;;&lt;/script&gt;#6.components/amount.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;&#123;&#123; $store.getters.optCount &#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;#7.components/counter.vue&lt;template&gt; &lt;div&gt; &lt;input type=\"button\" value=\"绑定事件-减少\" @click=\"sub\"&gt; &lt;input type=\"button\" value=\"绑定事件-增加\" @click=\"add\"&gt; &lt;br&gt; &lt;input type=\"text\" v-model=\"$store.state.count\"&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#125;; &#125;, methods: &#123; add() &#123; this.$store.commit(\"increment\"); &#125;, sub() &#123; this.$store.commit(\"subtract\",&#123; step:3&#125;); &#125; &#125;&#125;;&lt;/script&gt; 3.3 vuex异步修改状态​ mutation的使用局限：mutation必须是同步函数，如果有异步操作，可以在actions完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#main.js中给store添加actions的方法var store = new Vuex.Store(&#123; // state相当于组件中的data state: &#123; count: 0 &#125;, // 如果要修改store中state的值，需要调用 mutations提供的方法，可以通过this.$store.commit('方法名')来调用 mutations: &#123; increment (state) &#123; state.count++ &#125;, // mutations函数参数列表中最多支持两个参数，其中参数1是state； 参数2是通过commit提交过来的参数； subtract (state, obj) &#123; console.log(obj) state.count -= obj.step &#125; &#125;, getters: &#123; // 这里的getters只负责对外提供数据，不负责修改数据，如果想要修改 state 中的数据需要在mutations中修改 optCount: function (state) &#123; return '当前最新的count值是：' + state.count &#125; &#125;, actions: &#123; // action中的方法允许异步事件 increment (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; // 提交mutations中的increment方法 commit('increment') &#125;, 1000) &#125;, subtract (&#123; commit &#125;, obj) &#123; // 返回一个Promise，以便做回调 return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('subtract', obj) resolve() &#125;, 1000) &#125;) &#125; &#125;&#125;)#components/counter.vuemethods: &#123; add () &#123; // dispatch 触发指定的action this.$store.dispatch(\"increment\") &#125;, sub () &#123; this.$store.dispatch(\"subtract\", &#123; step: 3 &#125;) .then(() =&gt; &#123; console.log(\"减少操作完成\") &#125;) &#125;&#125; 3.4 vuex的模块12345678910111213141516171819202122232425262728293031#1.使用Vuex.Store中的modules声明多个模块const moduleA = &#123; state: &#123; count: 1 &#125;, mutations: &#123; &#125;&#125;const moduleB = &#123; state: &#123; count: 11 &#125;, mutations: &#123; &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)#2.使用不同模块中的数据&lt;div&gt; &lt;h3&gt;&#123;&#123; $store.state.a.count &#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123; $store.state.b.count &#125;&#125;&lt;/h3&gt;&lt;/div&gt; 3.5 刷新网页时vuex缓存https://blog.csdn.net/weixin_42233917/article/details/82217596 4.vue中UI框架4.1 常用框架介绍PC桌面端UI框架： 1231. iview （用户评分高功能多炫酷，解决和避免了其他UI框架出现的一些小问题）2. bootstrap （使用用户最多）3. ElementUI （饿了么团队研发，使用较多不过里还有些小bug） 手机端UI框架： 123456781.BUI http://www.easybui.com/docs/ 很不错官网有视频介绍。视频里有介绍非常非常实用的工具，建议去看官网视频。这个框架有现成的模板只需要一个创建模板的命令就可以创建一个大致的具有交互功能的页面。2.vux vux 基于WeUI和Vue(2.x)开发的移动端UI组件库 基于webpack+vue-loader+vux可以快速开发移动端页面，配合vux-loader方便你在WeUI的基础上定制需要的样式。3.Mint UI Mint UI 由饿了么前端团队推出的，Mint UI 是一个基于 Vue.js 封装的移动端组件库 4.2 MintUI 框架介绍Github 仓储地址 Mint-UI官方文档 4.2.1 css组件使用123456789101112131415161718192021222324252627282930311.安装MintUI npm install mint-ui -S2.main.js 导入MintUI，并注册到Vue import Vue from 'vue' import Mint from 'mint-ui'; import app from \"./app.vue\" Vue.use(Mint); var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, render:e=&gt;e(app) &#125;) 3.main.js 导入MintUI的样式 import 'mint-ui/lib/style.css' 4.app.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;app组件&lt;/h1&gt; &lt;mt-button type=\"primary\" size=\"large\" plain&gt;primary&lt;/mt-button&gt; &lt;mt-button type=\"danger\" size=\"small\" disabled&gt;danger&lt;/mt-button&gt; &lt;mt-button type=\"danger\" icon=\"more\" @click=\"show\"&gt;more&lt;/mt-button&gt; &lt;/div&gt;&lt;/template&gt; 4.2.2 js组件使用-toast123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#在上面代码的基础上#app.vue&lt;template&gt; &lt;div&gt; &lt;h1&gt;app组件&lt;/h1&gt; &lt;mt-button type=\"primary\" size=\"large\" plain&gt;primary&lt;/mt-button&gt; &lt;mt-button type=\"danger\" size=\"small\" disabled&gt;danger&lt;/mt-button&gt; &lt;mt-button type=\"danger\" icon=\"more\" @click=\"show\"&gt;more&lt;/mt-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 按需导入 Toast 组件 import &#123; Toast &#125; from \"mint-ui\"; export default &#123; data() &#123; return &#123; toastInstanse: null &#125;; &#125;, created() &#123; &#125;, methods:&#123; show()&#123; if(this.toastInstanse)&#123; return; &#125; this.toastInstanse = Toast(&#123; message: \"这是消息\", duration: -1, // 如果是 -1 则弹出之后不消失 position: \"top\", iconClass: \"glyphicon glyphicon-heart\", // 设置 图标的类 className: \"mytoast\" // 自定义Toast的样式，需要自己提供一个类名 &#125;); setTimeout(()=&gt;&#123; this.toastInstanse.close(); this.toastInstanse = null; &#125;,1000) &#125; &#125; &#125;;&lt;/script&gt;&lt;!--注意：这边style不需要加scoped，scoped样式只能作用于当前组件，不能作用于当前组件的子组件--&gt;&lt;style&gt; .mytoast&#123; color: red!important; &#125;&lt;/style&gt;#注意：toast中不自带字体图标，所以我们使用bootstrap中的字体图标//1.安装 npm install bootstrap@3.3.5//2.main.js中引入boostrap样式 import 'bootstrap/dist/css/bootstrap.css' 4.2.3 按需导入组件​ 如果完全导入Mint UI，打包后的bundle.js有将近1.5M，为了减少打包后的体积，我们可以进行按需导入。 http://mint-ui.github.io/docs/#/zh-cn2/quickstart 12345678910111213141516171819202122232425262728293031//1.安装babel-plugin-component插件 npm install babel-plugin-component -D//2.修改babel的配置文件 &#123; \"presets\": [\"env\", \"stage-0\"], \"plugins\": [\"transform-runtime\", [\"component\", [ &#123; \"libraryName\": \"mint-ui\", \"style\": true &#125; ]]] &#125; //3.修改main.js import Vue from 'vue' //按需导入button import &#123; Button&#125; from 'mint-ui' import 'mint-ui/lib/style.css' import 'bootstrap/dist/css/bootstrap.css' import app from \"./app.vue\" //注册button Vue.component(Button.name, Button) var vm = new Vue(&#123; el: '#app', data: &#123; msg: '123' &#125;, render:e=&gt;e(app) &#125;) 4.3 使用 MUI 组件官网首页 文档地址 4.3.1 MUI和Mint-UI区别​ MUI不同于Mint-UI，MUI只是一套开发出来的代码片段，配套了样式和html代码，类似于bootstrap。而Mint-UI是真正的vue组件，可以无缝的和vue项目集成开发。因此从体验上，Mint-UI体验更好，因为这是已经封装好的vue组件。理论上，任何项目都可以使用bootstrap和MUI，而Mint-UI只适用于vue 4.3.2 MUI的使用​ MUI不能使用npm进行下载，需要手动下载然后导入到项目。 ​ 由于MUI不是vue组件，因此不需要导入组件库然后注册组件，只需要导入样式之后就可以在页面使用了。 1234567891011121314151617181920212223242526272829303132#1. 将MUI下的fonts\\css\\js文件放入到项目的lib目录下#2.main.js引入MUI的样式 import \"../lib/mui/css/mui.css\"#3.app.vue中使用MUI的组件&lt;template&gt; &lt;div&gt; &lt;h1&gt;app组件&lt;/h1&gt; &lt;mt-button type=\"primary\" size=\"large\" plain&gt;primary&lt;/mt-button&gt; &lt;mt-button type=\"danger\" size=\"small\" disabled&gt;danger&lt;/mt-button&gt; &lt;mt-button type=\"danger\" icon=\"more\" @click=\"show\"&gt;more&lt;/mt-button&gt; &lt;!--引入MUI组件--&gt; &lt;form class=\"mui-input-group\"&gt; &lt;div class=\"mui-input-row\"&gt; &lt;label&gt;用户名&lt;/label&gt; &lt;input type=\"text\" class=\"mui-input-clear\" placeholder=\"请输入用户名\"&gt; &lt;/div&gt; &lt;div class=\"mui-input-row\"&gt; &lt;label&gt;密码&lt;/label&gt; &lt;input type=\"password\" class=\"mui-input-password\" placeholder=\"请输入密码\"&gt; &lt;/div&gt; &lt;div class=\"mui-button-row\"&gt; &lt;button type=\"button\" class=\"mui-btn mui-btn-primary\" &gt;确认&lt;/button&gt; &lt;button type=\"button\" class=\"mui-btn mui-btn-danger\" &gt;取消&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt;&lt;/template&gt;#注意点：MUI中有字体图标，所以需要在webpack.config.js中添加下面的url加载规则&#123; test: /\\.(png|jpg|gif|ttf)$/, use: 'url-loader' &#125; #","categories":[],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"http://yoursite.com/tags/Webpack/"}]},{"title":"前端安全","date":"2018-05-01T16:00:00.000Z","path":"2018/05/02/前端安全/","text":"XSS CSRF XSSXSS是什么XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 12示例：&lt;script&gt;alert(document.cookie)&lt;/script&gt; 特点能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击。&lt;攻击代码不一定（非要）在 中&gt; 原因 Web浏览器本身的设计不安全。浏览器能解析和执行JS等代码，但是不会判断该数据和程序代码是否恶意。 输入和输出是Web应用程序最基本的交互，而且网站的交互功能越来越丰富。如果在这过程中没有做好安全防护，很容易会出现XSS漏洞。 程序员水平参差不齐，而且大都没有过正规的安全培训，没有相关的安全意识。 XSS攻击手段灵活多变。 危害 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力 盗窃企业重要的具有商业价值的资料 非法转账 强制发送电子邮件 网站挂马 控制受害者机器向其它网站发起攻击 如何防范 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了. 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。 对数据进行Html Encode 处理 过滤或移除特殊的Html标签， 例如: , , &lt; for &lt;, &gt; for &gt;, &amp;quot for 过滤JavaScript 事件的标签。例如 “onclick=”, “onfocus” 等等。 参考资料：https://www.cnblogs.com/phpstudy2015-6/p/6767032.htmlhttps://www.cnblogs.com/443855539-wind/p/6055816.htmlhttps://baike.baidu.com/item/XSS%E6%94%BB%E5%87%BB/954065?fr=aladdin CSRFCSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本（XSS），但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 特点 依靠用户标识危害网站 利用网站对用户标识的信任 欺骗用户的浏览器发送HTTP请求给目标站点 另外可以通过IMG标签会触发一个GET请求，可以利用它来实现CSRF攻击。 防御 通过referer、token或者验证码来检测用户提交。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用post操作 。 避免全站通用的cookie，严格设置cookie的域。","categories":[],"tags":[{"name":"前端安全","slug":"前端安全","permalink":"http://yoursite.com/tags/前端安全/"}]},{"title":"第一个Angular项目","date":"2018-04-25T16:00:00.000Z","path":"2018/04/26/第一个Angular项目/","text":"第一个Angular项目基本步骤创建项目:ng new 添加组件:ng generate component 统一预览:ng serve –open –port 4200 打包部署:ng build 目录结构package.json插件下载详情 angular.jsonindex:启动页面 main:脚本入口 styles:外部样式 ​ 全局样式 scripts:第三方脚本 src(源码)index.htmlmain.jsstyle.cssappangular代码文件app.module.ts—–&gt;引导模块bootstrap:指定根组件 declarations:注册自定义组件 providers:注册全局服务 assets:静态资源项目框架ModelComponent：组件Component Directive Pipe service：服务Router：路由","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"Component","date":"2018-04-14T16:00:00.000Z","path":"2018/04/15/Component/","text":"Component组件angular项目的基本单元 意义复用 易于扩展 创建组件ng generate component 文件夹/组件名 注意：组件名小写，中间用中划线分割 组件的组成物理结构html css ts 逻辑结构注解（组件声明）注意：标签名用特定的前缀 ​ 视图和样式可以使用内部也可以使用外部的 控制器：组件类：处理外界逻辑的视图html文件HTML元素Angular元素123456789101112插值表达式：&#123;&#123;常量，变量或者表达式&#125;&#125;指令：实现特定的行为的属性或者标签，组件是一种特殊的指令 管道：格式化输出，格式化方法 管道号 | 组件：component注：模板变量：命名：#名称-----》Dom对象 作用域--》视图模板 css文件数据绑定数据传递的方式单向传递控制器-&gt;视图模板—》插值表达式：当绑定的是boolean 类的属性时候，会失效（属性绑定） 属性绑定：[属性]=”常量，变量或者表达式” 样式绑定：ng-class,ng-style—&gt; [ngClass]=’类名’。类名可以字符串常量，变量- [ngClass]={‘类名1’，’类名2’……..} [ngClass]={‘类名1’：boolean,’类名2’：boolean…….} ​ 视图模板-》控制器—》事件视图：(事件名)=’方法’ 控制器：事件处理的方法 注：模板中加$event ​ 控制器中加Event:对象 双向传递控制器视图模板 实现[(ngModel)]=”变量” 注：引入内置的FormsMoudel模板ngModel通常绑定表单控件上（input,textarea,select） 组件的交互父组件-&gt;子组件Input属性：接受父组件传递的值用法：子组件属性上添加Input注解：@Input()，@Input(‘属性别名’)注：输入属性可以有，也可以没有，也可以有多个 ​ 输入的属性可以是基本类型，也可以是引用类型 子组件-&gt;父组件Output属性：子组件向父组件以事件的方式传递数据实现：创建事件：EventEmmit Output注解 触发事件emit（参数） 监听事件父组件中（事件）=’方法‘ ViewChild注解功能：父组件调用子组件方法或者成员 实现：父组件中 @ViewChild(子组件类型) 特点：相比于Input属性，保护子组件中的属性","categories":[],"tags":[{"name":"Angular","slug":"Angular","permalink":"http://yoursite.com/tags/Angular/"}]},{"title":"初识angular","date":"2018-04-09T16:00:00.000Z","path":"2018/04/10/初识angular/","text":"初识angular定义Google javascript（angular1.x）或者TypeScript( angular2.0以上 ):编写所用语言 SPA:单页面 MVVM模式：M（model）V (view) VM(将后台数据显示到前端页面上中间的处理相当于controller) 优势跨平台 速度与性能 组件化 兼容性好 准备工作node+npm+git全局安装typeScriptnpm install -g typescript (推荐查看typescript中文网)注：angular版本angular1.x ————&gt;javascript ​ angular&gt;=2.0——–&gt;typescript 全局安装angular/cliangular命令行工具，快速构建angular项目工具安装npm install -g @angular/cli npm install -g @angular/cli @版本号 注意：ng –version查看angular版本号 ​ ng help 常用命令创建项目：ng new 项目名称 ng generate(g)组件 ，服务，类,管道 ——–》添加组件 组件：ng g c section-first/home-component 服务：ng g service services/data 管道：ng g pipe pipes/filter 启动项目：ng serve –open –port 4200(默认的，可以改变端口号)； 打包项目：ng build –port -aot 基本概念Module:模块 Service:服务 Router:路由 Component :组件Component Directive指令 Pipe管道","categories":[],"tags":[{"name":"angular","slug":"angular","permalink":"http://yoursite.com/tags/angular/"}]},{"title":"ES6的新特性十一模块","date":"2018-02-24T16:00:00.000Z","path":"2018/02/25/ES6的新特性十一模块/","text":"ES6的新特性十一-模块模块化的实现AMDAMD 即Asynchronous Module Definition，中文名是异步模块定义的意思。它是一个在浏览器端模块化开发的规范 由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出 requireJS主要解决两个问题 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 123456789define(id?, dependencies?, factory);id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）dependencies：是一个当前模块依赖的模块名称数组factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值require()函数接受两个参数第一个参数是一个数组，表示所依赖的模块第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 CMDcommon.jsexport require ES6实现exportimport注：文本即模块 浏览器无法直接使用exprot 和import 通过babel转换 babel： ES6转ES5 具体做法GIt BASH指令1、项目初始化 npm init –y 2、安装本地gulp npm install gulp –save-dev 3、安装babel与babelify npm install –save-dev babelify @babel/core npm install –save-dev @babel/preset-env @babel/preset-react 4、安装打包插件browserify npm install browserify –save-dev 5、安装打包辅助插件vinyl-source-stream npm install vinyl-source-stream –save-dev 6、编写脚本打包任务 gulp.task(‘script’ , function(){ let b = browerify({ entries:’./src/js/app.js’, transform:babelify.configure({ presets: [“@babel/preset-env”, “@babel/preset-react”] }) }); b.bundle() .pipe(source(&apos;bundle.js&apos;)) .pipe(gulp.dest(&apos;dist/js/&apos;)); }); 注：可以添加脚本压缩 gulpfile.js12345678910111213141516171819202122232425262728var gulp = require(&apos;gulp&apos;);var babelify = require(&apos;babelify&apos;);var browserfiy = require(&apos;browserify&apos;);var source = require(&apos;vinyl-source-stream&apos;);var uglify = require(&apos;gulp-uglify-cli&apos;);gulp.task(&apos;html&apos; , function()&#123; gulp.src(&apos;./src/index.html&apos;) .pipe(gulp.dest(&apos;./dist/&apos;));&#125;);gulp.task(&apos;script&apos; , function()&#123; browserfiy(&#123; entries:[&apos;./src/js/app.js&apos;] &#125;) .transform(babelify.configure(&#123; presets: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;] &#125;)) .bundle() .pipe(source(&apos;bundle.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;./dist/js/&apos;));&#125;);gulp.task(&apos;default&apos; , [&apos;html&apos; , &apos;script&apos;] , function()&#123; gulp.watch(&apos;./src/js/*.js&apos; , [&apos;script&apos;]);&#125;); ajax.js123456789101112131415161718var value = 100;const URL_ROOT = &apos;http://&apos;; // 导出常量function getJson()&#123; // 导出函数 console.log(&apos;函数&apos;);&#125;class Person&#123; constructor(name)&#123; this.name = name; &#125; sayHi()&#123; console.log(&apos;类&apos;); &#125;&#125;export &#123;URL_ROOT , getJson, Person&#125;// export default &#123;URL_ROOT , getJson , Person&#125;; app.js1234567891011import &#123;URL_ROOT , Person ,getJson&#125; from &apos;./ajax&apos;;console.log(URL_ROOT);getJson();new Person().sayHi();// import ajax from &apos;./ajax&apos;;// console.log(ajax.URL_ROOT);// ajax.getJson();// let person = new ajax.Person();// person.sayHi(); index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;js/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6新特性九iterator迭代器","date":"2018-02-18T16:00:00.000Z","path":"2018/02/19/ES6新特性九iterator迭代器/","text":"ES6新特性九iterator迭代器问题for-of可以遍历Array，set 和Map ，但是不能遍历ObjectObject 没有实现iterator接口iterator实现要点实现Symbol.iterator方法返回对象实现next 方法next方法返回值必须是对象（done,value):done是false代表有值，done为true代表结尾 案例一1234567891011121314151617181920let arr = [&apos;A&apos; , &apos;B&apos; , &apos;C&apos;]; for(let value of arr)&#123; console.log(value); &#125; console.warn(&apos;&apos;); let it = arr[Symbol.iterator](); let temp = it.next(); console.log(temp); temp = it.next(); console.log(temp); temp = it.next(); console.log(temp); temp = it.next(); console.log(temp); 案例二具体的实现原理12345678910111213141516171819202122232425262728293031323334let person = &#123; name:&apos;Rose&apos;, age : 18, sayHi:function()&#123; &#125;, [Symbol.iterator]:function()&#123; let self = this; let keys = Object.keys(self); let index = 0; return &#123; next:function()&#123; if(index &lt; keys.length)&#123; let result = &#123; value:[keys[index] , self[keys[index]]], done:false &#125;; index++; return result; &#125; return &#123; done:true &#125;; &#125; &#125;; &#125; &#125;; for(let [key,value] of person)&#123; console.log(key , value); &#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性八promise","date":"2018-02-17T16:00:00.000Z","path":"2018/02/18/ES6的新特性八-promise/","text":"ES6新特性八：promise功能异步处理方案：相比回调，结构更加的清晰定义存储多个等待的执行方法的容器待执行方法对象基本的使用方法创建promise的对象new Promise(匿名函数)；注：匿名函数通常是带有两个参数的方法即function(resolve,reject); 调用promise相关的方法，完成相应的功能：promise.then()——成功时候调用和promise.catch()——–失败时候调用 案例一1234567891011121314151617181920var showData = function(ms)&#123; var promise = new Promise( function(resolve)&#123; setTimeout(function()&#123; resolve(); &#125; , ms); &#125;); return promise; &#125; showData(2000).then(() =&gt; &#123; console.log(1); return showData(200); &#125;).then(() =&gt; &#123; console.log(2); return showData(20); &#125;).then(() =&gt; &#123; console.log(3); &#125;); 经典案例按顺序加载图片，第一张没有加载成功下一张不可以加载123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;button&gt;加载图片&lt;/button&gt; &lt;div&gt; &lt;img src=&quot;#&quot; width=&quot;128&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;#&quot; width=&quot;128&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;#&quot; width=&quot;128&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;script&gt; let image1 = &apos;http://101.200.58.3/app/img/test1.jpg&apos;; let image2 = &apos;http://101.200.58.3/app/img/test2.jpg&apos;; let image3 = &apos;http://101.200.58.3/app/img/test3.jpg&apos;; let btnLoad = document.querySelector(&apos;button&apos;); let images = document.querySelectorAll(&apos;img&apos;); btnLoad.onclick = function()&#123; loadImage(image1) .then((res) =&gt; &#123; images[0].src = res.src; return loadImage(image2); &#125;).then((res) =&gt; &#123; images[1].src = res.src; return loadImage(image3); &#125;).then((res) =&gt; &#123; images[2].src = res.src; &#125;); &#125; /* 请求图片资源 */ function loadImage(url)&#123; let p = new Promise((resolve , reject) =&gt; &#123; let image = new Image(); image.onload = function()&#123; resolve(image); &#125; image.onerror = function()&#123; reject(&apos;load image fauilre&apos;); &#125; image.src = url; &#125;); return p; &#125; &lt;/script&gt; 扩展方法Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。案例二1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;button&gt;加载图片&lt;/button&gt; &lt;div&gt; &lt;img src=&quot;#&quot; width=&quot;128&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;#&quot; width=&quot;128&quot; alt=&quot;&quot;&gt; &lt;img src=&quot;#&quot; width=&quot;128&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;script&gt; let image1 = &apos;http://101.200.58.3/app/img/test1.jpg&apos;; let image2 = &apos;http://101.200.58.3/app/img/test2.jpg&apos;; let image3 = &apos;http://101.200.58.3/app/img/test3.jpg&apos;; let btnLoad = document.querySelector(&apos;button&apos;); let images = document.querySelectorAll(&apos;img&apos;); btnLoad.onclick = function()&#123; let p1 = loadImage(image1); let p2 = loadImage(image2); let p3 = loadImage(image3); let promise = Promise.all([p1 , p2 , p3]); promise.then((res) =&gt; &#123; for(let i = 0 ;i &lt; res.length; i++)&#123; images[i].src = res[i].src; &#125; &#125;); &#125;; /* 请求图片资源 */ function loadImage(url)&#123; let p = new Promise((resolve , reject) =&gt; &#123; let image = new Image(); image.onload = function()&#123; resolve(image); &#125; image.onerror = function()&#123; reject(&apos;load image fauilre&apos;); &#125; image.src = url; &#125;); return p; &#125; &lt;/script&gt; Promise.race顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;success&apos;) &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&apos;failed&apos;) &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 打开的是 &apos;failed&apos;&#125;) 不足状态不可控制观察者模式rxjx","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性七oop","date":"2018-02-15T16:00:00.000Z","path":"2018/02/16/ES6的新特性七oop/","text":"ES6新特性七：opp类和对象对象，建和值得结合，其中key为字符串，值为任意值类的成员实例成员构造方法：constructor 属性 方法 语法：class类名 静态成员属性:类名，成员名 方法：static 案例一ES5中类的写法12345678910111213function Person(name , age)&#123; this.name = name; this.age = age; &#125; Person.COUNT = 10; //静态方法地创建 Person.hello = function()&#123; console.log(&apos;Hello,我是小静&apos;); &#125; //实例方法地创建 Person.prototype.sayHi = function()&#123; console.log( this.name + &apos;-&apos; + this.age); &#125; 案例二ES6中类的写法123456789101112131415161718 class Person&#123; constructor(name = null, age = 0)&#123; this.name = name; this.age = age; &#125; sayHi()&#123; console.log( this.name + &apos;-&apos; + this.age); &#125; static hello()&#123; console.log(&apos;Hello,我是小静 , &apos; , Person.count); &#125;&#125;var person = new Person(&apos;Rose&apos; , 18);person.sayHi();Person.hello(); 案例三java中的类写法1234567891011121314class Person&#123; public string name; public int age; public Person(name,age)&#123; this.name=name; this.age=age; &#125; public void sayHi()&#123; System.out.println(&quot;hi”)； &#125; public static void hello()&#123; System.out.println(&quot;hello&quot;)； &#125;&#125; 案例四php中类的写法12345678910111213141516class Person&#123; private $name=null; private $age=0; function __constructor($name)&#123; $this-&gt;name=$name; &#125; function setAge($age)&#123; $this-&gt;age=$age; &#125; function getAge()&#123; echo $name.&quot;今年&quot;.$age.&quot;岁了&quot;; &#125;&#125;$p=new Person();$p-&gt;setAge(15);$p-&gt;getAge(); 三大特性封装保护成员，安全setter,getter访问器set负责赋值，setter访问需要参数 get负责取值，getter必须有return返回值 可以只有setter,也可以只有getter 继承减少代码，实现复用实现 ：extends父类super:调用父类元素ES5中的继承写法12345678910111213141516function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.protoType.sayHi=function()&#123; console.lgo(&quot;我的名字”+this.name+&quot;你好&quot;);&#125;function Json(name,age,like)&#123; Person.call(this,name,age); this.like=like;&#125;Json.prototype=Object.create(Person.prototype) Json.prototype.contructor = Json;var child = new Child(&apos;Rose&apos; , 18 , &quot;eat&quot;);child.sayHi(); ES5中的继承方法二写法123456789101112131415function Person(name,age)&#123; this.name=name; this.age=age;&#125;Person.protoType.sayHi=function()&#123; console.lgo(&quot;我的名字”+this.name+&quot;你好&quot;);&#125;function Json(name,age,like)&#123; Person.call(this,name,age); this.like=like;&#125;Json.prototype=new Person()var child = new Child(&apos;Rose&apos; , 18 , &quot;eat&quot;);child.sayHi(); ES6中的继承的写法123456789101112131415161718192021class Parent&#123; constructor(name = null)&#123; this.name = name; &#125; hello()&#123; console.log(&apos;大家好，我是&apos; + this.name); &#125; &#125; class Child extends Parent&#123; constructor(name = null , age = 0)&#123; super(name); this.age = age; &#125; hello()&#123; console.log(&apos;我是&apos; + this.name + &apos;，今年芳龄：&apos; + this.age); &#125; &#125; var child = new Child(&apos;Rose&apos; , 18); child.hello(); 多态方法：方法的多样性，扩展实现：实现父类的签名（函数—+参数）相同的方法就是讲父类中的方法重新的写一遍，而且方法名不变，参数不变，只能改变里面的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 //1 父类 class Shape&#123; constructor(color = &apos;黑色&apos;)&#123; this.color = color; &#125; draw()&#123; // &#125; &#125; // 2 子类 class Rectangle extends Shape&#123; constructor(color = &apos;黑色&apos; , length = 0 , width = 0)&#123; super(color); this.length = length; this.width = width; &#125; draw()&#123; console.log(`绘制了一个长为$&#123;this.length&#125; 宽为$&#123;this.width&#125; 颜色为$&#123;this.color&#125;的矩形`); &#125; &#125; class Circle extends Shape&#123; constructor(color = &apos;黑色&apos; , radius = 0)&#123; super(color); this.radius = radius; &#125; // override(重写) (overloadding(重载)) draw()&#123; console.log(`绘制了一个半径为$&#123;this.radius&#125; 颜色为$&#123;this.color&#125;的圆`); &#125; &#125; /* * ES5 * */ function Shape(color)&#123; this.color = color; &#125; Shape.prototype.draw = function()&#123; &#125; function Rectangle(color , width ,length)&#123; Shape.call(this , color); this.width = width; this.length = length; &#125; Rectangle.prototype = Object.create(Shape.prototype); // property(属性) Rectangle.prototype.constructor = Rectangle; Rectangle.prototype.draw = function()&#123; console.log(`绘制了一个长为$&#123;this.length&#125; 宽为$&#123;this.width&#125; 颜色为$&#123;this.color&#125;的矩形`); &#125; let rect = new Rectangle(&apos;红色&apos; , 12 , 24);// let circle = new Circle(&apos;蓝色&apos; , 5); rect.draw();// circle.draw();","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性六内置对象","date":"2018-02-13T16:00:00.000Z","path":"2018/02/14/ES6的新特性六-内置对象/","text":"ES6新特性：内置对象Object简洁写法案例一成员名和成员值都来自一个变量的时方法省略function 1234567891011let name=&quot;张山&quot;;let age=&quot;12&quot;;let person=&#123; name; age; sayHi()&#123; console.log(&quot;你好&quot;); &#125;&#125;person.sayHi(); 扩展方法：静态方法 获取对象的成员Object.entries(),Object.keys(),Object.values() 案例二for-in循环遍历对象无法遍历【symbol.for()】定义的成员名12345678910111213141516171819202122232425let name = &apos;Rose&apos;;let age = 18;let person = &#123; name:name, age, sayHi()&#123; console.log(this.name); &#125;, [Symbol.for(&apos;KeyA&apos;)]:function()&#123; &#125;&#125;;for(let value in person)&#123; console.log(value);&#125;var keys = Object.getOwnPropertySymbols(person);console.log(keys)---&gt;[Symbol(KeyA)]//结果nameagesayHi 案例三用for-of遍历对象的时候会出错：person is not iterable123456789101112131415let name = &apos;Rose&apos;;let age = 18;let person = &#123; name:name, age, sayHi()&#123; console.log(this.name); &#125;, [Symbol.for(&apos;KeyA&apos;)]:function()&#123; &#125;&#125;;for(let value of person)&#123; console.log(value);&#125; 案例四解决for-of无法遍历对象的方法：Object.entries()123456789101112131415let name = &apos;Rose&apos;;let age = 18;let person = &#123; name:name, age, sayHi()&#123; console.log(this.name); &#125;, [Symbol.for(&apos;KeyA&apos;)]:function()&#123; &#125;&#125;;for(let [key,value] of Object.entries(person))&#123; console.log(key,value);&#125; 案例五Object.keys(对象)获取对象的属性名集合123456789101112131415161718192021222324let name = &apos;Rose&apos;;let age = 18;let person = &#123; name:name, age, sayHi()&#123; console.log(this.name); &#125;, [Symbol.for(&apos;KeyA&apos;)]:function()&#123; &#125;&#125;;let keys = Object.keys(person);console.log(keys)------------&gt;[&quot;name&quot;, &quot;age&quot;, &quot;sayHi&quot;]for(let key of keys)&#123; console.log(key , person[key]);&#125;//结果name Roseage 18sayHi ƒ sayHi()&#123; console.log(this.name); &#125; 案例六Object.values(对象)获取属性值得集合1234567891011121314151617let name = &apos;Rose&apos;;let age = 18;let person = &#123; name:name, age, sayHi()&#123; console.log(this.name); &#125;, [Symbol.for(&apos;KeyA&apos;)]:function()&#123; &#125;&#125;;console.warn(&apos;&apos;);let values = Object.values(person);for(let value of values)&#123; console.log(value);&#125; 案例七Object.assign:复制或者合并对象：注浅克隆浅克隆只是针对对象，数组函数等复杂的数据 简单的来说浅克隆就是说两个变量指向同一块内存，一个变另一个也变 深克隆就是创建一个新的对象，开辟一个新的空间，然后将原对象的数据全部复制过去，完全的切断两个对象之间的联系。 es5代码实现深克隆123456789101112131415161718192021222324let person = &#123; name:&apos;Rose&apos;, address:&#123; province:&apos;江苏&apos;, city:&apos;无锡&apos; &#125;, sayHi()&#123; console.log(this.name); &#125;&#125;;let jsonString = JSON.stringify(person);let clonePerson = JSON.parse(jsonString); console.warn(&apos;原始值&apos;);console.log(person , clonePerson);clonePerson.name = &apos;mike&apos;;clonePerson.address.city = &apos;苏州&apos;;console.warn(&apos;修改后&apos;);console.log(person , clonePerson); es6.Object.assgin123456789101112131415161718192021222324let person = &#123; name:&apos;Rose&apos;, address:&#123; province:&apos;江苏&apos;, city:&apos;无锡&apos; &#125;, sayHi()&#123; console.log(this.name); &#125; &#125;; var clonePerson = &#123; age:100 &#125;; Object.assign(clonePerson , person); console.warn(&apos;原始值&apos;); console.log(person , clonePerson); clonePerson.name = &apos;mike&apos;; clonePerson.address.city = &apos;苏州&apos;; console.warn(&apos;修改后&apos;); console.log(person , clonePerson); #### 集合扩展array扩展Array静态方法：Array.isArray:判断是否是数组数组判断的几种方法console.log(Array.isArray([])); console.log([] instanceof Array); console.log(Object.prototype.toString.call([]) === &apos;[object Array]&apos;); console.log([].constructor === Array); Array.of创建数组 new Array(一个整数)123456let arr = new Array(6);let arr2 = Array.of(6);console.log(arr , arr2);结果Array(6)----&gt;表示数组长度为6，但是没有值Array(1)-----&gt;有一个具体的值，而且长度为1 Array.from:克隆或者合并数组——浅克隆123456789101112var arr = [10 , 20 , 30 , [40 , 50]];var cloneArr = Array.from(arr);console.warn(&apos;&apos;);console.log(arr , cloneArr);//改变数组中的值但是cloneArr不会发生改变cloneArr[3][1] = 500;console.warn(&apos;&apos;);console.log(arr , cloneArr); Array实例方法arr.filter()过滤数组中的数据类似于sql中where得到结果是一组满足条件的数组即let arr2=arr.filter(function(item){ return item&gt;74})1234567891011121314let arr = [52 , 34 , 24 , 89 , 64 , 48 , 64]; let index = arr.indexOf(64); console.log(index);--&gt;4 //得到一组满足条件的数组 let rs = arr.filter((item) =&gt; item &gt; 34); console.log(rs);---&gt;[52, 89, 64, 48, 64] //es6新增的findindex方法用来查询满足条件的一个内容，但是只是返回下标 let index2 = arr.findIndex((item) =&gt; item == 74); console.log(index2);--&gt;-1 //查看数组中是否包含指定的内容 let flag = arr.includes(64); console.log(flag);-----&gt;true 现在我们思考一个问题：如果面试的时候，面试官让你快速的实现将数组去重，你会怎么处理初学者肯定想用for循环的方法一个一个的遍历，然后对比，将满足条件的值放到另一个数组中，这样可以实现面试官的问题，但是你绝对没有满足面试官的想法，Es6Array新增了set方法可以实现这个功能1)创建一个new Set(数组);2)存储数组add3)移除数组delete(),clear()4)遍历for-of案例如下123456let arr = [70 , 60 , 10 , 20 , 30 , 60 , 20 , 30];let set = new Set(arr);console.log(set)---------&gt;&#123;70, 60, 10, 20, 30&#125;for(let value of set)&#123; console.log(value);&#125; 存储数据add 当添加的数据和数组中其他数据一样时，不添加此数值123456789101112131415161718192021 let set = new Set();set.add(10);set.add(true);set.add(null);set.add(&quot;字符串&quot;); console.warn(&apos;&apos;);for(let value of set)&#123; console.log(value);-----&gt;10,true,null&#125;set.add(10);set.add(null);set.add(&#123;&#125;);console.warn(&apos;&apos;);for(let value of set)&#123; console.log(value);--------》10,true,null，&#123;&#125;&#125; 清除数组delete 和clear,delete是清除指定的数据而且对象数据去不了clear是清空set123456789let arr=[10,null,&#123;&#125;];set.delete(10);set.delete(&#123;&#125;);console.warn(&apos;&apos;);for(let value of set)&#123; console.log(value);-----&gt;null,&#123;&#125;&#125;set.clear();console.log(set);------------&gt;Set(0) &#123;&#125; Map:键和值的集合（key:value)注：1）key不可以重复，2）object的key只能为string，但是map的key可以是任意的类型基本用法1）创建Map:new Map() ​ new Map([key,value]) 2)操作：a)创建数据：map.set（key,value) key和value可以是任意的类型，key不可以重复 ​ b)读取数据 : map.get(key) 如果key不存在，返回undefined ​ c)移除数据 : map.delete(key), key为引用类型的时候和set.delete一样都移除不了 ​ d)清空数据： map.clear() ​ e)可以用for-of遍历 for（let [key,value] of map){} 12345678910111213141516171819202122232425let map = new Map(); map.set(10 , &quot;Value&quot;); map.set(&apos;Value&apos; , 10); map.set(true , &#123;&#125;); map.set(&#123;&#125; , true); map.set(null , []); map.set(null , &quot;????&quot;); map.set(true , &apos;boolean&apos;); console.warn(&apos;&apos;); for(let [key , value] of map)&#123; console.log(key , value); &#125; console.warn(&apos;&apos;); console.log(map.get(null)); console.log(map.get(&apos;&apos;)); map.delete(null); map.delete(&#123;&#125;); console.warn(&apos;&apos;); for(let [key , value] of map)&#123; console.log(key , value); &#125; map.clear(); String新添加的方法startWiths,endWiths,include Number新添加的方法isInteger","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性五函数","date":"2018-02-10T16:00:00.000Z","path":"2018/02/11/ES6的新特性五-函数/","text":"箭头函数(参数列表)=&gt;语句案例一1234567891011//es5中的函数写法var add = function(a , b)&#123; var result = a + b; return result;&#125; //es6中的函数新的写法var add = (a , b) =&gt; &#123; var result = a + b; return result;&#125;; 注：如果没有形参的时候也不能省略（）​ 如果函数中只有一条带有return的函数时可以省略{}如下案例二 ​ 箭头函数的this是由定义函数的时所在的执行环境 案例二12345678//es5中的写法var add=function(a,b)&#123; return a+b;&#125;console.log(add(1,2));---------&gt;3//es6中的写法var add=(a,b)=&gt;a+b;console.log(add(1,2));------&gt;3 参数参数可以有默认值：默认值有（number,boolean,string,引用类型） ​ number:0, boolean:false, string:” “或者null 引用类型 ：null 带有默认值的放在后面，没有默认值的放在前面 案例三 12345678910111213141516171819202122232425function foo(a = 0, b = 0, c = 0 , ...args)&#123; // arguments(假数组) var result = a + b + c; console.log(result); console.log(args);&#125;foo();foo(100);foo(100 , 200);foo(100 , 200 , 300 , 400);foo(100 , 200 , 300 , 400 , 500 , 600); 0 Array(0) 100 Array(0) 300 Array(0) 600 Array(1) 600 Array(3)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性四for-of","date":"2018-02-08T16:00:00.000Z","path":"2018/02/09/ES6的新特性四for-of/","text":"特性四：for-of循环数组：最基本的for循环，forEach,现在es6中新增了一个新的特性for-of案例案例一 下面的代码让我们先回顾一下forEach的用法 1234let arr=[100,200,150,251];forEach(function(item,index)&#123; console.log(item,index);--------------&gt;100,0 200,1 150,2 251,3&#125;) 案列二通过for-of的方法来实现这个功能 1234let arr = [100 , 200 , 300];for(let value of arr)&#123; console.log(value);-----------&gt;100,200,300&#125; 注：for-of不等于for-in,for-of是无法遍历对象的 案例三如果需要让对象支持for-of,我们可以使用Object.entries(对象)的方法 12345678var person = &#123; name:&apos;Rose&apos;, age:100 &#125;; for(let [key,value] of Object.entries(person))&#123; console.log(key,value);---------------&gt;name rose age 100 &#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性三解构和赋值","date":"2018-02-07T16:00:00.000Z","path":"2018/02/08/ES6的新特性三解构和赋值/","text":"解构赋值快速获取数组或者对象中的值得方式 数组解构：语法 【变量， ， ，】=数组案例 案例一1234let arr = [100 , 200 , 300 , 1 , 214];[a , , , b ,c , d = 800, e = 1000] = arr;console.log(a , b , c , d , e);------------》100 1 214 800 1000 案例二123let arr = [100 , 200 , 300 , 1 , 214];[a , ...b ] = arr;console.log(a , b);---------》100 (4) [200, 300, 1, 214] 对象解构：{变量名，变量名，，，}=对象案例案例一12345678let person = &#123; name:&apos;Rose&apos;, age:18, address:&apos;无锡&apos; &#125;; let &#123;name , age , address&#125; = person; console.log(name , age , address);----------&gt;Rose 18 无锡 案例二12345678910let name = &apos;Rose&apos;;let age = 18;let address = &apos;无锡&apos;;person = &#123; name:name, age:age, address:address&#125;;console.log(person);-------》&#123;name: &quot;Rose&quot;, age: 18, address: &quot;无锡&quot;&#125; 案例三ES6中档对象属性名和属性值相同的时候可以省略属性名 12345678910let name = &apos;Rose&apos;;let age = 18;let address = &apos;无锡&apos;;let person = &#123; name, age, address&#125;;console.log(person);----------------》&#123;name: &quot;Rose&quot;, age: 18, address: &quot;无锡&quot;&#125;","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性二let和const","date":"2018-02-06T16:00:00.000Z","path":"2018/02/07/ES6的新特性二let和const/","text":"ES6的新特性二let和const作用域全局作用域， 局部作用域， 块级作用域 案例案例一目的点击按钮分别输出1,2,3 1234567891011121314&lt;button&gt;按钮一&lt;/button&gt;&lt;button&gt;按钮二&lt;/button&gt;&lt;button&gt;按钮三&lt;/button&gt;&lt;script&gt; var buttons = document.querySelectorAll(&apos;button&apos;); for(var i = 0 ;i &lt; buttons.length; i++)&#123; (function(index)&#123; buttons[index].onclick = function(e)&#123; console.log(index+1); &#125; &#125;)(i); &#125; // console.log(i);----&gt;输出的是3 以上代码通过闭包的方法实现了以上的目的 案例二let 块级作用域只能在{}之间 12345if(true)&#123; let i = 100; console.warn(i);-----&gt;100 &#125; console.log(i);----------&gt;i not defined 案例三当我们使用for循环遍历的时候就很适合用let声明i,避免全局污染 123456let globalValue = 100; for(let i = 0; i &lt; 10 ;i++)&#123; // i作用域 console.log(globalValue)---------》100 &#125; console.log(i);-------------------》i not defined 案例四let和var的区别之一：let不可以重复声明 123let value = 10;let value = &apos;晚上少吃点，注意身材&apos;;console.log(value);---------》value&apos; has already been declared 案例五let 和var的区别之一：暂时性死区 12345678910let value = 200; function foo()&#123; console.log(value);------------------》value is not defined let value = &apos;不用着急，马上吃饭.&apos;; &#125; foo(); Const声明常量：1）声明常量必须赋值，并且后期不可以更改 ​ 2）建议在代码中无法更改的变量都尽量的去使用const 注：基本类型：一旦声明，无法修改 ​ 引用类型：可以修改对象的成员，但是不能为对象重新创建 案例案例一123456789101112const PERSON = &#123; name:&apos;Rose&apos;, age:18 &#125;; console.log(PERSON); PERSON.name = &apos;Jack&apos;; PERSON.age = 100; console.log(PERSON);------------------》&#123;name: &quot;Rose&quot;, age: 18&#125; &#123;name: &quot;Jack&quot;, age: 100&#125; PERSON = &#123;&#125;; // new Object;---------------------》Assignment to constant variable.","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Typescript入门","date":"2018-01-11T16:00:00.000Z","path":"2018/01/12/Typescript入门01/","text":"Typescript入门什么是ts:ES的超集，可以转换成ES5，ES3的代码 —–兼容好 类型化降本语言—-静态类语言—提高开发效率—增强了代码的质量 准备工作线上开发手动搭建环境安装typescript编译器 自动化构建工具gulp 步骤：查看typeScript中文网的辅助教程简单流程如下1）首先全局安装TypeScript和Gulp 1234567npm install -g typescriptnpm intall gulp --global(如果以前按过就不用安了)或者npm install -g gulp-cli 2）安装typescript，gulp和gulp-typescript到开发依赖项。 Gulp-typescript是TypeScript的一个Gulp插件。 1npm install --save-dev typescript gulp gulp-typescript 3）安装Browserify，tsify和vinyl-source-stream。 tsify是Browserify的一个插件，就像gulp-typescript一样，它能够访问TypeScript编译器。 vinyl-source-stream会将Browserify的输出文件适配成gulp能够解析的格式，它叫做vinyl。 1npm install --save-dev browserify tsify vinyl-source-stream 注：browserify:把所有模块捆绑成一个JavaScript文件 ​ tsify是Browserify的一个插件，就像gulp-typescript一样，它能够访问TypeScript编译器 gulpfile.js1234567891011121314151617181920var gulp = require(&quot;gulp&quot;);var browserify = require(&quot;browserify&quot;);var source = require(&apos;vinyl-source-stream&apos;);var tsify = require(&quot;tsify&quot;);var uglify = require(&apos;gulp-uglify-cli&apos;);gulp.task(&quot;copy-html&quot;, function () &#123; return gulp.src(&quot;./src/**/*.html&quot;) .pipe(gulp.dest(&quot;./dist&quot;));&#125;);gulp.task(&quot;default&quot;, [&quot;copy-html&quot;], function () &#123; return browserify(&#123; entries: [&apos;./src/app.ts&apos;], &#125;) //把所有模块捆绑成一个JavaScript文件 .plugin(tsify) //能够访问TypeScript编译器 .bundle() .pipe(source(&apos;bundle.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&quot;./dist&quot;));&#125;); src/ajax.ts12345678910export module ajax&#123; export class Person&#123; constructor(public name:string,public age:number)&#123; &#125; sayHai()&#123; console.log(&quot;你好&quot;); &#125; &#125; &#125; src/app.ts123import &#123;ajax&#125; from &apos;./ajax&apos;let person =new ajax.Person(&quot;张三&quot;,12);person.sayHai(); src/index.html123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; package.json 可以根据这个文件夹npm install 全部的下载所需的插件12345678910111213141516171819202122&#123; &quot;name&quot;: &quot;ts&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;pagefile.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: &#123; &quot;browserify&quot;: &quot;^16.2.3&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-typescript&quot;: &quot;^5.0.0&quot;, &quot;gulp-uglify-cli&quot;: &quot;^1.0.1&quot;, &quot;tsify&quot;: &quot;^4.0.1&quot;, &quot;typescript&quot;: &quot;^3.2.2&quot;, &quot;uglify&quot;: &quot;^0.1.5&quot;, &quot;vinyl-source-stream&quot;: &quot;^2.0.0&quot; &#125;&#125;","categories":[],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"http://yoursite.com/tags/Typescript/"}]},{"title":"JavaScript数据类型和类型检测","date":"2017-12-02T16:00:00.000Z","path":"2017/12/03/数据类型和类型检测/","text":"JavaScript数据类型和类型检测JavaScript数据类型JavaScript数据类型主要分为两大类： 1.基本数据类型：字符串(String)，数字(Number)，布尔(Boolean)，空(Null)，未定义(Undefined)，(Symbol) 注:Symbol 是 ES6 引入的一种新的原始数据类型，表示独一无二的值，在此不作详细介绍。 2.复杂数据类型 (引用数据类型)：对象(Object) 基本类型String&amp;Number123var x; // x 为 undefinedvar x = 1; // x 为 numbervar x = &quot;hi&quot;; // x 为 string Boolean布尔（逻辑）只能有两个值：true 或 false。 Null&amp;Undefined1.Undefined 表示变量声明了但是没有赋值(未初始化)。 2.可以通过将变量的值设置为 null 来清空变量。 12var person = null;console.log(typeof person); // &quot;object&quot; 引用类型除了基本数据类型的数据其他数据都是对象（对象，函数，数组…）。 函数（Function）,数组（Array）都可以归为对象。 对象的基本信息：属性，行为（方法） 对象的类型：1.内置对象（原生对象）=&gt;RegExp，Date，Math…(js语言本身预定义的对象) ​ 2.宿主对象=&gt;BOM对象：History，Location，Window，Navigate，Screen ​ DOM对象：Body，Style，Meta，Frame，Frameset… 常用的Math内置对象：（Math对象中的属性和方法都是静态的，可以通过构造器名称访问，无需创建对象） 123456789Math.pow(n,m) n的m次方Math.sqrt 开根号Math.abs() 取绝对值Math.PI Math.random() 在[0,1）区间内取随机数exp:取10到20之间的随机数=&gt;parseInt(Math.random()*10)+10;Math.cei() 向上取整Math.floor() 向下取整Math.round() 四舍五入 可以通过两种方式访问对象的属性 obj.key obj[“key”] 创建对象的方式1.字面量的方式 1234567var obj = &#123; name:&quot;John&quot;, age:50, eyeColor:&quot;blue&quot;, eat:function()&#123;&#125;, sleep:function()&#123;&#125;&#125;; 2.通过new object创建对象 1234var obj = new Object();obj.name = &quot;Jhon&quot;;obj.age = 50;obj.eat = function()&#123;&#125;; 缺点：如果要创建多个对象，需要写很多重复代码。 3.工厂模式创建对象（用函数对第二种方式进行封装，使得相似对象的创建不需要重复代码） 123456function CreateObject(name,age)&#123; var obj = new Object(); obj.name = &quot;Jhon&quot;; obj.age = 50; return obj;&#125; 缺点：无法判断出所创建出对象的具体类型。 4.构造函数创建对象 12345function Person(name,age)&#123; this.name = name; this.age = age;&#125;var p1 = new Person(&quot;Jhon&quot;,50); //实例化 拓展：遍历数组的方式=&gt;for循环 for(var i=0;i&lt;arr.length;i++){} ​ 遍历对象的方式=&gt;for…in 1234567var Person =&#123; name: &quot;Jhon&quot;, age: 50&#125;for(var key in Person)&#123; console.log(key + &quot;:&quot; + Person.key);&#125; 函数的原型原型的作用：可以将对象所有公共的信息（属性和方法）放到原型对象中去。 如果函数和函数原型中有同名的信息，优先使用对象中的信息。 函数的原型prototype，_ proto _,以及函数本身的关系 123var foo = function()&#123;&#125;; =&gt; Function.prototype._ proto _ =&gt; Object.prototype._ proto _ =&gt; NULL 函数本身有一个prototype属性——函数原型（对象所有公共的属性和方法，constructor=&gt;指向函数本身） 函数对象里有一个属性_ proto _=&gt;指向函数原型prototype 123console.log(对象._proto_ === 函数.prototype) //trueconsole.log(对象._proto_.constructor == 函数) //trueconsole.log(函数.prototype.constructor == 函数) //true JavaScript数据类型检测typeof=&gt;string无法判断具体的引用类型数据，如数组 检测的不管是数组还是正则都返回的是”object”,所以typeof不能判断一个值是否为数组 12345678console.log(typeof &quot;&quot;); //stringconsole.log(typeof 1); //numberconsole.log(typeof true); //booleanconsole.log(typeof null); //objectconsole.log(typeof undefined); //undefinedconsole.log(typeof []); //objectconsole.log(typeof function()&#123;&#125;); //functionconsole.log(typeof &#123;&#125;); //object instanceof=&gt;boolean能够判断具体的引用类型（不能用于判断null和undefined） 基本数据类型的值是不能用instanceof来检测的 123456789console.log(&quot;1&quot; instanceof String); //flaseconsole.log(new String(&quot;1&quot;) instanceof String); //trueconsole.log(1 instanceof Number); //falseconsole.log(new Number(1) instanceof Number); //trueconsole.log(true instanceof Boolean); //falseconsole.log(new Boolean(true) instanceof Boolean); //trueconsole.log([] instanceof Array); //trueconsole.log(function()&#123;&#125; instanceof Function); //trueconsole.log(&#123;&#125; instanceof Object); //true constructor123456console.log((&quot;1&quot;).constructor === String); //trueconsole.log((1).constructor === Number); //trueconsole.log((true).constructor === Boolean); //trueconsole.log(([]).constructor === Array); //trueconsole.log((function() &#123;&#125;).constructor === Function); //trueconsole.log((&#123;&#125;).constructor === Object); //true constructor不适用情况 12345678function Fn()&#123;&#125;;Fn.prototype=new Array(); //函数的原型指向数组var f=new Fn(); //实例化console.log(f.constructor===Fn); //falseconsole.log(f.constructor===Array); //true Object.prototype.toString.call()12345678910var a = Object.prototype.toString;console.log(a.call(&quot;aaa&quot;)); //[object String]console.log(a.call(1)); //[object Number]console.log(a.call(true)); //[object Boolean]console.log(a.call(null)); //[object Null]console.log(a.call(undefined)); //[object Undefined]console.log(a.call([])); //[object Array]console.log(a.call(function() &#123;&#125;)); //[object Function]console.log(a.call(&#123;&#125;)); //[object Object] isNaN,isBoolean…12345678console.log(isObject(&#123;&#125;)); //trueconsole.log(isDate(new Date())); //trueconsole.log(isBoolean(false)); //trueconsole.log(isString(1)); //falseconsole.log(isError(1)); //falseconsole.log(isError(new Error())); //trueconsole.log(isArray([])); //trueconsole.log(isArray(1)); //false","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"使用Hexo和Git搭建个人博客","date":"2017-10-06T16:00:00.000Z","path":"2017/10/07/使用Hexo和Git搭建个人博客/","text":"使用Hexo和Git搭建个人博客一、准备工作1.了解Hexo Hexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以使用 Markdown 编写文章 2.搭建Node.js环境搭建博客网站首先需要安装Node.js环境。 下载地址：http://nodejs.cn/download 测试安装：命令行使用node -v 、npm -v，查看显示版本号即成功。 Ps:大部分同学装的node版本是之前提供的5.0.0多的 hexo的初始化步骤中会出现报错，需要重新装最新的版本（10.0.0多的） 3. 安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在 控制台下（cmd）使用如下命令： 1npm install hexo-cli -g 4.安装Git版本工具Git是目前世界上最流行的分布式版本控制系统 使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。下载地址：https://git-scm.com/downloads测试安装:右击鼠标，如果有git bash等两个选项 即安装成功。 5.注册Github账号 gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式 进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网 站域名，而且需要使用gitHub同步我们个人博客的相关文件。 注册地址：https://github.com 二、开始搭建博客1. 开启GitHub服务通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 新仓库的名字，最好是是UserName+“github.io”的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 注意：固定新仓库的名字格式并非必须，只是这样操作生成的博客域名比较短小简洁，另起他名生成博客域名会很冗长 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，可以使用https://UserName.github.io，访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然点丑)： 2.创建本地博客站点 上述的步骤相当于我们使用Github，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很丑。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台(cmd)命令在本地一个合适的位置创建博客站点文件夹如下 hexo init myHexoBlog //myHexoBlog**是项目名** 测试本地博客站点，在本地博客根目录(git bash)下使用控制台命令： hexo g //g**是generetor的缩写，生成博客 hexo s //s**是server的缩写，启动服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下: 3.同步Github,允许公共访问初次安装git需要配置用户名和邮箱，否则git会提示：please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： $ git config –global user.name “superGG1990” $ git config –global user.email “superGG1990@163.com“ 注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱 git配置SSH Key1、在文件根目录 打开git bash.exe 2、检查是否已经有SSH Key $ cd ~/.ssh 3、生成SSH Key $ ssh-keygen -t rsa -C “youremail” 第一次生成的话，直接一路回车，不需要输入密码。不是第一次生成的话，会提示 overwrite (y/n)? 问你是否覆盖旧的 SSH Key ，直接填 y ，然后一直回车就行了，最后得到了两个文件：id_rsa和id_rsa.pub。 4、记事本打开/C/Users/Administrator/.ssh/下id_rsa.pub文件，复制该段信息；登录github账户，点击头像进入Settings -&gt; SSH and GPG keys -&gt; New SSH key，将复制的信息粘贴到该处。 5、测试是否成功$ssh -T git@github.com 提示“Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.”说明添加成功。 在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。首先找到我们的博客仓库，并拷贝仓库地址： 然后修改本地博客目录的配置： 修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： 之后shift+右击选择执行控制台命令(cmd)： npm install hexo-deployer-git //**安装部署插件 hexo d //**部署到github 再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 二、发布博客 可以发布自己的第一篇博客了。来尝试一下以下的步骤： 在本地博客文件夹根目录(git bash)输入： hexo new “我个人博客的第一篇博客” hexo g //**生成网页 hexo d //**部署到远端(github) 现在打开我们的博客网站：http://UserName.github.io,会看到网页 （显示可能有延迟 所以可以采用以下方法(git bash)： hexo clean //**清理缓存 hexo g //**重新生成博客代码 hexo d //**部署到本地 顺便一提 hexo s 启动本地服务器，用于预览(这里可以不用加上了)直接访问https://userName.github.io 可以写好.md文件然后把它放到source文件夹下然后 hexo clean //**清理缓存 hexo g //**重新生成博客代码 hexo d //**部署到本地 四、更换主题为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主 题下自己编写美化博客界面）。这里以使用github上的next主题为例： 1.创建next文件夹切换到本地博客根目录下，在主题文件thems下创建一个新文件夹next存放即将下载的next主题(git bash) $ git clone https://github.com/iissnan/hexo-theme-next themes/next 也可以直接找到相应的文件夹创建 //**下载主题 下载成之后我们会看到next的主题已经存在thems里了如下： 3.修改博客配置文件，更换主题配置修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next 然后在控制台（git bash）下输入如下命令： hexo clean //**清理缓存 hexo g //**重新生成博客代码 hexo d //**部署到本地 再次打开我们的博客网站https://UserName.github.io，将会看到更换主题后 更多主题美化： https://blog.csdn.net/qq_32454537/article/details/79482896 1.了解Hexo Hexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以使用 Markdown 编写文章 1.了解Hexo Hexo是高效的静态站点生成框架，她基于Node.js。 通过 Hexo 你可以使用 Markdown 编写文章","categories":[],"tags":[{"name":"搭建个人博客","slug":"搭建个人博客","permalink":"http://yoursite.com/tags/搭建个人博客/"}]},{"title":"HTTP","date":"2017-06-24T16:00:00.000Z","path":"2017/06/25/HTTP/","text":"1.RESTfulREST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。 GETget方法在Rest中主要用于获取资源，能够发送参数，不过有限制，且参数都会以?开头的形 式附加在URL尾部。规范的get方法处理器应该是幂等的，也就是说对一个资源不论发送多少次get请求都不会更改数据或造成破坏。 POSTpost方法在Rest请求中主要用于添加资源，参数信息存放在请求报文的消息体中相对安全，且可发送较大信息 PUTput方法在Rest中主要用于更新资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post. 因此为了使用put和delete方法,需要以post发送请求，在表单中使用隐藏域发送真正的请求。put方法的参数是同post一样是存放在消息中的，同样具有安全性，可发送较大信息。put方法是幂等的，对同一URL资源做出的同一数据的任意次put请求其对数据的改变都是一致的。 DELETEDelete在Rest请求中主要用于删除资源，因为大多数浏览器不支持put和delete，会自动将put和delete请求转化为get和post。因此为了使用put和delete方法,需要以post发送请求，在表单中使用隐藏域发送真正的请求。Delete方法的参数同post一样存放在消息体中,具有安全性，可发送较大信息 Delete方法是幂等的，不论对同一个资源进行多少次delete请求都不会破坏数据 https://blog.csdn.net/jnshu_it/article/details/80203696 2.GET和POST的区别 GET产生一个TCP数据包；POST产生两个TCP数据包。 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 3.Accept和Content-TypeAccept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。服务器使用 Content-Type 应答头通知客户端它的选择。123Accept: text/htmlAccept: image/*Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8 1.Accept属于请求头， Content-Type属于实体头。 Http报头分为通用报头，请求报头，响应报头和实体报头。 请求方的http报头结构：通用报头|请求报头|实体报头 响应方的http报头结构：通用报头|响应报头|实体报头 2.Accept代表发送端（客户端）希望接受的数据类型。 比如：Accept：text/xml; 代表客户端希望接受的数据类型是xml类型 Content-Type代表发送端（客户端|服务器）发送的实体数据的数据类型。 比如：Content-Type：text/html; 代表发送端发送的数据格式是html。 二者合起来， Accept:text/xml； Content-Type:text/html 即代表希望接受的数据类型是xml格式，本次请求发送的数据的数据格式是html。 4.状态码 状态码 类别 描述 1xx Informational（信息状态码） 接受请求正在处理 2xx Success（成功状态码） 请求正常处理完毕 3xx Redirection（重定向状态码） 需要附加操作已完成请求 4xx Client Error（客户端错误状态码） 服务器无法处理请求 5xx Server Error（服务器错误状态码） 服务器处理请求出错 166、HTTP 状态消息 200 302 304 403 404 500 分别表示什么200：请求已成功，请求所希望的响应头或数据体将随此响应返回。302：请求的资源临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在 Cache-Control 或 Expires 中进行了指定的情况下，这个响应才是可缓存的304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。403：服务器已经理解请求，但是拒绝执行它。404：请求失败，请求所希望得到的资源未被在服务器上发现。500：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 5.HTTP缓存https://segmentfault.com/a/1190000010690320 6.如何处理不让别人盗用你的图片，访问你的服务器资源 http header, 对refer做判断看来源是不是自己的网站，如果不是就拒绝 通过session校验，如果不通过特定服务生成cookie和session就不能请求得到资源 7.HTTP 协 议 中 ， header 信 息 里 面 ， 怎 么 控 制 页 面 失 效 时 间（last-modified,cache-control,Expires 分别代表什么）","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://yoursite.com/tags/前端基础/"}]},{"title":"javascript","date":"2017-06-14T16:00:00.000Z","path":"2017/06/15/JavaSciprt/","text":"1.同源策略同源策略可防止 JavaScript 发起跨域请求。源被定义为 URI、主机名和端口号的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。 2.跨域 原因 浏览器的同源策略导致了跨域 作用 用于隔离潜在恶意文件的重要安全机制 解决 jsonp ，允许 script 加载第三方资源 反向代理（nginx 服务内部配置 Access-Control-Allow-Origin ） cors 前后端协作设置请求头部，Access-Control-Allow-Origin 等头部信息 iframe 嵌套通讯，postmessage https://zhuanlan.zhihu.com/p/41479807 跨域资源共享 CORS 阮一峰 3.JSONPJsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是 ajax 技术 这是我认为写得比较通俗易懂的一篇文章 直接转载过来https://blog.csdn.net/hansexploration/article/details/80314948 4.事件绑定的方式 嵌入dom 1&lt;button onclick=&quot;func()&quot;&gt;按钮&lt;/button&gt; 直接绑定 1btn.onclick = function()&#123;&#125; 事件监听 1btn.addEventListener(&apos;click&apos;,function()&#123;&#125;) 5.事件委托事件委托利用了事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。所有用到按钮的事件（多数鼠标事件和键盘事件）都适合采用事件委托技术，使用事件委托可以节省内存。1234567891011121314151617181920&lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;凤梨&lt;/li&gt;&lt;/ul&gt;// gooddocument.querySelector(&apos;ul&apos;).onclick = (event) =&gt; &#123; let target = event.target if (target.nodeName === &apos;LI&apos;) &#123; console.log(target.innerHTML) &#125;&#125;// baddocument.querySelectorAll(&apos;li&apos;).forEach((e) =&gt; &#123; e.onclick = function() &#123; console.log(this.innerHTML) &#125;&#125;) 6.事件循环事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。 7.事件模型 DOM0直接绑定 1234&lt;input onclick=&quot;sayHi()&quot;/&gt;btn.onclick = function() &#123;&#125;btn.onclick = null DOM2DOM2级事件可以冒泡和捕获通过addEventListener绑定通过removeEventListener解绑 1234// 绑定btn.addEventListener(&apos;click&apos;, sayHi)// 解绑btn.removeEventListener(&apos;click&apos;, sayHi) DOM3DOM3具有更多事件类型DOM3级事件在DOM2级事件的基础上添加了更多的事件类型，全部类型如下： 12345678UI事件，当用户与页面上的元素交互时触发，如：load、scroll焦点事件，当元素获得或失去焦点时触发，如：blur、focus鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel文本事件，当在文档中输入文本时触发，如：textInput键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress合成事件，当为IME（输入法编辑器）输入字符时触发，如：compositionstart变动事件，当底层DOM结构发生变化时触发，如：DOMsubtreeModified https://www.jianshu.com/p/3acdf5f71d5b 8.target和currentTarget区别 event.target返回触发事件的元素 event.currentTarget返回绑定事件的元素 9.prototype和proto的关系是什么所有的对象都拥有proto属性，它指向Object.prototype（Object是一个原生函数，所有的对象都是Object的实例）12let obj = &#123;&#125;obj.__proto__ === Object.prototype // true 所有的函数都同时拥有proto和protytpe属性函数的proto指向自己的函数实现 函数的protytpe是一个对象 所以函数的prototype也有proto属性 指向Object.prototype12function func() &#123;&#125;func.prototype.__proto__ === Object.prototype // true Object.prototype.proto指向null1Object.prototype.__proto__ // null 10.什么是Ajax,ajax常用属性和方法Ajax(asynchronous JavaScript and XML)是使用客户端上的许多 Web 技术，创建异步 Web 应用的一种 Web 开发技术。借助 Ajax，Web 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，Ajax 允许网页和扩展 Web 应用程序动态更改内容，而无需重新加载整个页面。实际上，现在通常将 JSON 替换为 XML，因为 JavaScript 对 JSON 有原生支持优势。XMLHttpRequest API 经常用于异步通信。此外还有最近流行的fetch API。123456789101112131415let xmlhttpif (window.XMLHttpRequest) &#123; // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码 xmlhttp = new XMLHttpRequest()&#125; else &#123; // IE6, IE5 浏览器执行代码 xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)&#125;xmlhttp.onreadystatechange = () =&gt; &#123; if (xmlhttp.readyState === 4 &amp;&amp; xmlhttp.status === 200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML = xmlhttp.responseText &#125;&#125;xmlhttp.open(&quot;GET&quot;, &quot;/ajax/test.txt&quot;, true)xmlhttp.send() 11.Ajax和Fetch区别 ajax是使用XMLHttpRequest对象发起的，但是用起来很麻烦，所以ES6新规范就有了fetch，fetch发一个请求不用像ajax那样写一大堆代码。 使用fetch无法取消一个请求，这是因为fetch基于Promise，而Promise无法做到这一点。 在默认情况下，fetch不会接受或者发送cookies fetch没有办法原生监测请求的进度，而XMLHttpRequest可以 fetch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理 fetch由于是ES6规范，兼容性上比不上XMLHttpRequest 12.ajax 的缺点123451、ajax 不支持浏览器 back 按钮。2、安全问题 AJAX 暴露了与服务器交互的细节。3、对搜索引擎的支持比较弱。4、破坏了程序的异常机制。5、ajax跨域访问的问题 13.变量提升var会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。变量提升（hoisting）是用于解释代码中变量声明行为的术语。使用var关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。函数提升在变量提升之前 13.当你在浏览器输入一个地址后发生了什么参照php课件图 14.cookie、localStorage、sessionStorage区别 特性 cookie localStorage sessionStorage 数据的生命周期 一般由服务器生成，可设置失效时间，如果在浏览器生成，默认是关闭浏览器之后失效 永久保存，可清除 仅在当前会话有效，关闭页面后清除 存放数据大小 4KB 5MB 5MB 与服务器通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端保存 仅在客户端保存 用途 一般由服务器生成，用于标识用户身份 用于浏览器缓存数据 用于浏览器缓存数据 15.自执行函数?用于什么场景？好处?自执行函数:1、声明一个匿名函数2、马上调用这个匿名函数。作用：创建一个独立的作用域。 好处：防止变量弥散到全局，以免各种js库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理 场景：一般用于框架、插件等场景 16.实现add函数,让add(a)(b)和add(a,b)两种调用结果相同123456789function add(a, b) &#123; if (b === undefined) &#123; return function(x) &#123; return a + x &#125; &#125; return a + b&#125; 17.js中万物皆对象你认为对么我认为是对的在JS中有原生函数、基本数据类型，它们的原型最终还是对象。可以看看本文的原生函数 18.多个页面之间如何进行通信有如下几个方式： cookie web worker localeStorage和sessionStorage 19.css动画和js动画的差异 代码复杂度，js 动画代码相对复杂一些 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好 https://zhuanlan.zhihu.com/p/41479807 20.请用js去除字符串空格去除所有空格 1str.replace(/\\s/g, &apos;&apos;) 去除两边空格 123str.replace(/^\\s+|\\s+$/g, &apos;&apos;)// 原生方法str.trim() 21.清除浮动的几种方式 对父级设置适合CSS高度 父级div定义 overflow:hidden clear:both清除浮动 微元素清楚浮动 22.new一个对象经历了什么12function Test()&#123;&#125;const test = new Test() 创建一个新对象： 1const obj = &#123;&#125; 设置新对象的constructor属性为构造函数的名称，设置新对象的proto属性指向构造函数的prototype对象 12obj.constructor = Testobj.__proto__ = Test.prototype 使用新对象调用函数，函数中的this被指向新实例对象 1Test.call(obj) 将初始化完毕的新对象地址，保存到等号左边的变量中 23.如何实现文件断点续传断点续传最核心的内容就是把文件“切片”然后再一片一片的传给服务器，但是这看似简单的上传过程却有着无数的坑。 首先是文件的识别，一个文件被分成了若干份之后如何告诉服务器你切了多少块，以及最终服务器应该如何把你上传上去的文件进行合并，这都是要考虑的。 因此在文件开始上传之前，我们和服务器要有一个“握手”的过程，告诉服务器文件信息，然后和服务器约定切片的大小，当和服务器达成共识之后就可以开始后续的文件传输了。 前台要把每一块的文件传给后台，成功之后前端和后端都要标识一下，以便后续的断点。 当文件传输中断之后用户再次选择文件就可以通过标识来判断文件是否已经上传了一部分，如果是的话，那么我们可以接着上次的进度继续传文件，以达到续传的功能。有了HTML5 的 File api之后切割文件比想想的要简单的多的多。 只要用slice 方法就可以了1var packet = file.slice(start, end); 参数start是开始切片的位置，end是切片结束的位置 单位都是字节。通过控制start和end 就可以是实现文件的分块 如1234file.slice(0,1000);file.slice(1000,2000);file.slice(2000,3000);// ...... 在把文件切成片之后，接下来要做的事情就是把这些碎片传到服务器上。如果中间掉线了，下次再传的时候就得先从服务器获取上一次上传文件的位置，然后以这个位置开始上传接下来的文件内容。 https://www.cnblogs.com/zhwl/p/3580776.html 24.bind、call、apply的区别call和apply其实是一样的，区别就在于传参时参数是一个一个传或者是以一个数组的方式来传。call和apply都是在调用时生效，改变调用者的this指向。123456let name = &apos;Jack&apos;const obj = &#123;name: &apos;Tom&apos;&#125;function sayHi() &#123;console.log(&apos;Hi! &apos; + this.name)&#125;sayHi() // Hi! JacksayHi.call(obj) // Hi! Tom bind也是改变this指向，不过不是在调用时生效，而是返回一个新函数。12const newFunc = sayHi.bind(obj)newFunc() // Hi! Tom 25.JS的数据类型有哪些？typeof运算符的执行结果都有哪些数据类型？数据类型主要包括两部分： 基本数据类型： Undefined、Null、Boolean、Number和String 引用数据类型： Array 、Object typeof运算符的结果类型： number,string，boolean,object,function,undefined 26.null，undefined 的区别?null 表示一个对象被定义了，值为“空值”； undefined 表示不存在这个值。 27.怎么判断一个变量没有被定义typeof bianliang ==”undefined” 28.怎么判断一个变量arr的话是否为数组（此题用typeof不行）Arr instanceof Array 29.描述下JSON对象的两个很重要的方法JSON.parse() //JSON字符串转换为JSON对象 JSON.stringify() //JSON对象转化为字符串 30.“ ===”、“ ==”的区别？==，当且仅当两个运算数相等时，它返回 true，即不检查数据类型 ===，只有在无需类型转换运算数就相等的情况下，才返回 true，需要检查数据类型 31.原型、原型链？每个由构造函数new出来的实例化对象都自带一个proto属性，该属性指向创建它的构造函数的prototype对象。而prototype对象因为是实例，也有自己的proto属性，指向它的原型对象。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype= instance.proto 32.eval是做什么的？它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’); 33.简单jQuery：请写出代码，ul标签下面有1000个li，写一个性能最高的方式实现，在点击li后，输出li的内容$(“ul”).on(“click”,”li”,function(){ $(this).html(“hit”); }) 34.简述下为何通过ajax发送的请求会出现乱码问题，如何解决？乱码的问题就是编码格式冲突，我们需要传输中文数据前面加一个encodeURI()编码，例如：encodeURI(j$(“#fk_info”).val())；在接受参数的页面对传过来的编码过后的内容用后端语言进行解码 35.简述DOM，HTML DOM的区别和联系DOM分为三部分： （1）核心DOM：遍历DOM树、添加新节点、删除节点、修改节点 （2）HTML DOM：以一种简便的方法访问DOM树 （3）XML DOM：准用于操作XML文档 核心DOM与HTML DOM的区别： 核心DOM ： 对象：Document,Node, ElementNode,TextNode,AttributeNode，CommentNode,NodeList 核心DOM提供了统一的操作接口，如：createElement、appendChild、setAttribute等 核心DOM创建新元素：var newNode=document.createElement(“img”) 给元素添加属性：e.setAttribure()、e.setAttribureNode() 适用场合：核心DOM适合操作节点，如创建，删除，查找等 HTML DOM： 对象：image,Table,Form,Input,Select等等HTML标签对象化 HTML DOM提供了封装好的各种对象，如：Select、Option等等 适用场合：HTML DOM适合操作属性，如读取或修改属性的值 36.什么是事件流DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。DOM同时支持两种事件模型：捕获型事件和冒泡型事件 37.JavaScript原型继承是如何运作的？每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去(知道找到null为止)，也就是我们平时所说的原型链的概念。 38.DOM元素Attribute与Property的区别是什么？1、 property是DOM中的属性，是JavaScript里的对象；而attribute是HTML标签上的特性，它的值只能够是字符串； 2、DOM对象初始化时会在创建默认的基本property；只有在HTML标签中定义的attribute才会被保存在property的attributes属性中； 3、attribute会初始化property中的同名属性，但自定义的attribute不会出现在property中； 4、propety是对象，而attribute的值都是字符串； 5、最关键的两句话： attribute（特性），是我们赋予某个事物的特质或对象。 property（属性），是早已存在的不需要外界赋予的特质。 39.Long-Polling、WebSocket、SSE(Server-Sent Events)之间有什么差异？请写出WebSocket在浏览器端如何发送及接收消息的相关代码实现（需要考虑传输一场并根据返回数据的格式做不同处理）Long-Polling 自己主动请求数据来获知文件知否发生变化 缺点：会有很多无效请求 SSE 服务器端通知客户端数据变化 服务器端客户端保持一个长连接 缺点：保持长连接需要占用大量的服务器端只要 WebSocket 实时通信 缺点：浏览器支持情况没有上面两种方法好 40.指出下面代码的区别function Order(){ } var order = Order(); （1） var order = new Order();（2） 代码（1）是将函数Order()作为一个普通函数去调用的，代码（2）是将Order()作为一个构造函数去调用的；当函数Order的方法体中有this关键之的时候，作为普通函数this指的是window对象，作为构造函数存在的时候this指代的是本对象 41.$(document).ready()是个什么函数？为什么要用它。问题一： $(document).ready()这个函数是用来取代页面中的window.onload; 不同的是onload()的方法是在页面加载完成后才发生，这包括DOM元素和其他页面元素（例如图片）的加载，因此，使用document.ready()方法的执行速度比onload()的方法要快。 问题二：Javascript 只有在DOM元素已经定义以后才可以对其执行某种操作，jQuery使用document.ready来保证所要执行的代码是在DOM元素被加载完成的情况下执行。 43.请写一个正则，匹配输入的字符：第一个必须是字母或下划线开头，后面就是字母和数字或下划线构成，长度5-20.答案： /^[A-Za-z_]\\w{4,19}$/ 44.JS中原型链最上层的对象是 object 的原型对象，该对象的proto指针指向 null 的原型对象。45.JS中使用 Object 对象的 defineProperty 函数定义对象属性的访问器。46.如何对一篇文章进行敏感词替换？假如有几千个敏感词。（写一下思路即可）将这篇文章以字符串的形式赋给一个变量。定义一个正则表达式，以全局匹配的方式查找所有敏感词，并用replace方法替换掉 47.添加、删除、更改、插入节点的方法appendChild removeChild replaceChild insertBefore 48.在javascript编程中，请至少说出三种异步操作的使用场景？回调函数 事件监听 Promise对象 Nodejs的异步方法 49.知道不知道事件冒泡？知不知道阻止浏览器的默认行为？对应的原生兼容性写法该怎么写事件冒泡 父元素和子元素上面的话都添加的有click（不仅仅是click事件，只要保证是同一个事件即可）。子元素的click事件触发的时候，会导致该click事件冒泡到它的父元素上面，为了阻止父元素的事件触发，我们一般需要给子元素的事件里写上阻止事件冒泡的方法 场景：（下拉菜单）点击空白区域关闭下拉菜单 兼容性写法： if(event.stopPropagation){ ​ event.stopPropagation(); }else if(event.cancelBubble){ ​ event.cancelBubble = true; } 阻止浏览器默认行为 当我们不希望一些浏览器默认行为触发的时候，就需要给对应的事件添加上阻止浏览器默认行为。 场景： 禁止a链接的点击后发生跳转 禁止UC等手机浏览器左右滑动切换到前一页或者下一页(我们可以通过给document的touchmove事件加上阻止浏览器默认行为的方法) 50.什么是闭包（closure），为什么要用它？闭包就是能够读取其他函数内部变量的函数，如果一个函数内部又定义了一个内部函数，并将该内部函数作为返回值返回或者存储在某个对象的属性里，这时就会形成一个闭包。 使用场景：1.匿名自执行函数 2缓存 3实现封装（封装的方式有很多，闭包只是其中一种，不是说到封装就一定会用闭包） 闭包的优缺点 闭包的优点： 1.缓存 2.面向对象中的对象 3.实现封装，防止变量跑到外层作用域中，发生命名冲突 4.匿名自执行函数，匿名自执行函数可以减小内存消耗 5.提升变量的作用域链 闭包的缺点： 1.闭包有一个非常严重的问题，那就是内存浪费问题，这个内存浪费不仅仅因为它常驻内存，更重要的是，对闭包的使用不当的话会造成无效内存的产生 2.性能问题 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。 因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。 51.知道原型和原型链么，一般什么时候需要用？原型： 主要作用是用于继承 原型的作用是为函数对象声明通用的变量或者函数，构造函数的实例都会从原型上继承属性和方法。 每个对象中都有proto属性，这个属性指向的就是它基于的原型对象。 原型链： var person = function(name){ this.name = name }; person.prototype.getName = function(){ ​ return this.name; } var zjh = new person(‘zhangjiahao’); zjh.getName(); //zhangjiahao JS在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做proto的内置属性，用于指向创建它的函数对象的原型对象prototype。以上面的例子为例： console.log(zjh.proto === person.prototype) //true 同样，person.prototype对象也有proto属性，它指向创建它的函数对象（Object）的prototype console.log(person.prototype.proto === Object.prototype)//true 继续，Object.prototype对象也有proto属性，但它比较特殊，为null console.log(Object.prototype.proto) //null 我们把这个有proto串起来的直到Object.prototype.proto为null的链叫做原型链 我们调用一个对象的属性或者方法的时候，会存在一个优先级的问题。优先级为： 构造函数内定义的属性&gt;构造函数的原型上定义的属性&gt;沿着proto指定的原型（原型链）一直往上找，直到找到null为止。任何一步一旦找到就立马停止，不会继续往下找。 52.有没有封装过插件，你一般怎么封装呢逼格低点的话这样说： 封装过，以前我主要是把一些公共的功能封装成函数来实现简单封装，比如tab切换封装的时候我会定义一个叫tab的函数，选项卡节点和内容节点作为函数tab的参数。假如我一个页面有多个tab切换，我只需要执行函数的时候给函数传入不同的参数即可。 逼格高点的这样说： 封装过，我们主要用面向对象中的混合模式来封装插件，把可变的属性或者方法（通常都是属性）在构造函数内定义，把一些不变的属性或者方法（通常是方法）定义在函数的原型上面。我们封装好的插件通常会放在一个匿名自执行函数里面，这样做的目的是为了避免变量冲突。 53.Ajax和jsonp的原理？Ajax的原理（最次最次也得把XMLHttpRequest对象说出来） Ajax基于XMLHttpRequest对象与Web服务器端进行异步数据通信。 首先基于这个对象的open方法创建一个浏览器跟服务器端连接，通过send方法从浏览器向服务器端发送请求。我们可以通过这个对象的onreadystatechange事件来监听请求的状态，当请求成功之后的话，我可以获取到这个对象responseText等方法获取到请求过来的数据，然后通过js对这些数据进行解析 Jsonp原理 Ajax不能跨域，但是script标签和img标签都可以跨域。jsonp的话就是动态创建一个script标签，把jsonp数据格式(callback(json))的接口的地址赋值给我们的script标签的src属性。每一次发送jsonp请求的时候都会创建一个全局的回调函数，全局回调函数名称跟我们jsonp接口里面的函数名称是一致的。全局函数里面写的就是对请求过来数据的操作。 Ajax不能跨域，JSONP可以跨域。 54.你们移动端怎么开发的？用的什么单位、js框架呢、怎么真机调试你们程序、怎么解决前缀问题呢首先我们移动端用的是rem这个单位，移动端实际上还新增了vw,vh等一些单位，但是相对于rem来说，他们的兼容性都不好。rem是一个相对单位，是相对于根节点的font-size的比例。我们还会引用一个外部的js，这个js可以通过屏幕宽度动态计算根节点的font-size值。 我们移动端用的JS框架是zepto.js，因为相应来说它的的体积的话要小很多。而且我们项目中有时会需要使用一些触屏事件，比如滑动事件，那么我们还会调用它里面的touch模块 我们webapp的话都是基于gulp搭建的前端工程来开发，因为利用gulp起一个webserver特别简单，并且我还可以实现livereload功能（当我监控的文件发生变化的时候，可以触发浏览器的自动刷新功能），而且在css3里面加前缀的话是一个很头疼的问题，我们现在只需要用autoprefixer模块就可以很容易实现自动加css3前缀这个功能了。 55.移动端兼容性？1&gt;ios移动端click事件300ms的延迟响应. 用fastclick来解决 2&gt;zepto的touch模块的tap事件有点透的问题，也是用fastclick来解决 3&gt;一些情况下对非可点击元素如(label,span)监听click事件，ios下不会触发，css增加cursor:pointer就搞定了 4&gt;ios下取消input在输入的时候英文首字母的默认大写 &lt;input autocapitalize=”off”autocorrect=”off” /&gt; 5&gt;fixed定位缺陷 ios下fixed元素容易定位出错，软键盘弹出时，影响fixed元素定位 android下fixed表现要比iOS更好，软键盘弹出时，不会影响fixed元素定位 ios4下不支持position:fixed 解决方案： 可用iScroll插件解决这个问题 6&gt;Input 的placeholder会出现文本位置偏上的情况 input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal 7&gt;calc的兼容性处理 CSS3中的calc变量在iOS6浏览器中必须加-webkit-前缀，目前的FF浏览器已经无需-moz-前缀。 Android浏览器目前仍然不支持calc，所以要在之前增加一个保守尺寸： div { ​ width: 95%; ​ width: -webkit-calc(100% - 50px); ​ width: calc(100% - 50px); } 8&gt;在移动端修改难看的点击的高亮效果，iOS和安卓下都有效： \\ {-webkit-tap-highlight-color:rgba(0,0,0,0);} 9&gt;阻止旋转屏幕时自动调整字体大小 html, body, form, fieldset, p, div, h1, h2, h3, h4, h5,h6 {-webkit-text-size-adjust:none;} 57.谈谈你对bootstrap的认识，用它做过项目么？用Bootstrap主要用来做一些响应式的网站，它里面栅格化这块比较强大，我可以针对不同的屏幕尺寸定制不同页面结构。 我还用它做过后台管理系统，因为它里面集成的有风格标准统一的组件、插件、全局样式等，是我们做后台管理系统的话，不用再花大精力去布局页面了。而且甚至产品给我们一个原型图我们就可以开始开发，大大提高了开发效率。 58.javascript 继承的 6 种方法？ 原型链继承 借用构造函数继承 组合继承(原型+借用构造) 原型式继承 寄生式继承 寄生组合式继承 59.简述创建函数的几种方式第一种（函数声明）：function sum1(num1,num2){return num1+num2;}第二种（函数表达式）：var sum2 = function(num1,num2){return num1+num2;}匿名函数：function(){}:只能自己执行自己 60.把 Script 标签 放在页面的最底部的 body 封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？如果说放在 body 的封闭之前，将会阻塞其他资源的加载如果放在 body 封闭之后，不会影响 body 61.js 延迟加载的方式有哪些？ defer 和 async 动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack） 按需异步载入 js 62.数组方法 pop() push() unshift() shift()各表示什么意思？答：Push()尾部添加、pop()尾部删除、Unshift()头部添加、shift()头部删除 63.Javascript 中 callee 和 caller 的作用？caller 是返回一个对函数的引用，该函数调用了当前函数；用法：fn.callercallee 是返回正在被执行的 function 函数，也就是所指定的 function 对象的正文。用法：arguments.callee 64.jquery.extend 与 jquery.fn.extend 的区别？Jquery.extend 用来扩展 jQuery 对象本身；jquery.fn.extend 用来扩展 jQuery 原型对象 65.jQuery 和 Zepto 的区别？各自的使用场景？jQuery 主要用于 pc 端，当然有对应的 jQuerymobile 用于移动端，zepto 比 jQuery 更加小巧，主要用于移动端jquer mobile 相对于 zepto 功能强大，但是体积也很庞大，zepto 非常的轻量 66.Zepto 的点透问题如何解决？点透主要是由于两个 div 重合，例如：一个 div 调用 show()，一个 div 调用 hide()；这个时候当点击上面的 div 的时候就会影响到下面的那个 div；解决办法主要有 2 种：1.github 上有一个叫做 fastclick 的库，它也能规避移动设备上 click 事件的延迟响应，https://github.com/ftlabs/fastclick将它用 script 标签引入页面（该库支持 AMD，于是你也可以按照 AMD 规范，用诸如require.js 的模块加载器引入），并且在 dom ready 时初始化在 body 上，2.根据分析，如果不引入其它类库，也不想自己按照上述 fastclcik 的思路再开发一套东西，需要 1.一个优先于下面的“divClickUnder”捕获的事件；2.并且通过这个事件阻止掉默认行为（下面的“divClickUnder”对 click 事件的捕获，在 ios 的 safari，click 的捕获被认为和滚屏、点击输入框弹起键盘等一样，是一种浏览器默认行为，即可以被 event.preventDefault()阻止的行为）。 67.事件绑定和普通事件有什么区别传统事件绑定和符合 W3C 标准的事件绑定有什么区别？div1.onclick=function(){}; 1、如果说给同一个元素绑定了两次或者多次相同类型的事件，那么后面的绑定会覆盖前面的绑定2、不支持 DOM 事件流 事件捕获阶段目标元素阶段=&gt;事件冒泡阶段 addEventListener1、 如果说给同一个元素绑定了两次或者多次相同类型的事件，所有的绑定将会依次触发2、 支持 DOM 事件流的3、 进行事件绑定传参不需要 on 前缀 addEventListener(“click”,function(){},true);//此时的事件就是在事件冒泡阶段执行ie9 开始，ie11 edge：addEventListenerie9 以前：attachEvent/detachEvent1、 进行事件类型传参需要带上 on 前缀2、 这种方式只支持事件冒泡，不支持事件捕获事件绑定是指把事件注册到具体的元素之上，普通事件指的是可以用来注册的事件 68.IE 和标准下有哪些兼容性的写法var ev = ev || window.eventdocument.documentElement.clientWidth || document.body.clientWidthvar target = ev.srcElement||ev.target 69.iframe 的优缺点？优点： 解决加载缓慢的第三方内容如图标和广告等的加载问题 Security sandbox 并行加载脚本 缺点： iframe 会阻塞主页面的 Onload 事件 即时内容为空，加载也需要时间 没有语意 70.DOM 操作——怎样添加、移除、移动、复制、创建和查找节点 创建新节点 createDocumentFragment() // 创建一个 DOM 片段 createElement() // 创建一个具体的元素 createTextNode() // 创建一个文本节点 添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() // 在已有的子节点前插入一个新的子节点 查找 getElementsByTagName() // 通过标签名称 getElementsByName() // 通过元素的 Name 属性的值(IE 容错能力较强，会得到一个数组， 其中包括 id 等于 name 值的) getElementById() // 通过元素 Id，唯一性 71.js 延迟加载的方式有哪些？ defer 和 async 动态创建 DOM 方式（创建 script，插入到 DOM 中，加载完毕后 callBack） 按需异步载入 js 72.documen.write 和 innerHTML 的区别？document.write 只能重绘整个页面innerHTML 可以重绘页面的一部分 73.哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包 控制台日志 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 74.window.location.search 返回的是什么？答：查询(参数)部分。除了给动态语言赋值以外，我们同样可以给静态页面, 并使用 javascript 来获得相信应的参数值。返回值：?ver=1.0&amp;id=timlq 也就是问号后面的！ 75.window.location.hash 返回的是什么？答：锚点 76.window.location.reload() 作用？答：刷新当前页面。 77.BOM 对象有哪些，列举 window 对象？1、window 对象 ，是 JS 的最顶层对象，其他的 BOM 对象都是 window 对象的属性；2、document 对象，文档对象；3、location 对象，浏览器当前 URL 信息；4、navigator 对象，浏览器本身信息；5、screen 对象，客户端屏幕信息；6、history 对象，浏览器访问历史信息； 78.请问代码实现 outerHTML说明：outerHTML 其实就是 innerHTML 再加上本身； 12345Object.prototype.outerHTML = function()&#123; var innerCon = this.innerHTML, //获得里面的内容 outerCon = this.appendChild(innerCon); //添加到里面 alert(outerCon);&#125; 79.你如何优化自己的代码？代码重用避免全局变量（命名空间，封闭空间，模块化 mvc..）拆分函数避免函数过于臃肿：单一职责原则适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程内存管理，尤其是闭包中的变量释放 80.列举常用的 js 框架以及分别适用的领域jquery：简化了 js 的一些操作，并且提供了一些非常好用的 APIjquery ui、jquery-easyui：在 jqeury 的基础上提供了一些常用的组件 日期，下拉框，表格这些组件require.js、sea.js（阿里的玉帛）+》模块化开发使用的zepto：精简版的 jquery，常用于手机 web 前端开发 提供了一些手机页面实用功能,touchext.js：跟 jquery 差不多，但是不开源，也没有 jquery 轻量angular、knockoutjs、avalon(去哪儿前端总监)：MV*框架，适合用于单页应用开发(SPA) 81.JavaScript 数组元素添加、删除、排序等方法有哪些？Array.concat( ) 连接数组Array.join( ) 将数组元素连接起来以构建一个字符串Array.length 数组的大小Array.pop( ) 删除并返回数组的最后一个元素Array.push( ) 给数组添加元素Array.reverse( ) 颠倒数组中元素的顺序Array.shift( ) 将元素移出数组Array.slice( ) 返回数组的一部分Array.sort( ) 对数组元素进行排序Array.splice( ) 插入、删除或替换数组的元素Array.toLocaleString( ) 把数组转换成局部字符串Array.toString( ) 将数组转换成一个字符串Array.unshift( ) 在数组头部插入一个元素 82.如何添加 html 元素的事件，有几种方法？请列举a、直接在标签里添加：这是一个层b、在元素上通过 js 添加:c、使用事件注册函数添加 83.使用闭包实现点击每一列的时候 alert 其 index？123456789101112131415&lt;ul id=&quot;test&quot;&gt; &lt;li&gt;这是第一条&lt;/li&gt; &lt;li&gt;这是第二条&lt;/li&gt; &lt;li&gt;这是第三条&lt;/li&gt;&lt;/ul&gt;var lis=document.querySelectorAll(&apos;li&apos;);for (var i = 0; i &lt; lis.length; i++) &#123; var li = lis[i]; li.onclick=(function(index)&#123; return function(e)&#123; alert(index); &#125;; &#125;)(i);&#125; 84.列出 3 条以上 ff 和 IE 的脚本兼容问题123456789101112131415161718192021221、在 IE 下和火狐下事件冒泡不一样2、IE 的写法： tbody=table.childNodes[0] 在 FF 中，firefox 会在子节点中包含空白则第一个子节点为空白&quot;&quot;， 而 ie 不会返回空白 可以通过 if(&quot;&quot; != node.nodeName)过滤掉空白子对象3、模拟点击事件if(document.all)&#123; //ie 下 document.getElementById(&quot;a3&quot;).click();&#125;else&#123; //非 IE var evt = document.createEvent(&quot;MouseEvents&quot;); evt.initEvent(&quot;click&quot;, true, true); document.getElementById(&quot;a3&quot;).dispatchEvent(evt);&#125;4、事件注册if (isIE)&#123;window.attachEvent(&quot;onload&quot;, init);&#125;else&#123;window.addEventListener(&quot;load&quot;, 5、ajax对象的获取6、firstElement等返回结果不一样 85.在 Javascript 中什么是伪数组？如何将伪数组转化为标准数组？伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，但仍可以对真正数组遍历方法来遍历它们。典型的是函数的 argument 参数，还有像调用getElementsByTagName,document.childNodes 之类的,它们都返回 NodeList 对象都属于伪数组。可以使用 Array.prototype.slice.call(fakeArray)将数组转化为真正的 Array 对象。 86.正则表达式构造函数 var reg=new RegExp(“xxx”)与正则表达字面量 varreg=//有什么不同？匹配邮箱的正则表达式？答案：当使用 RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\表示一个\\）。使用正则表达字面量的效率更高。 87.jQuery 的 slideUp 动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢?先 stop(true,true)后 slideUp() 88.javascript 的本地对象，内置对象和宿主对象本地对象为独立于宿主环境的 ECMAScript 提供的对象，包括 Array Object RegExp 等可以 new 实例化的对象内置对象为 Gload，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象的一个子集)宿主对象为所有的非本地对象，所有的 BOM 和 DOM 对象都是宿主对象，如浏览器自带的document,window 等对象 89.请说出三种减低页面加载时间的方法1、压缩 css、js 文件2、合并 js、css 文件，减少 http 请求3、外部 js、css 文件放在最底下4、减少 dom 操作，尽可能用变量替代不必要的 dom 操作 90.Javascript 作用域链?JavaScript有全局作用域和局部作用域，没有块作用域，函数的嵌套形成不同层次的作用域，嵌套的层次形成链式形式，通过作用域链查找属性的规则需要深入理解。 91. eval 是做什么的？它的功能是把对应的字符串解析成 JS 代码并运行；应该避免使用 eval，不安全，非常耗性能（2 个步骤，一次解析成 js 语句，一次执行） 92.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？意思是使用严格模式，使用严格模式，一些不规范的语法将不再支持 12345678910111213141516171819202122232425链接：http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html全局变量显式声明静态绑定禁止使用 with 语句eval 中定义的变量都是局部变量禁止 this 关键字指向全局对象禁止在函数内部遍历调用栈严格模式下无法删除变量。只有 configurable 设置为 true 的对象属性，才能被删除正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。严格模式下，对一个使用 getter 方法读取的属性进行赋值，会报错。严格模式下，对禁止扩展的对象添加新属性，会报错。严格模式下，删除一个不可删除的属性，会报错。正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。正常模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，这属于语法错误。正常模式下，整数的第一位如果是 0，表示这是八进制数，比如 0100 等于十进制的 64。严格模式禁止这种表示法，整数第一位为 0，将报错。不允许对 arguments 赋值arguments 不再追踪参数的变化禁止使用 arguments.callee严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 93.Javascript 中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？HasOwnProperty 94.js模块化规范浏览器端 requirejs，seajs； 服务器端 commonJS； ES6 模块化；fis 95.gulp、grunt、webpackgulp、grunt、webpack都是前端自动化构建工具。gulp 和 grunt 非常类似，gulp强调的是前端开发的工作流程，核心都是基于一个个的任务(task)进行项目构建，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程 Webpack与Gulp、Grunt没有什么可比性，它把项目看成一个整体，是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。webpack is a module bundle 96.requireJS 的核心原理是什么？核心是 js 的加载模块，通过正则匹配模块以及模块的依赖关系，保证文件加载的先后顺序，根据文件的路径对加载过的文件做了缓存 97.AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？理解这两种规范的差异，主要通过 requirejs 与 seajs 的对比，理解模块的定义与引用方式的差异以及这两种规范的设计原则参考链接 1：https://www.zhihu.com/question/20351507/answer/14859415参考链接 2：https://github.com/seajs/seajs/issues/277 1、对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.2、CMD 推崇依赖就近，AMD 推崇依赖前置。 3、AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个API 都简单纯粹。 98.谈一谈你对 ECMAScript6 的了解ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。 新特性：变量声明(let const)、解构赋值、字符串扩展(模板字符串)、函数扩展(箭头函数)、数组扩展、对象扩展、Symbol、数据结构(Array\\Set\\Map)、代理反射、类(Class)、Promise、迭代器(Iterator)、生成器(Generator) 99.Object 对象的常用方法Object.hasOwnProperty( ) 检查属性是否被继承Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性Object.toLocaleString( ) 返回对象的本地字符串表示Object.toString( ) 定义一个对象的字符串表示Object.valueOf( ) 指定对象的原始值 100.如何编写高性能的 Javascript？使用 DocumentFragment 优化多次 append通过模板元素 clone ，替代 createElement使用一次 innerHTML 赋值代替构建 dom 元素使用 firstChild 和 nextSibling 代替 childNodes 遍历 dom 元素使用 Array 做为 StringBuffer ，代替字符串拼接的操作将循环控制量保存到局部变量顺序无关的遍历时，用 while 替代 for将条件分支，按可能性顺序从高到低排列在同一条件子的多（ &gt;2 ）条件分支时，使用 switch 优于 if使用三目运算符替代条件分支需要不断执行的时候，优先考虑使用 setInterval 101.说说你对 this 的理解？在 JavaScript 中，this 通常指向的是我们正在执行的函数本身，或者是，指向该函数所属的对象。全局的 this → 指向的是 Window函数中的 this → 指向的是函数调用者对象中的 this → 指向其本身事件中 this → 指向事件对象 102.分别阐述 split(),slice(),splice(),join()？join()用于把数组中的所有元素拼接起来放入一个字符串。所带的参数为分割字符串的分隔符，默认是以逗号分开。归属于 Arraysplit()即把字符串分离开，以数组方式存储。归属于 Stringstringslice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。返回的是含有被删除的元素的数组。 103.jQuery.fn 的 init 方法返回的 this 指的是什么对象？为什么要返回 this？this 执行 init 构造函数自身，其实就是 jQuery 实例对象，返回 this 是为了实现 jQuery的链式操作 104.js中如何将数组转化为 json 字符串，然后再转化回来？JSON.parse()JSON.stringify() 105.jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？递归赋值","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://yoursite.com/tags/前端基础/"}]},{"title":"css","date":"2017-06-08T16:00:00.000Z","path":"2017/06/09/CSS/","text":"1.CSS 选择器的优先级是如何计算的？浏览器通过优先级规则，判断元素展示哪些样式。优先级通过 4 个维度指标确定，我们假定以a、b、c、d命名，分别代表以下含义： a表示是否使用内联样式（inline style）。如果使用，a为 1，否则为 0。 b表示 ID 选择器的数量。 c表示类选择器、属性选择器和伪类选择器数量之和。 d表示标签（类型）选择器和伪元素选择器之和。 优先级的结果并非通过以上四个值生成一个得分，而是每个值分开比较。a、b、c、d权重从左到右，依次减小。判断优先级时，从左到右，一一比较，直到比较出最大值，即可停止。所以，如果b的值不同，那么c和d不管多大，都不会对结果产生影响。比如0，1，0，0的优先级高于0，0，10，10。 当出现优先级相等的情况时，最晚出现的样式规则会被采纳。如果你在样式表里写了相同的规则（无论是在该文件内部还是其它样式文件中），那么最后出现的（在文件底部的）样式优先级更高，因此会被采纳。 在写样式时，我会使用较低的优先级，这样这些样式可以轻易地覆盖掉。尤其对写 UI 组件的时候更为重要，这样使用者就不需要通过非常复杂的优先级规则或使用!important的方式，去覆盖组件的样式了。 https://www.smashingmagazine.com/2007/07/css-specificity-things-you-should-know/ https://www.sitepoint.com/web-foundations/specificity/ 2.重置（resetting）CSS 和 标准化（normalizing）CSS 的区别是什么？你会选择哪种方式，为什么？ 重置（Resetting）： 重置意味着除去所有的浏览器默认样式。对于页面所有的元素，像margin、padding、font-size这些样式全部置成一样。你将必须重新定义各种元素的样式。 标准化（Normalizing）： 标准化没有去掉所有的默认样式，而是保留了有用的一部分，同时还纠正了一些常见错误。 当需要实现非常个性化的网页设计时，我会选择重置的方式，因为我要写很多自定义的样式以满足设计需求，这时候就不再需要标准化的默认样式了。 https://stackoverflow.com/questions/6887336/what-is-the-difference-between-normalize-css-and-reset-css 3.请阐述Float定位的工作原理。浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。 CSS 的clear属性通过使用left、right、both，让该元素向下移动（清除浮动）到浮动元素下面。 如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题。 有一种 hack 的方法，是自定义一个.clearfix类，利用伪元素选择器::after清除浮动。另外还有一些方法，比如添加空的&lt;div&gt;&lt;/div&gt;和设置浮动元素父元素的overflow属性。与这些方法不同的是，clearfix方法，只需要给父元素添加一个类，定义如下： 12345.clearfix::after &#123; content: ''; display: block; clear: both;&#125; 值得一提的是，把父元素属性设置为overflow: auto或overflow: hidden，会使其内部的子元素形成块格式化上下文（Block Formatting Context），并且父元素会扩张自己，使其能够包围它的子元素。 https://css-tricks.com/all-about-floats/ 4.请阐述z-index属性，并说明如何形成层叠上下文（stacking context）。CSS 中的z-index属性控制重叠元素的垂直叠加顺序。z-index只能影响position值不是static的元素。 没有定义z-index的值时，元素按照它们出现在 DOM 中的顺序堆叠（层级越低，出现位置越靠上）。非静态定位的元素（及其子元素）将始终覆盖静态定位（static）的元素，而不管 HTML 层次结构如何。 层叠上下文是包含一组图层的元素。 在一组层叠上下文中，其子元素的z-index值是相对于该父元素而不是 document root 设置的。每个层叠上下文完全独立于它的兄弟元素。如果元素 B 位于元素 A 之上，则即使元素 A 的子元素 C 具有比元素 B 更高的z-index值，元素 C 也永远不会在元素 B 之上. 每个层叠上下文是自包含的：当元素的内容发生层叠后，整个该元素将会在父层叠上下文中按顺序进行层叠。少数 CSS 属性会触发一个新的层叠上下文，例如opacity小于 1，filter不是none，transform不是none。 https://css-tricks.com/almanac/properties/z/z-index/ https://philipwalton.com/articles/what-no-one-told-you-about-z-index/ https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context 5.请阐述块格式化上下文（Block Formatting Context）及其工作原理。块格式上下文（BFC）是 Web 页面的可视化 CSS 渲染的部分，是块级盒布局发生的区域，也是浮动元素与其他元素交互的区域。 一个 HTML 盒（Box）满足以下任意一条，会创建块格式化上下文： float的值不是none. position的值不是static或relative. display的值是table-cell、table-caption、inline-block、flex、或inline-flex。 overflow的值不是visible。 在 BFC 中，每个盒的左外边缘都与其包含的块的左边缘相接。 两个相邻的块级盒在垂直方向上的边距会发生合并（collapse）。更多内容请参考边距合并（margin collapsing）。 https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context https://www.sitepoint.com/understanding-block-formatting-contexts-in-css/ 6.有哪些清除浮动的技术，都适用哪些情况？ 空div方法：&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;。 Clearfix 方法：上文使用.clearfix类已经提到。 overflow: auto或overflow: hidden方法：上文已经提到。 在大型项目中，我会使用 Clearfix 方法，在需要的地方使用.clearfix。设置overflow: hidden的方法可能使其子元素显示不完整，当子元素的高度大于父元素时。 7.请解释什么是雪碧图（css sprites），以及如何实现？雪碧图是把多张图片整合到一张上的图片。它被运用在众多使用了很多小图标的网站上（Gmail 在使用）。实现方法： 使用生成器将多张图片打包成一张雪碧图，并为其生成合适的 CSS。 每张图片都有相应的 CSS 类，该类定义了background-image、background-position和background-size属性。 使用图片时，将相应的类添加到你的元素中。 好处： 减少加载多张图片的 HTTP 请求数（一张雪碧图只需要一个请求）。但是对于 HTTP2 而言，加载多张图片不再是问题。 提前加载资源，防止在需要时才在开始下载引发的问题，比如只出现在:hover伪类中的图片，不会出现闪烁。 https://css-tricks.com/css-sprites/ 8.如何解决不同浏览器的样式兼容性问题？ 在确定问题原因和有问题的浏览器后，使用单独的样式表，仅供出现问题的浏览器加载。这种方法需要使用服务器端渲染。 使用已经处理好此类问题的库，比如 Bootstrap。 使用 autoprefixer 自动生成 CSS 属性前缀。 使用 Reset CSS 或 Normalize.css。 9.如何为功能受限的浏览器提供页面？ 使用什么样的技术和流程？ 优雅的降级：为现代浏览器构建应用，同时确保它在旧版浏览器中正常运行。 Progressive enhancement - The practice of building an application for a base level of user experience, but adding functional enhancements when a browser supports it. 渐进式增强：构建基于用户体验的应用，但在浏览器支持时添加新增功能。 利用 caniuse.com 检查特性支持。 使用 autoprefixer 自动生成 CSS 属性前缀。 使用 Modernizr进行特性检测。 10.有什么不同的方式可以隐藏内容（使其仅适用于屏幕阅读器）？这些方法与可访问性（a11y）有关。 visibility: hidden：元素仍然在页面流中，并占用空间。 width: 0; height: 0：使元素不占用屏幕上的任何空间，导致不显示它。 position: absolute; left: -99999px： 将它置于屏幕之外。 text-indent: -9999px：这只适用于block元素中的文本。 Metadata： 例如通过使用 Schema.org，RDF 和 JSON-LD。 WAI-ARIA：如何增加网页可访问性的 W3C 技术规范。 即使 WAI-ARIA 是理想的解决方案，我也会采用绝对定位方法，因为它具有最少的注意事项，适用于大多数元素，而且使用起来非常简单。 https://www.w3.org/TR/wai-aria-1.1/ https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA http://a11yproject.com/ 11.除了screen，你还能说出一个 @media 属性的例子吗？ all适用于所有设备。 print为了加载合适的文档到当前使用的可视窗口. 需要提前咨询 paged media（媒体屏幕尺寸）, 以满足个别设备网页尺寸不匹配等问题。 screen主要适用于彩色的电脑屏幕 speech解析speech这个合成器. 注意: CSS2已经有一个相似的媒体类型叫aural.https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media 12.编写高效的 CSS 应该注意什么？首先，浏览器从最右边的选择器，即关键选择器（key selector），向左依次匹配。根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。避免使用标签和通用选择器作为关键选择器，因为它们会匹配大量的元素，浏览器必须要进行大量的工作，去判断这些元素的父元素们是否匹配。 BEM (Block Element Modifier) methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override.BEM (Block Element Modifier)原则上建议为独立的 CSS 类命名，并且在需要层级关系时，将关系也体现在命名中，这自然会使选择器高效且易于覆盖。 搞清楚哪些 CSS 属性会触发重新布局（reflow）、重绘（repaint）和合成（compositing）。在写样式时，避免触发重新布局的可能。 https://developers.google.com/web/fundamentals/performance/rendering/ https://csstriggers.com/ 13.使用 CSS 预处理的优缺点分别是什么？优点： 提高 CSS 可维护性。 易于编写嵌套选择器。 引入变量，增添主题功能。可以在不同的项目中共享主题文件。 通过混合（Mixins）生成重复的 CSS。 Splitting your code into multiple files. CSS files can be split up too but doing so will require a HTTP request to download each CSS file. 将代码分割成多个文件。不进行预处理的 CSS，虽然也可以分割成多个文件，但需要建立多个 HTTP 请求加载这些文件。 缺点： 需要预处理工具。 重新编译的时间可能会很慢。 14.对于你使用过的 CSS 预处理，说说喜欢和不喜欢的地方？喜欢： 绝大部分优点上题以及提过。 Less 用 JavaScript 实现，与 NodeJS 高度结合。 Dislikes: 我通过node-sass使用 Sass，它用 C ++ 编写的 LibSass 绑定。在 Node 版本切换时，我必须经常重新编译。 Less 中，变量名称以@作为前缀，容易与 CSS 关键字混淆，如@media、@import和@font-face。 15.如何实现一个使用非标准字体的网页设计？使用@font-face并为不同的font-weight定义font-family。 16.解释浏览器如何确定哪些元素与 CSS 选择器匹配。这部分与上面关于编写高效的 CSS 有关。浏览器从最右边的选择器（关键选择器）根据关键选择器，浏览器从 DOM 中筛选出元素，然后向上遍历被选元素的父元素，判断是否匹配。选择器匹配语句链越短，浏览器的匹配速度越快。 例如，对于形如p span的选择器，浏览器首先找到所有&lt;span&gt;元素，并遍历它的父元素直到根元素以找到&lt;p&gt;元素。对于特定的&lt;span&gt;，只要找到一个&lt;p&gt;，就知道’`已经匹配并停止继续匹配。 https://stackoverflow.com/questions/5797014/why-do-browsers-match-css-selectors-from-right-to-left 17.描述伪元素及其用途。CSS 伪元素是添加到选择器的关键字，去选择元素的特定部分。它们可以用于装饰（:first-line，:first-letter）或将元素添加到标记中（与 content:…组合），而不必修改标记（:before，:after）。 :first-line和:first-letter可以用来修饰文字。 上面提到的.clearfix方法中，使用clear: both来添加不占空间的元素。 使用:before和after展示提示中的三角箭头。鼓励关注点分离，因为三角被视为样式的一部分，而不是真正的 DOM。如果不使用额外的 HTML 元素，只用 CSS 样式绘制三角形是不太可能的。 https://css-tricks.com/almanac/selectors/a/after-and-before/ 18.说说你对盒模型的理解，以及如何告知浏览器使用不同的盒模型渲染布局。CSS 盒模型描述了以文档树中的元素而生成的矩形框，并根据排版模式进行布局。每个盒子都有一个内容区域（例如文本，图像等）以及周围可选的padding、border和margin区域。 CSS 盒模型负责计算： 块级元素占用多少空间。 边框是否重叠，边距是否合并。 盒子的尺寸。 盒模型有以下规则： 块级元素的大小由width、height、padding、border和margin决定。 如果没有指定height，则块级元素的高度等于其包含子元素的内容高度加上padding（除非有浮动元素，请参阅下文）。 如果没有指定width，则非浮动块级元素的宽度等于其父元素的宽度减去父元素的padding。 元素的height是由内容的height来计算的。 元素的width是由内容的width来计算的。 默认情况下，padding和border不是元素width和height的组成部分。 https://www.smashingmagazine.com/2010/06/the-principles-of-cross-browser-css-coding/#understand-the-css-box-model 19.{ box-sizing: border-box; }会产生怎样的效果？ 元素默认应用了box-sizing: content-box，元素的宽高只会决定内容（content）的大小。 box-sizing: border-box改变计算元素width和height的方式，border和padding的大小也将计算在内。 元素的height = 内容（content）的高度 + 垂直方向的padding + 垂直方向border的宽度 元素的width = 内容（content）的宽度 + 水平方向的padding + 水平方向border的宽度 20.display的属性值都有哪些？ none, block, inline, inline-block, table, table-row, table-cell, list-item. 21.inline和inline-block有什么区别？我把block也加入其中，为了获得更好的比较。 block inline-block inline 大小 填充其父容器的宽度。 取决于内容。 取决于内容。 定位 从新的一行开始，并且不允许旁边有 HTML 元素（除非是float） 与其他内容一起流动，并允许旁边有其他元素。 与其他内容一起流动，并允许旁边有其他元素。 能否设置width和height 能 能 不能。 设置会被忽略。 可以使用vertical-align对齐 不可以 可以 可以 边距（margin）和填充（padding） 各个方向都存在 各个方向都存在 只有水平方向存在。垂直方向会被忽略。 尽管border和padding在content周围，但垂直方向上的空间取决于’line-height’ 浮动（float） - - 就像一个block元素，可以设置垂直边距和填充。 22.relative、fixed、absolute和static四种定位有什么区别？经过定位的元素，其position属性值必然是relative、absolute、fixed或sticky。 static：默认定位属性值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 relative：该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。 absolute：不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 fixed：不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky：盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。 https://developer.mozilla.org/en/docs/Web/CSS/position 23.你使用过哪些现有的 CSS 框架？你是如何改进它们的？ Bootstrap： 更新周期缓慢。Bootstrap 4 已经处于 alpha 版本将近两年了。添加了在页面中广泛使用的微调按钮组件。 Semantic UI：源代码结构使得自定义主题很难理解。非常规主题系统的使用体验很差。外部库的路径需要硬编码（hard code）配置。变量重新赋值没有 Bootstrap 设计得好。 Bulma： 需要很多非语义的类和标记，显得很多余。不向后兼容，以至于升级版本后，会破坏应用的正常运行。 jquery UI MUI 24.你了解 CSS Flex 和 Grid 吗？Flex 主要用于一维布局，而 Grid 则用于二维布局。 Flex：flex容器中存在两条轴， 横轴和纵轴， 容器中的每个单元称为flex item。 在容器上可以设置6个属性： flex-direction flex-wrap flex-flow justify-content align-items align-content 注意：当设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 Flex 有六种属性可运用在 item 项目上: order flex-basis flex-grow flex-shrink flex align-self ​ Grid：CSS网格布局用于将页面分割成数个主要区域，或者用来定义组件内部元素间大小、位置和图层之间的关系。 像表格一样，网格布局让我们能够按行或列来对齐元素。 但是，使用CSS网格可能还是比CSS表格更容易布局。 例如，网格容器的子元素可以自己定位，以便它们像CSS定位的元素一样，真正的有重叠和层次。 25.响应式设计与自适应设计有何不同？响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。 响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。 自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个。 https://developer.mozilla.org/en-US/docs/Archive/Apps/Design/UI_layout_basics/Responsive_design_versus_adaptive_design http://mediumwell.com/responsive-adaptive-mobile/ https://css-tricks.com/the-difference-between-responsive-and-adaptive-design/ 26.你有没有使用过视网膜分辨率的图形？当中使用什么技术？我倾向于使用更高分辨率的图形（显示尺寸的两倍）来处理视网膜显示。更好的方法是使用媒体查询，像@media only screen and (min-device-pixel-ratio: 2) { ... }，然后改变background-image。 对于图标类的图形，我会尽可能使用 svg 和图标字体，因为它们在任何分辨率下，都能被渲染得十分清晰。 还有一种方法是，在检查了window.devicePixelRatio的值后，利用 JavaScript 将&lt;img&gt;的src属性修改，用更高分辨率的版本进行替换。 https://www.sitepoint.com/css-techniques-for-retina-displays/ 27.什么情况下，用translate()而不用绝对定位？什么时候，情况相反。translate()是transform的一个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。而改变绝对定位会触发重新布局，进而触发重绘和复合。transform使浏览器为元素创建一个 GPU 图层，但改变绝对定位会使用到 CPU。 因此translate()更高效，可以缩短平滑动画的绘制时间。 当使用translate()时，元素仍然占据其原始空间（有点像position：relative），这与改变绝对定位不同。 https://www.paulirish.com/2012/why-moving-elements-with-translate-is-better-than-posabs-topleft/ https://neal.codes/blog/front-end-interview-css-questions https://quizlet.com/28293152/front-end-interview-questions-css-flash-cards/ http://peterdoes.it/2015/12/03/a-personal-exercise-front-end-job-interview-questions-and-my-answers-all/ 28.行内元素、块级元素区别行内元素：和其他元素都在一行上，高度、行高及外边距和内边距都不可改变，文字图片的宽度不可改变，只能容纳文本或者其他行内元素；其中img是行元素 块级元素：总是在新行上开始，高度、行高及外边距和内边距都可控制，可以容纳内敛元素和其他元素；行元素转换为块级元素方式：display：block； 29.水平垂直居中的方式flex 1234// 父容器display: flex;justify-content: center;align-items: center; position 12345678910// 父容器position: relative;// 子容器position:absolute;margin:auto;top:0;bottom:0;left:0;right:0; position+transform 12345678// 父容器position: relative;// 子容器position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%); table-cell 123456789101112131415161718192021222324252627&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;html, body &#123; height: 100%; width: 100%; margin: 0;&#125;.box &#123; display: table; height: 100%; width: 100%;&#125;.content &#123; display: table-cell; vertical-align: middle; text-align: center;&#125;.inner &#123; background-color: #000; display: inline-block; width: 200px; height: 200px;&#125; 30.display:none、visibile:hidden、opacity:0的区别 是否隐藏 是否在文档中占用空间 是否会触发事件 display: none 是 否 否 visibile: hidden 是 是 否 opacity: 0 是 是 是 31.CSS中link和@import的区别 link属于HTML标签，而@import是CSS提供的 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import只在IE5以上才能识别，而link是HTML标签，无兼容问题 link方式的样式的权重 高于@import的权重 32.如何用css实现瀑布流布局利用column-count和break-inside这两个CSS3属性即可，复制如下代码即可察看效果1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;style&gt; body &#123; margin: 0; &#125; .waterfall-container &#123; /分几列/ column-count: 2; width: 100%; / 列间距 / column-gap: 10px; &#125; .waterfall-item &#123; break-inside: avoid; width: 100%; height: 100px; margin-bottom: 10px; background: #ddd; column-gap: 0; text-align: center; color: #fff; font-size: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;waterfall-container&quot;&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 400px&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 600px&quot;&gt;6&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 400px&quot;&gt;7&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 300px&quot;&gt;8&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 700px&quot;&gt;9&lt;/div&gt; &lt;div class=&quot;waterfall-item&quot; style=&quot;height: 100px&quot;&gt;10&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 33.文本超出部分显示省略号单行 123overflow: hidden;text-overflow:ellipsis;white-space: nowrap; 多行 1234display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3; // 最多显示几行overflow: hidden; 34.利用伪元素画三角12345678910.info-tab &#123; position: relative;&#125;.info-tab::after &#123; content: &apos;&apos;; border: 4px solid transparent; border-top-color: #2c8ac2; position: absolute; top: 0;&#125; 32.介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？（1）有两种， IE 盒子模型、W3C 盒子模型； （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； （3）区 别： IE的content部分把 border 和 padding计算了进去; 33.CSS选择符有哪些？哪些属性可以继承？1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（ ） 8.属性选择器（a[rel = “external”]） 9.伪类选择器（a:hover, li:nth-child） 可继承的样式： font-sizefont-family color, UL LI DL DD DT; 不可继承的样式：border paddingmargin width height 34.css定义的权重 标签的权重为1，class的权重为10，id的权重为100 35.如果需要手动写动画，你认为最小时间间隔是多久，为什么？ 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 36.简单介绍下CSS的盒子模型，他都包含哪些属性？ width,height,margin,padding,border 37.宽高都200px的div在浏览器窗口居中（水平垂直都居中） position:fixed;width:200px;height:200px;left:50%;top:50%; margin-left:-100px;margin-top:-100px; 39.超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 40.低版本浏览器不支持display:inline-block属性，请问怎么兼容display:inline;zoom:1; 41.在使用display:inline-block时，inline-block元素会有4px左右的空隙，这是什么原因导致的以及解决方法（1） 取消换行和空格 （2） 设置父元素的font-size为0，在给子元素设置自身的字体大小 42.写出下面三个的区别？height{} _height{} +height{} \\ IE7及以下 _IE6 +IE7 43.Inline-block默认的对其方式是什么？在使用inline-block时在内容不同的时候想要保持内容水平对齐，说一下你采用的方法？默认对齐方式：base-line 水平对齐：vertical-align:top; 44.简明说一下CSS link于@import的区别和用法link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 link支持使用Javascript控制DOM去改变样式；而@import不支持。 45.HTML5、CSS3里面都新增了那些新特性？12345678910HTML5新增如下：1. 拖拽释放(Drag and drop) API2. 语义化更好的内容标签（header,nav,footer,aside,article,section）3. 音频、视频 API(audio,video)4. 画布(Canvas) API5. 地理(Geolocation) API6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；7. sessionStorage 的数据在浏览器关闭后自动删除8. 表单控件，calendar、date、time、email、url、search9. 新的技术 webworker, websocket, Geolocation 1234567CSS3新增如下：CSS3的2d，3d变换。transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜CSS3圆角（border-radius），阴影（box-shadow），对文字加特效（text-shadow)，边框图片(border-image)CSS3动画 Transition,animationCSS3的媒体查询、多栏布局、伸缩盒子CSS3新的单位（rem,vw，vh等）CSS3更多的选择器 46.HTML5 为什么只需要写 &lt;!DOCTYPEHTML&gt;？ HTML5 不基于 SGML（标准通用标记语言），因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）； 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 47.如何处理HTML5新标签的浏览器兼容问题？IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 将上代码复制到head部分，记住一定要是head部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效） 最后在css里面加上这段： article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block} 主要是让这些html5标签成块状，像div那样。 48.cookies，sessionStorage 和 localStorage 的区别？cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 生命周期： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 49.什么叫优雅降级和渐进增强？优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 50.transition和animation的区别transition是过渡，animation是动画。transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画，可以定义动画的区间等。 transition必须通过一些行为才能触发（js或者伪类来触发），animation的话直接就可以触发。 51.margin-left:calc(-100%-100px) 代码中用到了一个calc（），这个函数的作用是什么？答：通过计算来确定CSS属性值。 calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。calc()可以使用数学运算中的简单加（+）、减（-）、乘（）和除（/）来解决问题，而且还可以根据单位如px,em,rem和百分比来转化计算 52.简述HTML5新增的canvas、audio、svg标签的作用canvas被称作画布，canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域,可以控制其每一像素。 audio标签可以引用音频资源，在页面上播放音乐 svg用XML格式定义图形，可以用来制作矢量图形。 53.简述如何通过CSS进行响应式布局的方式响应式布局使用媒体查询@media 定义多个分辨率下的样式，使页面在不同的分辨率下显示不同的样式 54.CSS的单位中，设定元素的长度或宽度与父元素字体大小相关的单位是什么？与html文档元素大小相关的单位是什么？em 、rem 55.CSS3实现一段阴影文本持续淡入淡出？HTML结构 ： &lt;divclass=”box”&gt;文本 CSS样式： ​ .box { ​ text-shadow: 1px 1px 2px #F00; ​ -moz-animation:fade1s infinite; ​ -webkit-animation:fade1s infinite; ​ -o-animation:fade1s infinite; ​ animation:fade1s infinite; ​ } ​ @keyframes fade { ​ 0%{ opacity: 0;} ​ 50%{ opacity: 100;} ​ 100%{ opacity: 0;} ​ } ​ @-webkit-keyframes fade { ​ 0%{ opacity: 0;} ​ 50%{ opacity: 100;} ​ 100%{ opacity: 0;} ​ } ​ @-moz-keyframes fade { ​ 0%{ opacity: 0;} ​ 50%{ opacity: 100;} ​ 100%{ opacity: 0;} ​ } ​ @-o-keyframes fade { ​ 0%{ opacity: 0;} ​ 50%{ opacity: 100;} ​ 100%{ opacity: 0;} ​ } 56.简述如何通过CSS进行响应式布局的方式。meta标签定义: 使网页适配设备宽度。 使用Media Queries适配对应样式 57.如何使用Canvas来画一条简单的线？var canvas=document.getElementById(“canvas”); var cxt=canvas.getContext(‘2d’); cxt.beginPath(); cxt.lineWidth=10; cxt.strokeStyle=”#00ff00”; cxt.moveTo(20,20); cxt.lineTo(100,20); cxt.stroke(); cxt.closePath(); 58.rgba和opacity的透明效果有什么不同？opacity会继承父元素的 opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性。比如rgba的话,内部的文字透明度不会发生变化，而opacity的话，会影响到内部的文字 59.FontAwesome和iconfont是什么？他们有什么异同，问什么要使用它，有什么弊端？两个都是图标字体。Font Awesome 是一套完美的图标字体,主要目的是和 Bootstrap 搭配使用 Iconfont是阿里的字体库，可以定制自己要的字体图标。 优势： 1、轻量性：一个图标字体比一系列的图像（特别是在Retina屏中使用双倍图像）要小。一旦图标字体加载了，图标就会马上渲染出来，不需要下载一个图像。可以减少HTTP请求，还可以配合HTML5离线存储做性能优化。 2、灵活性：图标字体可以用过font-size属性设置其任何大小，还可以加各种文字效果，包括颜色、Hover状态、透明度、阴影和翻转等效果。可以在任何背景下显示。使用位图的话，必须得为每个不同大小和不同效果的图像输出一个不同文件。 3、兼容性：网页字体支持所有现代浏览器，包括IE低版本。详细兼容性可以点击这里。 弊端： 只能单色 跨域问题 字体图标库似乎体积显得有些过大 60.什么是响应式设计？它是关于网站的制作或网页制作的工作。不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常。一部分是媒体查询和不同的视觉效果。一部分是不同的资源（如不同的Javascript来处理触摸与点击自动适应屏幕的对比）。 61.解释下这个CSS选择器什么发生什么？[role=navigation] &gt; ul a:not([href^=mailto]) {} 定义了role属性，并且值为navigation的任何元素，其子元素列表下的除邮箱链接之外的所有链接元素。 能够用语言表达清楚这个选择器，证明你理解他们和可以使用他们做一些技术交流。 61.如何处理HTML5新标签的浏览器兼容问题？（自己需要试试） 将上代码复制到head部分，记住一定要是head部分（因为IE必须在元素解析前知道这个元素，所以这个js文件不能在其他位置调用，否则失效） 最后在css里面加上这段： article,aside,dialog,footer,header,section,footer,nav,figure,menu{display:block} 主要是让这些html5标签成块状，像div那样。 62.经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？不同浏览器都会带有自己的浏览器默认样式，一般我们需要把这些浏览器默认自带的样式给清楚，一般我们借助reset.css（我们公司里开发前端页面都用这个来清楚浏览器默认样式） display:inline-block（IE7及以下不支持） 需要对低版本IE特殊处理：{display:inline-block;display:inline;zoom:1;} display:inline-block 什么时候会显示间隙？怎样消除间隙？ 父元素font-size设置成0，子元素重新设置font-size display:inline-block滥用容易出现布局方面的问题，尤其在左中右、左右等布局方面的问题尤为突出。因此如果是左右布局的话，尽量都用浮动来代替 z-index在IE7及以下版本的话，有时会发现不是谁z-index设置的越高谁就显示在最上面。碰到这种问题需要设置父元素有相对定位属性元素的z-index。先比较父元素的z-index再比较子元素的 IE6双边距 IE6中，元素向左浮动并且设置了左侧的外边距出现了这样的双边距bug。同理，元素向右浮动并且设置右边距也会出现同样的情况。同一行如果有多个浮动元素，第一个浮动元素会出现这个双边距bug，其它的浮动元素则不会。只需要给浮动元素加上display:inline;这样的CSS属性就可以了。 margin-top，margin-bottom的bug 父元素的第一个子元素设置了margin-top,会作用于父元素（值为父元素的margin-top与该margin-top两者中的最大值)，而子元素和父元素的边距则没有发生变化。 63.IE8-(IE8及以下)rgba模式不兼容的解决方案IE8以及以下用滤镜， filter:Alpha(opacity=20); 64.CSS Hack什么是CSS hack 由于不同厂商的流览器或某浏览器的不同版本（如IE6-IE11,Firefox/Safari/Opera/Chrome等），对CSS的支持、解析不一样，导致在不同浏览器的环境中呈现出不一致的页面展现效果。这时，我们为了获得统一的页面效果，就需要针对不同的浏览器或不同版本写特定的CSS样式，我们把这个针对不同的浏览器/不同版本写相应的CSS code的过程，叫做CSS hack! CSS hack的原理 由于不同的浏览器和浏览器各版本对CSS的支持及解析结果不一样，以及CSS优先级对浏览器展现效果的影响，我们可以据此针对不同的浏览器情景来应用不同的CSS。 CSS hack分类 科普 lte：就是Less than or equal to的简写，也就是小于或等于的意思。 lt ：就是Less than的简写，也就是小于的意思。 gte：就是Greater than or equal to的简写，也就是大于或等于的意思。 gt ：就是Greater than的简写，也就是大于的意思。 ! ：就是不等于的意思，跟javascript里的不等于判断符相同 CSS Hack大致有3种表现形式，CSS属性前缀法、选择器前缀法以及IE条件注释法（即HTML头部引用if IE）Hack，实际项目中CSS Hack大部分是针对IE浏览器不同版本之间的表现差异而引入的。 属性前缀法(即类内部Hack)：例如 IE6能识别下划线””和星号” “，IE7能识别星号” “，但不能识别下划线””，IE6~IE10都认识”\\9”，但firefox前述三个都不能认识. .all IE{property:value\\9;} .gte IE 8{property:value\\0;} .lte IE7{property:value;} .IE 8/9{property:value\\0;} .IE 9{property:value\\9\\0;} .IE7{+property:value;} .IE 6{_property:value;} .not IE{property//:value;} 选择器前缀法(即选择器Hack)：例如 IE6能识别html .class{}，IE7能识别+html .class{}或者:first-child+html.class{}。 IE条件注释法(即HTML条件注释Hack)：针对所有IE(注：IE10+已经不再支持条件注释)： ，针对IE6及以下版本： 。这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。 只在IE下生效 只在IE6下生效 只在IE6以上版本生效 &lt;–[if gte IE 6]&gt; 这段文字只在IE6以上(包括)版本IE浏览器显示&lt;![endif]–&gt; 只在IE8上不生效 非IE浏览器生效 65.写一个CSS3动画？并让描述transition和animation的区别transition是过渡，animation是动画。transition只能从一种状态过渡到另外一种状态，animation可以定制复杂动画，可以定义动画的区间等。 transition必须通过一些行为才能触发（js或者伪类来触发），animation的话不需要直接就可以触发。 66.BFC 是什么?BFC（块级格式化上下文），一个创建了新的 BFC 的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个 BFC 中的两个相邻的盒子在垂直方向发生 margin 重叠的问题BFC 是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用 67.什么是外边距重叠？重叠的结果是什么？答案：外边距重叠就是 margin-collapse。在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。折叠结果遵循下列计算规则： 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 68.你如何对网站的文件和资源进行优化？文件合并文件最小化/文件压缩使用 CDN 托管缓存的使用 69.为什么利用多个域名来存储网站资源会更有效？CDN 缓存更方便突破浏览器并发限制节约 cookie 带宽节约主域名的连接数，优化页面响应速度防止不必要的安全问题 70.知道 css 有个 content 属性吗？有什么作用？有什么应用？知道。css 的 content 属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。 71.HTML5 引入什么新的表单属性？Datalist datetime output keygen date month week time number range email url 72.语义化的理解？用正确的标签做正确的事情！html 语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；在没有样式 CCS 情况下也以一种文档格式显示，并且是容易阅读的。搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于 SEO。使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 73.简述一下 Sass、Less，且说明区别？他们是动态的样式语言，是 CSS 预处理器,CSS 上的一种抽象层。他们是一种特殊的语法/语言而编译成 CSS。变量符不一样，less 是@，而 Sass 是$;Sass 支持条件语句，可以使用 if{}else{},for{}循环等等。而 Less 不支持;Sass 是基于 Ruby 的，是在服务端处理的，而 Less 是需要引入 less.js 来处理 Less 代码输出 Css 到浏览器","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://yoursite.com/tags/前端基础/"}]},{"title":"HTML","date":"2017-05-24T16:00:00.000Z","path":"2017/05/25/HTML/","text":"1.什么是语义化用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 语义化标签的好处 易于用户阅读，样式丢失的时候能让页面呈现清晰的结构。 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重。 方便其他设备解析，如盲人阅读器根据语义渲染网页 有利于开发和维护，语义化更具可读性，代码更好维护，与CSS3关系更和谐。 http://www.daqianduan.com/6549.html 2.cookie、sessionStorage和localStorage的区别。上面提到的技术名词，都是在客户端以键值对存储的存储机制，并且只能将值存储为字符串。 cookie localStorage sessionStorage 由谁初始化 客户端或服务器，服务器可以使用Set-Cookie请求头。 客户端 客户端 过期时间 手动设置 永不过期 当前页面关闭时 在当前浏览器会话（browser sessions）中是否保持不变 取决于是否设置了过期时间 是 否 是否随着每个 HTTP 请求发送给服务器 是，Cookies 会通过Cookie请求头，自动发送给服务器 否 否 容量（每个域名） 4kb 5MB 5MB 访问权限 任意窗口 任意窗口 当前页面窗口 3.为什么最好把 CSS 的&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间？为什么最好把 JS 的&lt;script&gt;标签恰好放在&lt;/body&gt;之前，有例外情况吗？ 把&lt;link&gt;放在&lt;head&gt;中 把&lt;link&gt;标签放在&lt;head&gt;&lt;/head&gt;之间是规范要求的内容。此外，这种做法可以让页面逐步呈现，提高了用户体验。将样式表放在文档底部附近，会使许多浏览器（包括 Internet Explorer）不能逐步呈现页面。一些浏览器会阻止渲染，以避免在页面样式发生变化时，重新绘制页面中的元素。这种做法可以防止呈现给用户空白的页面或没有样式的内容。 把&lt;script&gt;标签恰好放在&lt;/body&gt;之前 脚本在下载和执行期间会阻止 HTML 解析。把&lt;script&gt;标签放在底部，保证 HTML 首先完成解析，将页面尽早呈现给用户。 例外情况是当你的脚本里包含document.write()时。但是现在，document.write()不推荐使用。同时，将&lt;script&gt;标签放在底部，意味着浏览器不能开始下载脚本，直到整个文档（document）被解析。也许，对此比较好的做法是，&lt;script&gt;使用defer属性，放在&lt;head&gt;中。 4.什么是渐进式渲染（progressive rendering）？渐进式渲染是用于提高网页性能（尤其是提高用户感知的加载速度），以尽快呈现页面的技术。 在以前互联网带宽较小的时期，这种技术更为普遍。如今，移动终端的盛行，而移动网络往往不稳定，渐进式渲染在现代前端开发中仍然有用武之地。 一些举例： 图片懒加载——页面上的图片不会一次性全部加载。当用户滚动页面到图片部分时，JavaScript 将加载并显示图像。 确定显示内容的优先级（分层次渲染）——为了尽快将页面呈现给用户，页面只包含基本的最少量的 CSS、脚本和内容，然后可以使用延迟加载脚本或监听DOMContentLoaded/load事件加载其他资源和内容。 异步加载 HTML 片段——当页面通过后台渲染时，把 HTML 拆分，通过异步请求，分块发送给浏览器。更多相关细节可以在这里找到。 5.viewportViewport ：字面意思为视图窗口，在移动web开发中使用。表示将设备浏览器宽度虚拟成一个特定的值（或计算得出），这样利于移动web站点跨设备显示效果基本一致。移动版的 Safari 浏览器最新引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放，其他手机浏览器也基本支持。 在移动端浏览器当中，存在着两种视口，一种是可见视口（也就是我们说的设备大小），另一种是视窗视口（网页的宽度是多少）。举个例子：如果我们的屏幕是320像素 480像素的大小（iPhone4），假设在浏览器中，320像素的屏幕宽度能够展示980像素宽度的内容。那么320像素的宽度就是可见视口的宽度，而能够显示的980像素的宽度就是视窗视口的宽度。 为了显示更多的内容，大多数的浏览器会把自己的视窗视口扩大，简易的理解，就是让原本320像素的屏幕宽度能够容下980像素甚至更宽的内容（将网页等比例缩小）。 6.Reflow和RepaintReflow：当涉及到DOM节点的布局属性发生变化时，就会重新计算该属性，浏览器会重新描绘相应的元素，此过程叫Reflow（回流或重排）。 Repaint：当影响DOM元素可见性的属性发生变化 (如 color) 时, 浏览器会重新描绘相应的元素, 此过程称为Repaint（重绘）。因此重排必然会引起重绘。 7.引起Repaint和Reflow的一些操作 调整窗口大小 字体大小 样式表变动 元素内容变化，尤其是输入控件 CSS伪类激活，在用户交互过程中发生 DOM操作，DOM元素增删、修改 width, clientWidth, scrollTop等布局宽高的计算 ​ Repaint和Reflow是不可避免的，只能说对性能的影响减到最小，给出下面几条建议： 避免逐条更改样式。建议集中修改样式，例如操作className。 避免频繁操作DOM。创建一个documentFragment或div，在它上面应用所有DOM操作，最后添加到文档里。设置display:none的元素上操作，最后显示出来。 避免频繁读取元素几何属性（例如scrollTop）。绝对定位具有复杂动画的元素。 绝对定位使它脱离文档流，避免引起父元素及后续元素大量的回流 8.img中的alt和元素的title属性作用 img的alt属性如果无法显示图像，浏览器将显示alt指定的内容 元素title属性在鼠标移到元素上时显示title的内容 9.href和src区别 href href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系若在文档中添加href ，浏览器会识别该文档为 CSS 文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式加载 CSS，而不是使用 @import 方式。 src src表示引用资源，替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。当浏览器解析到src ，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等也如此，类似于将所指向资源应用到当前内容。这也是为什么建议把 js 脚本放在底部而不是头部的原因。 https://blog.csdn.net/lhjuejiang/article/details/80795081 10.浏览器的渲染过程 解析HTML生成DOM树。 解析CSS生成CSSOM规则树。 将DOM树与CSSOM规则树合并在一起生成渲染树。 遍历渲染树开始布局，计算每个节点的位置大小信息。 将渲染树每个节点绘制到屏幕。 https://baijiahao.baidu.com/s?id=1593097105869520145&amp;wfr=spider&amp;for=pc 11.处理兼容问题的思路 根据兼容需求选择技术框架/库(jquery) 根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr) 条件注释、CSS Hack、js 能力检测做一些修补 渐进增强(progressive enhancement): 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 优雅降级 (graceful degradation): 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 https://github.com/jirengu/frontend-interview/issues/35 回到顶部 12.doctype有什么用doctype是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。 &lt;!DOCTYPE&gt;声明是用来指示web浏览器关于页面使用哪个HTML版本进行编写的指令。 &lt;!DOCTYPE&gt;声明必须是HTML文档的第一行，位于html标签之前。 浏览器本身分为两种模式，一种是标准模式，一种是怪异模式，浏览器通过doctype来区分这两种模式，doctype在html中的作用就是触发浏览器的标准模式，如果html中省略了doctype，浏览器就会进入到Quirks模式的怪异状态，在这种模式下，有些样式会和标准模式存在差异，而html标准和dom标准值规定了标准模式下的行为，没有对怪异模式做出规定，因此不同浏览器在怪异模式下的处理也是不同的，所以一定要在html开头使用doctype。 13.标准模式和怪异模式区别区别：总体会有布局、样式解析和脚本执行三个方面的区别。盒模型：在 W3C 标准中，如果设置一个元素的宽度和高度，指的是元素内容的宽度和高度，而在 Quirks 模式下，IE 的宽度和高度还包含了 padding 和 border。设置行内元素的高宽：在 Standards 模式下，给等行内元素设置 wdith 和 height 都不会生效，而在 quirks 模式下，则会生效。设置百分比的高度：在 standards 模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置百分比的高度，子元素设置一个百分比的高度是无效的用margin:0 auto 设置水平居中：使用 margin:0 auto 在 standards 模式下可以使元素水平居中，但在 quirks 模式下却会失效。 14.一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。图片懒加载，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。如果图片为 css 图片，可以使用 CSSsprite，SVGsprite，Iconfont、Base64 等技术。如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。 15.严格模式与混杂模式的区别？严格模式下：页面排版及 JS 解析是以该浏览器支持的最高标准来执行混杂模式：不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容 16.iframe有那些缺点？ iframe会阻塞主页面的Onload事件； 搜索引擎的检索程序无法解读这种页面，不利于SEO; iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript。动态给iframe添加src属性值，这样可以绕开以上两个问题。 17.HTML与XHTML 二者有什么区别，你觉得应该使用哪一个并说出理由。1.XHTML 元素必须被正确地嵌套。 错误：thisis example. 正确：thisis example. 2.XHTML 元素必须被关闭。 错误：this isexample. 正确：this isexample. 3.标签名必须用小写字母。 错误：this isexample. 正确：this isexample. 3.1空标签也必须被关闭 错误： 正确： 4.XHTML 文档必须拥有根元素。 所有的 XHTML 元素必须被嵌套于 根元素中。 18.常见的浏览器内核有哪些？Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 19.HTML5的form如何关闭自动完成功能？给不想要提示的 form 或某个 input 设置为autocomplete=off。 20. 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 21.title与h1的区别、b与strong的区别、i与em的区别？title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：会重读，而是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements – 自然样式标签 b, i, u, s, pre Semantic Style Elements – 语义样式标签 strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。 22.请描述下 SEO 中的 TDK ？在SEO中，所谓的TDK其实就是title、description、keywords这三个标签，这三个标签在网站的优化过程中 title标题标签，description描述标签，keywords关键词标签 23. 简单书写 HTML 代码：请写出一个 html 网站代码，内容为一个图片，链接到 “http://www.baidu.com” ，图片路径为 “./img/logo.png”, 为图片设置替换文本 ”webfoss”, 新网页在新窗口打开；答： &lt;a href=”http://www.baidu.com” alt=”webfoss” target=”_blank”&gt;&lt;img src=”./img/logo.png”&gt; 24. 标签上 title 与 alt 属性的区别是什么？alt是给搜索引擎识别，在图像无法显示时的替代文本；title是关于元素的注释信息，主要是给用户解读。当鼠标放到文字或是图片上时有title文字显示。（因为IE不标准）在IE浏览器中alt起到了title的作用，变成文字提示。在定义img对象时，将alt和title属性写全，可以保证在各种浏览器中都能正常使用。 25. 前端页面有哪三层构成，分别是什么？作用是什么？分成：结构层、表示层、行为层。 结构层（structural layer） 由 HTML 或 XHTML之类的标记语言负责创建。标签，也就是那些出现在尖括号里的单词，对网页内容的语义含义做出了描述，但这些标签不包含任何关于如何显示有关内容的信息。例如，P标签表达了这样一种语义：“这是一个文本段。” 表示层（presentationlayer） 由 CSS 负责创建。 CSS对“如何显示有关内容”的问题做出了回答。 行为层（behaviorlayer） 负责回答“内容应该如何对事件做出反应”这一问题。这是 Javascript 语言和 DOM主宰的领域。 26.每个 HTML 文件头里都有个很重要的东西， Doctype ，知道这是干什么的么？&lt;!DOCTYPE&gt; 声明位于文档中的最前面的位置，处于 标签之前。 作用： 1.告知浏览器文档使用哪种 HTML 或 XHTML 规范。 2.告诉浏览器按照何种规范解析页（如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,浏览器按照自己的方式解析渲染页面） 27.DIV+CSS 布局较 table 有什么优势？1、速率更快，页面体积变小，浏览速度变快，这就使得对于某些控制主机流量的网站来说是最大的优势了； 2、更好地被搜索引擎收录，大部分html页面的样式写入了CSS文件中，便于被搜索引擎采集收录； 3、对浏览者和浏览器更具优势，由于CSS富含丰富的样式，使页面更加灵活性，它可以根据不同的浏览器，而达到显示效果的统一和不变形； 4、修改更有效率，由于使用了DIV+CSS制作方法，在修改页面的时候更加容易省时，提高工作效率； 28.为什么用多个域名存储网站资源更有效？1、CDN缓存更方便 2、突破浏览器并发限制 3、节约cookie带宽 4、节约主域名的连接数，优化页面响应速度 5、防止不必要的安全问题 29.简要说明一下做好 SEO 需要考虑哪些方面？1.TDK 2.图片+alt 3.友情链接 4.站点地图","categories":[],"tags":[{"name":"前端基础","slug":"前端基础","permalink":"http://yoursite.com/tags/前端基础/"}]}]