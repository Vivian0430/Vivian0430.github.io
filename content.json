[{"title":"JavaScript常用设计模式详解","date":"2018-12-17T16:00:00.000Z","path":"2018/12/18/JavaScript常用设计模式详解/","text":"JavaScript常用设计模式详解JavaScript中常用的设计模式有十种，分别为工厂模式，单体模式，模块模式，代理模式，职责链模式，命令模式，模板方法模式，策略模式，发布-订阅模式以及中介者模式。 都是为了降低代码的耦合度，提高性能。 其中，工厂模式，单例模式，模块模式，发布订阅模式比较重要，常用。 工厂模式简单工厂模式简单工厂模式就是用来解决多个类似对象的声明问题，无法判断所创建出的对象的类型。 1234567891011121314151617181920212223242526272829//创建对象function CreatePerson(name,age,sex) &#123; var obj = new Object(); //new了一个object对象 obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function()&#123; return this.name; &#125; return obj;&#125;//可以无数次调用这个函数，来获得包含三个属性一个方法的对象var p1 = new CreatePerson(&quot;longen&quot;,&apos;28&apos;,&apos;男&apos;);var p2 = new CreatePerson(&quot;tugenhua&quot;,&apos;27&apos;,&apos;女&apos;);console.log(p1.name); // longenconsole.log(p1.age); // 28console.log(p1.sex); // 男console.log(p1.sayName()); // longenconsole.log(p2.name); // tugenhuaconsole.log(p2.age); // 27console.log(p2.sex); // 女console.log(p2.sayName()); // tugenhua// 返回都是object 无法识别对象的类型 不知道他们是哪个对象的实例(不知道对象的类型)console.log(typeof p1); // objectconsole.log(typeof p2); // objectconsole.log(p1 instanceof Object); // true 拓展： 除了string、number、Boolean、null、undefined之外，其他的数据都是对象。 对象的类型：1.内置对象（原生对象）=&gt;RegExp，Date，Math…(js语言本身预定义的对象) ​ 2.宿主对象=&gt;BOM对象：History，Location，Window，Navigate，Screen ​ DOM对象：Body，Style，Meta，Frame，Frameset… 复杂工厂模式将其对象成员的实例化推迟到子类当中，子类可以重写接口（overRide）来创建自己的对象类型。 父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。父类中只声明方法而具体的业务逻辑要在子类中写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 定义自行车的构造函数 父类=&gt;抽象类var BicycleShop = function(name)&#123; this.name = name; this.method = function()&#123; return this.name; &#125;&#125;;BicycleShop.prototype = &#123; constructor: BicycleShop, sellBicycle: function(model)&#123; var bicycle = this.createBicycle(model); // 执行A业务逻辑 bicycle.A(); // 执行B业务逻辑 bicycle.B(); return bicycle; &#125;, createBicycle: function(model)&#123; throw new Error(&quot;父类是抽象类不能直接调用，需要子类重写该方法&quot;); &#125; &#125;; //子类 var BicycleChild = function(name)&#123; this.name = name; // 继承构造函数父类中的属性和方法 BicycleShop.call(this,name); &#125;; // 子类继承父类原型方法 extend(BicycleChild,BicycleShop); // BicycleChild 子类重写父类的方法 BicycleChild.prototype.createBicycle = function()&#123; var A = function()&#123; console.log(&quot;执行A业务操作&quot;); &#125;; var B = function()&#123; console.log(&quot;执行B业务操作&quot;); &#125;; return &#123; A: A, B: B &#125;&#125;var childClass = new BicycleChild(&quot;捷安特&quot;);console.log(childClass);console.log(childClass.name);childClass.sellBicycle(&quot;model&quot;); extend子类继承父类原型方法函数的封装 12345678910111213141516171819202122function extend(Sub,Sup) &#123; //Sub表示子类，Sup表示超类 // 首先定义一个空函数 var F = function()&#123;&#125;; // 设置空函数的原型为超类的原型 F.prototype = Sup.prototype; // 实例化空函数，并把超类原型引用传递给子类 Sub.prototype = new F(); // 重置子类原型的构造器为子类自身 Sub.prototype.constructor = Sub; // 在子类中保存超类的原型,避免子类与超类耦合 Sub.sup = Sup.prototype; if(Sup.prototype.constructor === Object.prototype.constructor) &#123; // 检测超类原型的构造器是否为原型自身 Sup.prototype.constructor = Sup; &#125; &#125; 优点：1.弱化对象间的耦合，防止代码的重复。在一个方法中进行类的实例化，可以消除重复性的代码。 ​ 2.重复性的代码可以放在父类去编写，子类继承于父类的所有成员属性和方法，子类只专注于实现自己的业务逻辑。 单体模式(单例模式)对象以字面量的方式来创建单体模式 特点：如果可以实例化，只可以实例化一次 单体模式的基本结构：（使用一个变量来标识该类是否被实例化，如果未被实例化的话，那么我们可以实例化一次，否则的话，直接返回已经被实例化的对象。） 1234567891011121314151617181920212223// 单体模式var Singleton = function(name)&#123; this.name = name;&#125;;Singleton.prototype.getName = function()&#123; return this.name;&#125;// 获取实例对象function getInstance(name) &#123;var instance = null; if(!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;// 测试单体模式的实例var a = getInstance(&quot;aa&quot;);var b = getInstance(&quot;bb&quot;);console.log(a === b); // trueconsole.log(a.getName()); // aa 单体模式只能实例化一次console.log(b.getName()); // aa 单体模式实现弹窗一般情况下编写弹窗： 12345678910111213// 实现弹窗var createWindow = function()&#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是弹窗内容&quot;; div.style.display = &apos;none&apos;; document.body.appendChild(&apos;div&apos;); return div;&#125;;document.getElementById(&quot;Id&quot;).onclick = function()&#123; // 点击后先创建一个div元素 var win = createWindow(); //会频繁地创建div对象，降低性能 win.style.display = &quot;block&quot;;&#125; 用单例模式实现弹窗，只实例化一次 123456789101112131415161718// 实现单体模式弹窗var createWindow = (function()&#123; var div; return function()&#123; if(!div) &#123; div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是弹窗内容&quot;; div.style.display = &apos;none&apos;; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.getElementById(&quot;Id&quot;).onclick = function()&#123; // 点击后先创建一个div元素 var win = createWindow(); win.style.display = &quot;block&quot;;&#125; 封装单体模式函数123456var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); //调用当前对象的方法 &#125;&#125;; 测试单体模式函数 12345678910111213141516171819202122232425262728293031323334353637var createWindow = function()&#123; var div = document.createElement(&quot;div&quot;); div.innerHTML = &quot;我是弹窗内容&quot;; div.style.display = &apos;none&apos;; div.style.border = &apos;1px solid red&apos;; div.style.width = &apos;100px&apos;; div.style.height = &apos;100px&apos;; document.body.appendChild(div); return div;&#125;;// 创建iframevar createIframe = function()&#123; var iframe = document.createElement(&quot;iframe&quot;); iframe.style.width = &apos;500px&apos;; iframe.style.height = &apos;300px&apos;; document.body.appendChild(iframe); return iframe;&#125;;// 获取实例的封装代码var getInstance = function(fn) &#123; var result; return function()&#123; return result || (result = fn.call(this,arguments)); &#125;&#125;;// 测试创建divvar createSingleDiv = getInstance(createWindow);document.getElementById(&quot;btn&quot;).onclick = function()&#123; var win = createSingleDiv(); win.style.display = &quot;block&quot;;&#125;;// 测试创建iframevar createSingleIframe = getInstance(createIframe);document.getElementById(&quot;btn2&quot;).onclick = function()&#123; var win = createSingleIframe(); win.src = &quot;http://baidu.com&quot;;&#125;; 模块模式为单体模式添加私有变量和私有方法能够减少全局变量的使用。降低了代码的耦合度。沙箱模式 模块模式使用了一个返回对象的匿名函数。在这个匿名函数内部，先定义了私有变量和函数，供内部函数使用，然后将一个对象字面量作为函数的值返回，返回的对象字面量中只包含可以公开的属性和方法。 12345678910111213var singleMode = (function()&#123; // 创建私有变量 var privateNum = 112; // 创建私有函数 function privateFunc()&#123; // 实现自己的业务逻辑代码 &#125; // 返回一个对象包含公有方法和属性 return &#123; publicMethod1: publicMethod1, publicMethod2: publicMethod1 &#125;;&#125;)(); 模块增强模式 增强的模块模式的使用场合是：适合那些单列必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。 12345678910111213141516171819202122232425262728function CustomType() &#123; this.name = &quot;tugenhua&quot;;&#125;;CustomType.prototype.getName = function()&#123; return this.name;&#125;var application = (function()&#123; // 定义私有 var privateA = &quot;aa&quot;; // 定义私有函数 function A()&#123;&#125;; // 实例化一个对象后，返回该实例，然后为该实例增加一些公有属性和方法 var object = new CustomType(); // 添加公有属性 object.A = &quot;aa&quot;; // 添加公有方法 object.B = function()&#123; return privateA; &#125; // 返回该对象 return object;&#125;)();console.log(application.A);// aaconsole.log(application.B()); // aa //调用公有的函数访问私有数据console.log(application.name); // tugenhuaconsole.log(application.getName());// tugenhua 代理模式委托机制，新建一个对象代替本体对象被实例化。 比如现在京东ceo想送给奶茶妹一个礼物，但是呢假如该ceo不好意思送，或者由于工作忙没有时间送，那么这个时候他就想委托他的经纪人去做这件事，然后可以使用代理模式来编写如下代码： 123456789101112131415161718192021222324// 先申明一个奶茶妹对象var TeaAndMilkGirl = function(name) &#123; this.name = name;&#125;;// 这是京东ceo先生var Ceo = function(girl) &#123; this.girl = girl; // 送结婚礼物 给奶茶妹 this.sendMarriageRing = function(ring) &#123; console.log(&quot;Hi &quot; + this.girl.name + &quot;, ceo送你一个礼物：&quot; + ring); &#125;&#125;;// 京东ceo的经纪人是代理，来代替送var ProxyObj = function(girl)&#123; this.girl = girl; // 经纪人代理送礼物给奶茶妹 this.sendGift = function(gift) &#123; // 代理模式负责本体对象实例化 (new Ceo(this.girl)).sendMarriageRing(gift); &#125;&#125;;// 初始化var proxy = new ProxyObj(new TeaAndMilkGirl(&quot;奶茶妹&quot;));proxy.sendGift(&quot;结婚戒&quot;); // Hi 奶茶妹, ceo送你一个礼物：结婚戒 优点：1.代理对象可以代替本体被实例化，并使其可以被远程访问 ​ 2.它还可以把本体实例化推迟到真正需要的时候，对于实例化比较费时的本体对象，或者因为尺寸比较大以至于不用时不适于保存在内存中的本体，我们可以推迟实例化该对象 使用虚拟代理实现图片预加载不使用代理模式预加载图片 1234567891011121314151617// 不使用代理的预加载图片函数如下var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); var img = new Image(); img.onload = function()&#123; imgNode.src = this.src; &#125;; return &#123; setSrc: function(src) &#123; imgNode.src = &quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;; img.src = src; &#125; &#125;&#125;)();// 调用方式myImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;); 使用代理模式预加载图片 12345678910111213141516171819202122232425//创建图片var myImage = (function()&#123; var imgNode = document.createElement(&quot;img&quot;); document.body.appendChild(imgNode); return &#123; setSrc: function(src) &#123; imgNode.src = src; &#125; &#125;&#125;)();// 代理模式var ProxyImage = (function()&#123; var img = new Image(); img.onload = function()&#123; myImage.setSrc(this.src); &#125;; return &#123; setSrc: function(src) &#123; myImage.setSrc(&quot;http://img.lanrentuku.com/img/allimg/1212/5-121204193Q9-50.gif&quot;); img.src = src; &#125; &#125;&#125;)();// 调用方式ProxyImage.setSrc(&quot;https://img.alicdn.com/tps/i4/TB1b_neLXXXXXcoXFXXc8PZ9XXX-130-200.png&quot;); 优缺点： 第一种方案一般的方法代码的耦合性太高，一个函数内负责做了几件事情，比如创建img元素，和实现给未加载图片完成之前设置loading加载状态等多项事情，未满足面向对象设计原则中单一职责原则；并且当某个时候不需要代理的时候，需要从myImage 函数内把代码删掉，这样代码耦合性（关联程度）太高。 第二种方案使用代理模式，其中myImage 函数只负责做一件事，创建img元素加入到页面中，其中的加载loading图片交给代理函数ProxyImage 去做，当图片加载成功后，代理函数ProxyImage 会通知及执行myImage 函数的方法，同时当以后不需要代理对象的话，我们直接可以调用本体对象的方法即可。 虚拟代理合并http的请求比如在做后端系统中，有表格数据，每一条数据前面有复选框按钮，当点击复选框按钮时候，需要获取该id后需要传递给给服务器发送ajax请求，服务器端需要记录这条数据，去请求，如果我们每当点击一下向服务器发送一个http请求的话，对于服务器来说压力比较大，网络请求比较频繁，但是如果现在该系统的实时数据不是很高的话，我们可以通过一个代理函数收集一段时间内(比如说2-3秒)的所有id，一次性发ajax请求给服务器，相对来说网络请求降低了, 服务器压力减少了。 代理函数做一个暂存的功能，最后一次性提交。 缓存代理缓存代理的含义就是对第一次运行时候进行缓存，当再一次运行相同的时候，直接从缓存里面取，这样做的好处是避免重复一次运算功能，如果运算非常复杂的话，对性能很耗费，那么使用缓存对象可以提高性能。 发布-订阅模式（观察者模式）发布—订阅模式又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 例如：淘宝收藏店铺，卖家，买家的关系；angular框架的路由 优点 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。 发布者与订阅者耦合性降低，发布者只管发布一条消息出去，它不关心这条消息如何被订阅者使用，同时，订阅者只监听发布者的事件名，只要发布者的事件名不变，它不管发布者如何改变。 缺点 创建订阅者需要消耗一定的时间和内存。 如何实现发布-订阅模式 首先要想好谁是发布者（比如卖家）。 然后给发布者添加一个缓存列表，用于存放回调函数来通知订阅者(比如上面的买家收藏了卖家的店铺，卖家通过收藏了该店铺的一个列表名单)。 最后就是发布消息，发布者遍历这个缓存列表，依次触发里面存放的订阅者回调函数。（在callback函数中传入描述商品信息的参数）。 简单的发布-订阅模式 123456789101112131415161718192021222324252627var shoeObj = &#123;&#125;; // 定义发布者 淘宝店铺卖家shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(fn) &#123; shoeObj.list.push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; for(var i = 0,fn; fn = this.list[i++];) &#123; fn.apply(this,arguments); &#125;&#125;// 小红订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(&quot;颜色是：&quot;+color); console.log(&quot;尺码是：&quot;+size); &#125;);// 小花订阅如下消息shoeObj.listen(function(color,size)&#123; console.log(&quot;再次打印颜色是：&quot;+color); console.log(&quot;再次打印尺码是：&quot;+size); &#125;);shoeObj.trigger(&quot;红色&quot;,40);shoeObj.trigger(&quot;黑色&quot;,42); ​ 增强的发布-订阅模式（订阅者只订阅自己想要看的东西） 12345678910111213141516171819202122232425262728293031323334353637var shoeObj = &#123;&#125;; // 定义发布者shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者shoeObj.listen = function(key,fn) &#123; if(!this.list[key]) &#123; // 如果还没有订阅过此类消息，给该类消息创建一个缓存列表 this.list[key] = []; &#125; this.list[key].push(fn); // 订阅消息添加到缓存列表&#125;// 发布消息shoeObj.trigger = function()&#123; var key = Array.prototype.shift.call(arguments); // 取出消息类型名称 var fns = this.list[key]; // 取出该消息对应的回调函数的集合 // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++]; ) &#123; fn.apply(this,arguments); // arguments 是发布消息时附送的参数 &#125;&#125;;// 小红订阅如下消息shoeObj.listen(&apos;red&apos;,function(size)&#123; console.log(&quot;尺码是：&quot;+size); &#125;);// 小花订阅如下消息shoeObj.listen(&apos;black&apos;,function(size)&#123; console.log(&quot;再次打印尺码是：&quot;+size); &#125;);shoeObj.trigger(&quot;red&quot;,40);shoeObj.trigger(&quot;black&quot;,42); 发布-订阅模式代码封装123456789101112131415161718192021var event = &#123; list: [], listen: function(key,fn) &#123; if(!this.list[key]) &#123; this.list[key] = []; &#125; // 订阅的消息添加到缓存列表中 this.list[key].push(fn); &#125;, trigger: function()&#123; var key = Array.prototype.shift.call(arguments); var fns = this.list[key]; // 如果没有订阅过该消息的话，则返回 if(!fns || fns.length === 0) &#123; return; &#125; for(var i = 0,fn; fn = fns[i++];) &#123; fn.apply(this,arguments); &#125; &#125;&#125;; 测试封装代码 12345678910111213141516171819var initEvent = function(obj) &#123; for(var i in event) &#123; //遍历 obj[i] = event[i]; &#125;&#125;;var shoeObj = &#123;&#125;;initEvent(shoeObj);// 小红订阅如下消息shoeObj.listen(&apos;red&apos;,function(size)&#123; console.log(&quot;尺码是：&quot;+size); &#125;);// 小花订阅如下消息shoeObj.listen(&apos;black&apos;,function(size)&#123; console.log(&quot;再次打印尺码是：&quot;+size); &#125;);shoeObj.trigger(&quot;red&quot;,40);shoeObj.trigger(&quot;black&quot;,42);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"ES6的新特性let和const","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/ES6的新特性let和const/","text":"ES6的新特性let和constlet-块级作用域1.ES5中声明变量用var，ES6中用let声明变量，const声明常量。 2.在ES5中变量的作用域分为全局作用域和局部作用域，但是在ES6中新增了块级作用域。let的作用域是在声明变量最近的一对大括号内，var声明变量时是将变量添加到window下，而let不是。 1234567891011if(true)&#123; let i = 100; console.warn(i); //100 &#125; console.log(i); //undefined if(true)&#123; var i = 100; console.warn(i); //100 &#125;console.log(i); //100 3.在for循环遍历时适合使用let声明变量，来避免全局污染。 12345let globalValue = 100; for(let i = 0; i &lt; 10 ;i++)&#123; // i作用域 &#125; console.log(i); //i is not defined var和let的区别重复声明var可以重复声明变量，而let则不可以。 用var对变量再次声明时，最后一次的赋值会覆盖之前的，而let会报has been declared的错误。 123var a = 10;var a = 20;console.log(a); //20 变量提升var可以提升变量的声明，而let不可以。 12345console.log(a);var a = 10; //undefined a被定义了但是没有赋值，提升了变量声明console.log(a);let a = 10; //a is not defined a没有被定义 暂时性死区12345678910111213var i = 1;function foo()&#123; console.log(i); //undefined var i = &quot;hello&quot;; //局部变量声明提升&#125;let i = 1;function foo()&#123; //暂时性死区 console.log(i); //i is not defined i没有被定义 let i = &quot;hello&quot;; //暂时性死区&#125; const在ES6中用const声明常量，声明必须赋值且后期不能修改。 基本类型123const VALUE = 100;console.log(VALUE);VALUE = 200; //值不能改变 引用类型const声明一个对象时，可以修改对象成员 123456789const PERSON = &#123; name:&apos;Rose&apos;, age:18 &#125;; console.log(PERSON); //Rose 18 PERSON.name = &apos;Jack&apos;; PERSON.age = 100; console.log(PERSON); //Jack 100","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6的新特性Symbol","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/ES6-Symbol/","text":"Symbol1.Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值，减少命名冲突。 1234var a = Symbol(&apos;第一个symbol的值&apos;);var b = Symbol(&apos;第二个symbol的值&apos;);console.log(a === b);//falseconsole.log(a, b);//Symbol(第一个symbol的值) Symbol(第二个symbol的值) 2.Symbol值通过Symbol函数生成 12let s = Symbol();console.log(typeof s);//&quot;symbol&quot; 4.相同参数的Symbol函数的返回值是不相等的。 12345678//无参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2;//false//有参数的情况let s1 = Symbol(&apos;foo&apos;);let s2 = Symbol(&apos;foo&apos;);s1 === s2 // false 5.Symbol.for 1234var a = Symbol.for(&apos;keyA&apos;); // 创建一个Symbol的值var b = Symbol.for(&apos;keyA&apos;); // 存在，读取值console.log(a === b);//true 6.Symbol作为对象的属性名key（在ES5中key的值只能是字符串） 1234567891011121314151617var keyA = Symbol.for(&apos;KeyA&apos;); var person = &#123; name:&apos;Rose&apos;, age:18, [keyA]:&apos;abc&apos; &#125;; for(var key in person)&#123; //for-in遍历对象，不能遍历对象中的Symbol类型属性 console.log(key , person[key]); &#125;// name Rose// age 18 var keys = Object.getOwnPropertySymbols(person); //遍历对象中的Symbol类型属性 console.log(keys);// [Symbol(keyA)] 7.Symbol 值不能与其他类型的值进行运算，不能进行字符串的拼接。 8.Symbol可以转换为字符串类型和布尔类型，但是不能转换为数值类型。 123let sym = Symbol();String(sym)Boolean(sym)","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6新特性promise","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/promise封装ajax的get和post请求函数/","text":"promise封装ajax的get和post请求函数","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6新特性promise","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/ES6-promise对象/","text":"ES6新特性promisepromise的含义Promise 是异步编程的一种解决方案，从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。 存储多个等待的执行方法的容器。 promise的特点 对象状态不受外界影响。promise对象表示一个异步操作，有三种状态，pending（进行中），fulfilled（已成功）和rejected（已失败）。只有异步操作的结果可以决定当前处于哪种状态，其他操作都无法改变这个状态 一旦状态改变，就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。 promise的缺点 一旦新建，会立即执行，无法中途取消。 如果没有设置回调函数，promise内部抛出的错误无法反应到外部。 当处于pending状态时，无法得知当前进展到哪一阶段。 基本用法ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 1234567const promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); //已定型 &#125; else &#123; reject(error); //失败 &#125;&#125;); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 promise.then(promise对象状态变为resolved的回调函数,promise对象状态变为rejected的回调函数) 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 案例依次输出1,2,3 ES5实现方法1234567891011121314var showData = function(ms , cb)&#123; setTimeout(function()&#123; cb(); &#125; , ms); &#125;showData(2000 , function()&#123; console.log(1); showData(200 , function()&#123; console.log(2); showData(20 , function()&#123; console.log(3); &#125;); &#125;); &#125;); 注：以下代码可以达到相同效果，但是如果资源是图片，第一次请求的图片资源较大或者第二次请求资源较小时，依旧无法实现资源依次显示的效果。 123456showData(20 , function()&#123; console.log(1); &#125;);showData(200 , function()&#123; console.log(2); &#125;); ES6实现方法12345678910111213141516171819var showData = function(ms)&#123; var promise = new Promise(function(resolve)&#123; setTimeout(function()&#123; resolve(); &#125; , ms); &#125;); return promise; &#125; showData(2000).then(() =&gt; &#123; //2s后输出1 console.log(1); return showData(200); &#125;).then(() =&gt; &#123; //输出1后的0.2s后输出2 console.log(2); return showData(20); &#125;).then(() =&gt; &#123; console.log(3); &#125;);","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JavaScript数据类型和类型检测","date":"2018-12-02T16:00:00.000Z","path":"2018/12/03/数据类型和类型检测/","text":"JavaScript数据类型和类型检测JavaScript数据类型JavaScript数据类型主要分为两大类： 1.基本数据类型：字符串(String)，数字(Number)，布尔(Boolean)，空(Null)，未定义(Undefined)，(Symbol) 注:Symbol 是 ES6 引入的一种新的原始数据类型，表示独一无二的值，在此不作详细介绍。 2.复杂数据类型 (引用数据类型)：对象(Object) 基本类型String&amp;Number123var x; // x 为 undefinedvar x = 1; // x 为 numbervar x = &quot;hi&quot;; // x 为 string Boolean布尔（逻辑）只能有两个值：true 或 false。 Null&amp;Undefined1.Undefined 表示变量声明了但是没有赋值(未初始化)。 2.可以通过将变量的值设置为 null 来清空变量。 12var person = null;console.log(typeof person); // &quot;object&quot; 引用类型除了基本数据类型的数据其他数据都是对象（对象，函数，数组…）。 函数（Function）,数组（Array）都可以归为对象。 对象的基本信息：属性，行为（方法） 对象的类型：1.内置对象（原生对象）=&gt;RegExp，Date，Math…(js语言本身预定义的对象) ​ 2.宿主对象=&gt;BOM对象：History，Location，Window，Navigate，Screen ​ DOM对象：Body，Style，Meta，Frame，Frameset… 常用的Math内置对象：（Math对象中的属性和方法都是静态的，可以通过构造器名称访问，无需创建对象） 123456789Math.pow(n,m) n的m次方Math.sqrt 开根号Math.abs() 取绝对值Math.PI Math.random() 在[0,1）区间内取随机数exp:取10到20之间的随机数=&gt;parseInt(Math.random()*10)+10;Math.cei() 向上取整Math.floor() 向下取整Math.round() 四舍五入 可以通过两种方式访问对象的属性 obj.key obj[“key”] 创建对象的方式1.字面量的方式 1234567var obj = &#123; name:&quot;John&quot;, age:50, eyeColor:&quot;blue&quot;, eat:function()&#123;&#125;, sleep:function()&#123;&#125;&#125;; 2.通过new object创建对象 1234var obj = new Object();obj.name = &quot;Jhon&quot;;obj.age = 50;obj.eat = function()&#123;&#125;; 缺点：如果要创建多个对象，需要写很多重复代码。 3.工厂模式创建对象（用函数对第二种方式进行封装，使得相似对象的创建不需要重复代码） 123456function CreateObject(name,age)&#123; var obj = new Object(); obj.name = &quot;Jhon&quot;; obj.age = 50; return obj;&#125; 缺点：无法判断出所创建出对象的具体类型。 4.构造函数创建对象 12345function Person(name,age)&#123; this.name = name; this.age = age;&#125;var p1 = new Person(&quot;Jhon&quot;,50); //实例化 拓展：遍历数组的方式=&gt;for循环 for(var i=0;i&lt;arr.length;i++){} ​ 遍历对象的方式=&gt;for…in 1234567var Person =&#123; name: &quot;Jhon&quot;, age: 50&#125;for(var key in Person)&#123; console.log(key + &quot;:&quot; + Person.key);&#125; 函数的原型原型的作用：可以将对象所有公共的信息（属性和方法）放到原型对象中去。 如果函数和函数原型中有同名的信息，优先使用对象中的信息。 函数的原型prototype，_ proto _,以及函数本身的关系 123var foo = function()&#123;&#125;; =&gt; Function.prototype._ proto _ =&gt; Object.prototype._ proto _ =&gt; NULL 函数本身有一个prototype属性——函数原型（对象所有公共的属性和方法，constructor=&gt;指向函数本身） 函数对象里有一个属性_ proto _=&gt;指向函数原型prototype 123console.log(对象._proto_ === 函数.prototype) //trueconsole.log(对象._proto_.constructor == 函数) //trueconsole.log(函数.prototype.constructor == 函数) //true JavaScript数据类型检测typeof=&gt;string无法判断具体的引用类型数据，如数组 检测的不管是数组还是正则都返回的是”object”,所以typeof不能判断一个值是否为数组 12345678console.log(typeof &quot;&quot;); //stringconsole.log(typeof 1); //numberconsole.log(typeof true); //booleanconsole.log(typeof null); //objectconsole.log(typeof undefined); //undefinedconsole.log(typeof []); //objectconsole.log(typeof function()&#123;&#125;); //functionconsole.log(typeof &#123;&#125;); //object instanceof=&gt;boolean能够判断具体的引用类型（不能用于判断null和undefined） 基本数据类型的值是不能用instanceof来检测的 123456789console.log(&quot;1&quot; instanceof String); //flaseconsole.log(new String(&quot;1&quot;) instanceof String); //trueconsole.log(1 instanceof Number); //falseconsole.log(new Number(1) instanceof Number); //trueconsole.log(true instanceof Boolean); //falseconsole.log(new Boolean(true) instanceof Boolean); //trueconsole.log([] instanceof Array); //trueconsole.log(function()&#123;&#125; instanceof Function); //trueconsole.log(&#123;&#125; instanceof Object); //true constructor123456console.log((&quot;1&quot;).constructor === String); //trueconsole.log((1).constructor === Number); //trueconsole.log((true).constructor === Boolean); //trueconsole.log(([]).constructor === Array); //trueconsole.log((function() &#123;&#125;).constructor === Function); //trueconsole.log((&#123;&#125;).constructor === Object); //true constructor不适用情况 12345678function Fn()&#123;&#125;;Fn.prototype=new Array(); //函数的原型指向数组var f=new Fn(); //实例化console.log(f.constructor===Fn); //falseconsole.log(f.constructor===Array); //true Object.prototype.toString.call()12345678910var a = Object.prototype.toString;console.log(a.call(&quot;aaa&quot;)); //[object String]console.log(a.call(1)); //[object Number]console.log(a.call(true)); //[object Boolean]console.log(a.call(null)); //[object Null]console.log(a.call(undefined)); //[object Undefined]console.log(a.call([])); //[object Array]console.log(a.call(function() &#123;&#125;)); //[object Function]console.log(a.call(&#123;&#125;)); //[object Object] isNaN,isBoolean…12345678console.log(isObject(&#123;&#125;)); //trueconsole.log(isDate(new Date())); //trueconsole.log(isBoolean(false)); //trueconsole.log(isString(1)); //falseconsole.log(isError(1)); //falseconsole.log(isError(new Error())); //trueconsole.log(isArray([])); //trueconsole.log(isArray(1)); //false","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]}]